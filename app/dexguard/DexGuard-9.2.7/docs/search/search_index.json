{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the manual for DexGuard version 9.2.7 ( what's new? ). DexGuard is a specialized optimizer and obfuscator for Android applications. Once applied to your application or library, it produces code that is optimized and more difficult to crack. If you are getting started with DexGuard, please follow the quick start guide in order to arrive at basic setup for your application or library as quickly as possible. Once DexGuard successfully rebuilds your application or SDK make sure it's optimally protected by enabling additional features . If during this process you run into any issues, please make sure to check the Troubleshooting section .","title":"Home"},{"location":"addons_overview.html","text":"Introduction \u00b6 Besides its standard functionality, DexGuard offers following addons for extended functionality. They need to be purchased separately. If interest, please contact us . NDK : the DexGuard NDK add-on protects native libraries (written in C or C++) against reverse engineering and tampering by adding multiple layers of obfuscation and integrating RASP. Whenever integrating such a library in your app, you should consider additionally protecting it. Whitebox Cryptography : DexGuard's Java-based whitebox cryptography (WBC) solution. Device Fingerprinting : DexGuard\u2019s device fingerprinting SDK can determine the identity of devices, for instance as a parameter to assess the risk of sensitive transactions. Secure Keyboard : DexGuard offers an SDK with a keyboard implementation that is hardened against keylogging and other forms of snooping.","title":"Overview"},{"location":"addons_overview.html#introduction","text":"Besides its standard functionality, DexGuard offers following addons for extended functionality. They need to be purchased separately. If interest, please contact us . NDK : the DexGuard NDK add-on protects native libraries (written in C or C++) against reverse engineering and tampering by adding multiple layers of obfuscation and integrating RASP. Whenever integrating such a library in your app, you should consider additionally protecting it. Whitebox Cryptography : DexGuard's Java-based whitebox cryptography (WBC) solution. Device Fingerprinting : DexGuard\u2019s device fingerprinting SDK can determine the identity of devices, for instance as a parameter to assess the risk of sensitive transactions. Secure Keyboard : DexGuard offers an SDK with a keyboard implementation that is hardened against keylogging and other forms of snooping.","title":"Introduction"},{"location":"annotations.html","text":"In addition to the standard configuration via project-specific configuration files (typically proguard-project.txt or dexguard-project.txt ), DexGuard also supports annotation-based configuration. Dependencies for annotation-based configuration \u00b6 DexGuard comes with a separate jar that contains supported Java annotations. You can find the annotations jar in the DexGuard distribution at lib/dexguard-annotations.jar It is self-contained, and does not depend on any libraries, other than the Java Standard Library. Configuration changes for annotation-based configuration \u00b6 The DexGuard annotations are runtime-invisible. By default, D8/R8 strips such annotations when building release configurations, meaning DexGuard will not see them during post-processing. As a result, the annotation-based configuration will not be applied. To make sure the DexGuard annotations are not stripped, please follow the workaround on this page . Alternatively, you can switch to a file-based configuration instead, for which you can find more information here . Keep annotations for code \u00b6 The following annotations (all located in package proguard.annotation ) are supported: Annotation Target Description Equivalent configuration @Keep Class Field Method Preserves the annotated class/field/method. For classes : -keep class com.example.SomeClass For class members : -keepclassmembers class com.example.SomeClass { someMethod(); } @KeepName Class Field Method Preserves the name of the annotated class/field/method. For classes : -keepnames class SomeClass For class members : -keepclassmembernames class com.example.SomeClass { someMethod(); } @Keep \u200b ClassMembers Class Preserves all members of the annotated class. -keepclassmembers class com.example.SomeClass { *; } @KeepPublic \u200b ClassMembers Class Preserves all public members of the annotated class. -keepclassmembers public class com.example.SomeClass { public *; } @KeepPublicProtected \u200b ClassMembers Class Preserves all public and protected members of the annotated class. -keepclassmembers class com.example.SomeClass { public protected *; } @Keep \u200b ClassMemberNames Class Preserves the names of all members of the annotated class. -keepclassmembernames class com.example.SomeClass { *; } @KeepPublic \u200b ClassMemberNames Class Preserves the names of all public members of the annotated class. -keepclassmembernames class com.example.SomeClass { public *; } @KeepPublicProtected \u200b ClassMemberNames Class Preserves the names of all public and protected members of the annotated class. -keepclassmembernames class com.example.SomeClass { public protected *; } @Keep \u200b GettersSetters Class Preserves all getters and setters of the annotated class. -keepclassmembers class com.example.SomeClass { *** get*(); void set*(***)*; } @KeepPublic \u200b GettersSetters Class Preserves all public getters and setters of the annotated class. -keepclassmembers class com.example.SomeClass { public *** get*(); public void set*(***)*; } @Keep \u200b Implementations Class Preserves all classes the extend/implement the annotated class. -keep class * extends com.example.SomeClass @KeepPublic \u200b Implementations Class Preserves all public classes that extend/implement the annotated class. -keep public class * extends com.example.SomeClass The @Keep and @KeepName annotations, when applied to a class, will only preserve the class itself but not its members (i.e. fields and methods). In order to fully keep the class and all its members from being shrunk or obfuscated, you have to annotate the class also with @KeepClassMembers or @KeepClassMemberNames annotations like this: @Keep @KeepClassMembers public class SomeClass { ... } Obfuscation annotations \u00b6 The following annotations (located in package com.guardsquare.dexguard.annotation ) related to obfuscation are supported: Annotation Target Description Equivalent configuration @EncryptClass Class Encrypts the annotated class. -encryptclasses class com.example.SomeClass @EncryptString Field Encrypts the annotated final String field. -encryptstrings class com.example.SomeClass { final java.lang.String someField; } @EncryptStrings Class Method Encrypts all strings in the annotated class or method. -encryptstrings class com.example.SomeClass -encryptstrings class com.example.SomeClass { someMethod(); } @ObfuscateCodeLow Class Method Obfuscates the code attribute(s) of the annotated class or method with low strength. For classes : -obfuscatecode,low class com.example.SomeClass For methods : -obfuscatecode,low class com.example.SomeClass { someMethod(); } @ObfuscateCodeMedium Class Method Obfuscates the code attribute(s) of the annotated class or method with medium strength. For classes : -obfuscatecode,medium class com.example.SomeClass For methods : -obfuscatecode,medium class com.example.SomeClass { someMethod(); } @ObfuscateCodeHigh Class Method Obfuscates the code attribute(s) of the annotated class or method with high strength. For classes : -obfuscatecode,high class com.example.SomeClass For methods : -obfuscatecode,high class com.example.SomeClass { someMethod(); } @VirtualizeCode Class Method Virtualizes the code attribute(s) of the annotated class or method. For classes : -virtualizecode class com.example.SomeClass For methods : -virtualizecode class com.example.SomeClass { someMethod(); }","title":"Annotations"},{"location":"annotations.html#dependencies-for-annotation-based-configuration","text":"DexGuard comes with a separate jar that contains supported Java annotations. You can find the annotations jar in the DexGuard distribution at lib/dexguard-annotations.jar It is self-contained, and does not depend on any libraries, other than the Java Standard Library.","title":"Dependencies for annotation-based configuration"},{"location":"annotations.html#configuration-changes-for-annotation-based-configuration","text":"The DexGuard annotations are runtime-invisible. By default, D8/R8 strips such annotations when building release configurations, meaning DexGuard will not see them during post-processing. As a result, the annotation-based configuration will not be applied. To make sure the DexGuard annotations are not stripped, please follow the workaround on this page . Alternatively, you can switch to a file-based configuration instead, for which you can find more information here .","title":"Configuration changes for annotation-based configuration"},{"location":"annotations.html#keep-annotations-for-code","text":"The following annotations (all located in package proguard.annotation ) are supported: Annotation Target Description Equivalent configuration @Keep Class Field Method Preserves the annotated class/field/method. For classes : -keep class com.example.SomeClass For class members : -keepclassmembers class com.example.SomeClass { someMethod(); } @KeepName Class Field Method Preserves the name of the annotated class/field/method. For classes : -keepnames class SomeClass For class members : -keepclassmembernames class com.example.SomeClass { someMethod(); } @Keep \u200b ClassMembers Class Preserves all members of the annotated class. -keepclassmembers class com.example.SomeClass { *; } @KeepPublic \u200b ClassMembers Class Preserves all public members of the annotated class. -keepclassmembers public class com.example.SomeClass { public *; } @KeepPublicProtected \u200b ClassMembers Class Preserves all public and protected members of the annotated class. -keepclassmembers class com.example.SomeClass { public protected *; } @Keep \u200b ClassMemberNames Class Preserves the names of all members of the annotated class. -keepclassmembernames class com.example.SomeClass { *; } @KeepPublic \u200b ClassMemberNames Class Preserves the names of all public members of the annotated class. -keepclassmembernames class com.example.SomeClass { public *; } @KeepPublicProtected \u200b ClassMemberNames Class Preserves the names of all public and protected members of the annotated class. -keepclassmembernames class com.example.SomeClass { public protected *; } @Keep \u200b GettersSetters Class Preserves all getters and setters of the annotated class. -keepclassmembers class com.example.SomeClass { *** get*(); void set*(***)*; } @KeepPublic \u200b GettersSetters Class Preserves all public getters and setters of the annotated class. -keepclassmembers class com.example.SomeClass { public *** get*(); public void set*(***)*; } @Keep \u200b Implementations Class Preserves all classes the extend/implement the annotated class. -keep class * extends com.example.SomeClass @KeepPublic \u200b Implementations Class Preserves all public classes that extend/implement the annotated class. -keep public class * extends com.example.SomeClass The @Keep and @KeepName annotations, when applied to a class, will only preserve the class itself but not its members (i.e. fields and methods). In order to fully keep the class and all its members from being shrunk or obfuscated, you have to annotate the class also with @KeepClassMembers or @KeepClassMemberNames annotations like this: @Keep @KeepClassMembers public class SomeClass { ... }","title":"Keep annotations for code"},{"location":"annotations.html#obfuscation-annotations","text":"The following annotations (located in package com.guardsquare.dexguard.annotation ) related to obfuscation are supported: Annotation Target Description Equivalent configuration @EncryptClass Class Encrypts the annotated class. -encryptclasses class com.example.SomeClass @EncryptString Field Encrypts the annotated final String field. -encryptstrings class com.example.SomeClass { final java.lang.String someField; } @EncryptStrings Class Method Encrypts all strings in the annotated class or method. -encryptstrings class com.example.SomeClass -encryptstrings class com.example.SomeClass { someMethod(); } @ObfuscateCodeLow Class Method Obfuscates the code attribute(s) of the annotated class or method with low strength. For classes : -obfuscatecode,low class com.example.SomeClass For methods : -obfuscatecode,low class com.example.SomeClass { someMethod(); } @ObfuscateCodeMedium Class Method Obfuscates the code attribute(s) of the annotated class or method with medium strength. For classes : -obfuscatecode,medium class com.example.SomeClass For methods : -obfuscatecode,medium class com.example.SomeClass { someMethod(); } @ObfuscateCodeHigh Class Method Obfuscates the code attribute(s) of the annotated class or method with high strength. For classes : -obfuscatecode,high class com.example.SomeClass For methods : -obfuscatecode,high class com.example.SomeClass { someMethod(); } @VirtualizeCode Class Method Virtualizes the code attribute(s) of the annotated class or method. For classes : -virtualizecode class com.example.SomeClass For methods : -virtualizecode class com.example.SomeClass { someMethod(); }","title":"Obfuscation annotations"},{"location":"attributes.html","text":"Class files essentially define classes, their fields, and their methods. A lot of essential and non-essential data are attached to these classes, fields, and methods as attributes . For instance, attributes can contain bytecode, source file names, line number tables, etc. DexGuard's obfuscation step removes attributes that are generally not necessary for executing the code. With the -keepattributes option, you can specify a filter for attributes that you do want to keep, for instance if your code accesses them through reflection, or if you want to preserve some compilation or debugging information. The filter works like any filter in DexGuard. The following wildcards are supported: Wildcard Meaning ? matches any single character in an attribute name. * matches any part of an attribute name. An attribute name that is preceded by an exclamation mark ' ! ' is excluded from further attempts to match with subsequent attribute names in the filter. Make sure to specify filters correctly, since they are not checked for potential typos. For example, the following setting preserves the optional attributes that are typically necessary when processing code that is intended to be used as a library: -keepattributes Exceptions , InnerClasses , Signature , Deprecated , SourceFile , LineNumberTable , *Annotation* , EnclosingMethod The Java bytecode specifications currently specify the following list of attributes. Optional attributes \u00b6 DexGuard's obfuscation step by default discards the following optional attributes. You can keep them with the -keepattributes option. SourceFile Specifies the name of the source file from which the class file was compiled. If present, this name is reported in stack traces. SourceDir (J++ extension) Specifies the name of the source directory from which the class file was compiled. Record (Java 14 or higher) Specifies the components of a record class. Code may access this information by reflection. InnerClasses Specifies the relationship between a class and its inner classes and outer classes. Other than this and the naming convention with a '\\$' separator between the names of inner classes and outer classes, inner classes are just like ordinary classes. Compilers may need this information to find classes referenced in a compiled library. Code may access this information by reflection, for instance to derive the simple name of the class. PermittedSubclasses (Java 15 or higher) Specifies the allowed extensions or implementations of sealed classes or interfaces. EnclosingMethod (Java 5 or higher) Specifies the method in which the class was defined. Compilers may need this information to find classes referenced in a compiled library. Code may access this information by reflection, for instance to derive the simple name of the class. Deprecated Indicates that the class, field, or method is deprecated. Synthetic Indicates that the class, field, or method was generated by the compiler. Signature (Java 5 or higher) Specifies the generic signature of the class, field, or method. Compilers may need this information to properly compile classes that use generic types from compiled libraries. Code may access this signature by reflection. MethodParameters (Java 8 or higher) Specifies the names and access flags of the parameters of the method. Code may access this information by reflection. Exceptions Specifies the exceptions that a method may throw. Compilers may use this information to enforce catching them. LineNumberTable Specifies the line numbers of the method. If present, these line numbers are reported in stack traces. LocalVariableTable Specifies the names and types of local variables of the method. If present, some IDEs may use this information for helping with auto-completion. LocalVariableTypeTable (Java 5 or higher) Specifies the names and generic types of local variables of the method. If present, some IDEs may use this information for helping with auto-completion. RuntimeVisibleAnnotations (Java 5 or higher) Specifies the annotations that are visible at run-time, for classes, fields, and methods. Compilers and annotation processors may use these annotations. Code may access them by reflection. RuntimeInvisibleAnnotations (Java 5 or higher) Specifies the annotations that are visible at compile-time, for classes, fields, and methods. Compilers and annotation processors may use these annotations. RuntimeVisibleParameterAnnotations (Java 5 or higher) Specifies the annotations that are visible at run-time, for method parameters. Compilers and annotation processors may use these annotations. Code may access them by reflection. RuntimeInvisibleParameterAnnotations (Java 5 or higher) Specifies the annotations that are visible at compile-time, for method parameters. Compilers and annotation processors may use these annotations. RuntimeVisibleTypeAnnotations (Java 8 or higher) Specifies the annotations that are visible at run-time, for generic types, instructions, etc. Compilers and annotation processors may use these annotations. Code may access them by reflection. RuntimeInvisibleTypeAnnotations (Java 8 or higher) Specifies the annotations that are visible at compile-time, for generic types, instructions, etc. Compilers and annotation processors may use these annotations. AnnotationDefault (Java 5 or higher) Specifies a default value for an annotation. Essential attributes \u00b6 DexGuard automatically keeps the following essential attributes, processing them as necessary. We're listing them for the sake of completeness: ConstantValue Specifies a constant integer, float, class, string, etc. Code Specifies the actual bytecode of a method. StackMap (Java Micro Edition) Provides preverification information. The Java Virtual Machine can use this information to speed up the verification step when loading a class. StackMapTable (Java 6 or higher) Provides preverification information. The Java Virtual Machine can use this information to speed up the verification step when loading a class. BootstrapMethods (Java 7 or higher) Specifies the methods to bootstrap dynamic method invocations. Module (Java 9 or higher) Specifies the dependencies of a module . ModuleMainClass (Java 9 or higher) Specifies the main class of a module . ModulePackages (Java 9 or higher) Specifies the packages of a module . NestHost (Java 11 or higher) Specifies the host class of a nest , for example an outer class. NestMembers (Java 11 or higher) Specifies the members of a nest , for example the inner classes.","title":"Attributes"},{"location":"attributes.html#optional-attributes","text":"DexGuard's obfuscation step by default discards the following optional attributes. You can keep them with the -keepattributes option. SourceFile Specifies the name of the source file from which the class file was compiled. If present, this name is reported in stack traces. SourceDir (J++ extension) Specifies the name of the source directory from which the class file was compiled. Record (Java 14 or higher) Specifies the components of a record class. Code may access this information by reflection. InnerClasses Specifies the relationship between a class and its inner classes and outer classes. Other than this and the naming convention with a '\\$' separator between the names of inner classes and outer classes, inner classes are just like ordinary classes. Compilers may need this information to find classes referenced in a compiled library. Code may access this information by reflection, for instance to derive the simple name of the class. PermittedSubclasses (Java 15 or higher) Specifies the allowed extensions or implementations of sealed classes or interfaces. EnclosingMethod (Java 5 or higher) Specifies the method in which the class was defined. Compilers may need this information to find classes referenced in a compiled library. Code may access this information by reflection, for instance to derive the simple name of the class. Deprecated Indicates that the class, field, or method is deprecated. Synthetic Indicates that the class, field, or method was generated by the compiler. Signature (Java 5 or higher) Specifies the generic signature of the class, field, or method. Compilers may need this information to properly compile classes that use generic types from compiled libraries. Code may access this signature by reflection. MethodParameters (Java 8 or higher) Specifies the names and access flags of the parameters of the method. Code may access this information by reflection. Exceptions Specifies the exceptions that a method may throw. Compilers may use this information to enforce catching them. LineNumberTable Specifies the line numbers of the method. If present, these line numbers are reported in stack traces. LocalVariableTable Specifies the names and types of local variables of the method. If present, some IDEs may use this information for helping with auto-completion. LocalVariableTypeTable (Java 5 or higher) Specifies the names and generic types of local variables of the method. If present, some IDEs may use this information for helping with auto-completion. RuntimeVisibleAnnotations (Java 5 or higher) Specifies the annotations that are visible at run-time, for classes, fields, and methods. Compilers and annotation processors may use these annotations. Code may access them by reflection. RuntimeInvisibleAnnotations (Java 5 or higher) Specifies the annotations that are visible at compile-time, for classes, fields, and methods. Compilers and annotation processors may use these annotations. RuntimeVisibleParameterAnnotations (Java 5 or higher) Specifies the annotations that are visible at run-time, for method parameters. Compilers and annotation processors may use these annotations. Code may access them by reflection. RuntimeInvisibleParameterAnnotations (Java 5 or higher) Specifies the annotations that are visible at compile-time, for method parameters. Compilers and annotation processors may use these annotations. RuntimeVisibleTypeAnnotations (Java 8 or higher) Specifies the annotations that are visible at run-time, for generic types, instructions, etc. Compilers and annotation processors may use these annotations. Code may access them by reflection. RuntimeInvisibleTypeAnnotations (Java 8 or higher) Specifies the annotations that are visible at compile-time, for generic types, instructions, etc. Compilers and annotation processors may use these annotations. AnnotationDefault (Java 5 or higher) Specifies a default value for an annotation.","title":"Optional attributes"},{"location":"attributes.html#essential-attributes","text":"DexGuard automatically keeps the following essential attributes, processing them as necessary. We're listing them for the sake of completeness: ConstantValue Specifies a constant integer, float, class, string, etc. Code Specifies the actual bytecode of a method. StackMap (Java Micro Edition) Provides preverification information. The Java Virtual Machine can use this information to speed up the verification step when loading a class. StackMapTable (Java 6 or higher) Provides preverification information. The Java Virtual Machine can use this information to speed up the verification step when loading a class. BootstrapMethods (Java 7 or higher) Specifies the methods to bootstrap dynamic method invocations. Module (Java 9 or higher) Specifies the dependencies of a module . ModuleMainClass (Java 9 or higher) Specifies the main class of a module . ModulePackages (Java 9 or higher) Specifies the packages of a module . NestHost (Java 11 or higher) Specifies the host class of a nest , for example an outer class. NestMembers (Java 11 or higher) Specifies the members of a nest , for example the inner classes.","title":"Essential attributes"},{"location":"codepush.html","text":"This page explains how you can apply DexGuard protection to your code push update as well. This is a separate step from protecting the app you upload to the Play Store or App store and requires no changes to its configuration or setup. Both React Native and Cordova code push updates are supported, you can find samples for the Android case in the samples/advanced/CodePush directory. Only JavaScript supported Right now, only the JavaScript part of the code push update can be protected by DexGuard. Asset and resource files are not supported at the moment. iOS apps While DexGuard can only process Android apps (and not iOS apps), it can process code push updates for both Android and iOS. The steps for both are very similar and any differences are indicated by tabs on this page. DexGuard standalone \u00b6 You can process your code push update by calling DexGuard on the command line. First, you must generate the code push update. Android React Native react-native bundle \\ --platform android \\ --entry-file index.js \\ --bundle-output CodePush/index.android.bundle \\ --assets-dest CodePush Make sure the CodePush directory exists before you execute this command. Cordova cordova prepare android iOS React Native react-native bundle \\ --platform ios \\ --entry-file index.js \\ --bundle-output CodePush/index.ios.bundle \\ --assets-dest CodePush Make sure the CodePush directory exists before you execute this command. Cordova cordova prepare ios Once the code push update has been generated, you can call DexGuard to process it. React Native java -jar <dexguard-dir>/lib/dexguard.jar \\ -injars CodePush \\ -outjars CodePush-protected \\ -obfuscatejavascript **.bundle \\ -javascriptconfiguration javascript.yml Cordova java -jar <dexguard-dir>/lib/dexguard.jar \\ -injars platforms/android/app/src/main/assets/www \\ -outjars www-protected \\ -obfuscatejavascript **.js,**.html \\ -javascriptconfiguration javascript.yml DexGuard will generate the protected code push update to the path specified in -outjars . You can then simply upload it to the app center. React Native appcenter codepush release \\ -a <ownerName>/<appName> \\ -c CodePush-protected \\ -t <version> \\ -d <deployment> Cordova appcenter codepush release \\ -a <ownerName>/<appName> \\ -c www-protected \\ -t <version> \\ -d <deployment> Using the DexGuard gradle plugin \u00b6 Alternatively, the DexGuard gradle plugin provides a processCodePushUpdateWithDexGuard task which can do all of these things for you. To gain access to this task you simply extend your DexGuard configuration with a codePush block. In this block you have to tell DexGuard where it can find the code push update and which javascript configuration you want to process the update with. Groovy dexguard { path = '/path/to/DexGuard' license = '/path/to/dexguard_license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } codePush { inputLocation = '/path/to/CodePush' configuration = '/path/to/javascript.yml' } } Kotlin dexguard { path = \"/path/to/DexGuard\" license = \"/path/to/dexguard_license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } codePush { inputLocation = \"/path/to/CodePush\" configuration = \"/path/to/javascript.yml\" } } Once you have configured the task, you can execute it with the following command: Linux/macOS ./gradlew processCodePushUpdateWithDexGuard Windows gradlew processCodePushUpdateWithDexGuard The task will place your protected code push update in the outputs/dexguard/codepush directory. Limitations \u00b6 Cordova \u00b6 When using the DexGuard Cordova plugin you can encrypt the app's asset files. This is not supported when processing your code push updates. You can still encrypt the assets when protecting your app (for upload to the Play store), but once these assets are updated as part of a code push update the encryption will be removed. React Native \u00b6 When processing the app you cannot encrypt any asset or resource file, this includes the JavaScript bundle file. The same is true when processing the code push update, encrypting any of the asset or resource files is unsupported. Organizational tips \u00b6 Put your DexGuard options in a file \u00b6 You can simplify the command you have to type by storing the DexGuard options in a file, dexguard-codepush.txt for example. React Native -injars CodePush -outjars CodePush-protected -obfuscatejavascript **.bundle -javascriptconfiguration javascript.yml Cordova -injars platforms/android/app/src/main/assets/www -outjars www-protected -obfuscatejavascript **.js,**.html -javascriptconfiguration javascript.yml You can then call DexGuard and pass in this file. java -jar <dexguard-dir>/lib/dexguard.jar -include dexguard-codepush.txt Share your configuration \u00b6 You may have noticed that you have to configure JavaScript obfuscation when processing both your app and code push update. It is possibe to share this configuration, simply put the common parts in a separate file, dexguard-javascript.txt for example. React- Native -obfuscatejavascript **.bundle -javascriptconfiguration javascript.yml Cordova -obfuscatejavascript **.js,**.html -javascriptconfiguration javascript.yml You can then include this file when processing your app and code push update Processing app (build.gradle) dexguard { ... configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'dexguard-javascript.txt' } } } Processing code push update java -jar <dexguard-dir>/lib/dexguard.jar \\ -include dexguard-codepush.txt \\ -include dexguard-javascript.txt Alternatively, you can also include the dexguard-javascript.txt configuration file in your configurations directory using the -include option. Below is an example of this in dexguard-codepush.txt . React Native -injars CodePush -outjars CodePush-protected -include dexguard-javascript.txt Cordova -injars platforms/android/app/src/main/assets/www -outjars www-protected -include dexguard-javascript.txt Differing paths Be warned that the files have a different path in the app than they have in the code push update, so the rules to target them might differ! For example, when using Cordova and trying to obfuscate the index.js file you would use the following rule for the app -obfuscatejavascript assets/www/js/index.js and this rule for the code push update -obfuscatejavascript www/js/index.js Android For React Native you would use this rule for the app -obfuscatejavascript assets/index.android.bundle and the rule below for the code push update (assuming the root directory we used in our examples above) -obfuscatejavascript CodePush/index.android.bundle iOS For React Native you would use this rule for the app -obfuscatejavascript assets/index.ios.bundle and the rule below for the code push update (assuming the root directory we used in our examples above) -obfuscatejavascript CodePush/index.ios.bundle The rules given as an example on this page work for both apps and code push updates due to the use of wildcards.","title":"Code Push"},{"location":"codepush.html#dexguard-standalone","text":"You can process your code push update by calling DexGuard on the command line. First, you must generate the code push update. Android React Native react-native bundle \\ --platform android \\ --entry-file index.js \\ --bundle-output CodePush/index.android.bundle \\ --assets-dest CodePush Make sure the CodePush directory exists before you execute this command. Cordova cordova prepare android iOS React Native react-native bundle \\ --platform ios \\ --entry-file index.js \\ --bundle-output CodePush/index.ios.bundle \\ --assets-dest CodePush Make sure the CodePush directory exists before you execute this command. Cordova cordova prepare ios Once the code push update has been generated, you can call DexGuard to process it. React Native java -jar <dexguard-dir>/lib/dexguard.jar \\ -injars CodePush \\ -outjars CodePush-protected \\ -obfuscatejavascript **.bundle \\ -javascriptconfiguration javascript.yml Cordova java -jar <dexguard-dir>/lib/dexguard.jar \\ -injars platforms/android/app/src/main/assets/www \\ -outjars www-protected \\ -obfuscatejavascript **.js,**.html \\ -javascriptconfiguration javascript.yml DexGuard will generate the protected code push update to the path specified in -outjars . You can then simply upload it to the app center. React Native appcenter codepush release \\ -a <ownerName>/<appName> \\ -c CodePush-protected \\ -t <version> \\ -d <deployment> Cordova appcenter codepush release \\ -a <ownerName>/<appName> \\ -c www-protected \\ -t <version> \\ -d <deployment>","title":"DexGuard standalone"},{"location":"codepush.html#using-the-dexguard-gradle-plugin","text":"Alternatively, the DexGuard gradle plugin provides a processCodePushUpdateWithDexGuard task which can do all of these things for you. To gain access to this task you simply extend your DexGuard configuration with a codePush block. In this block you have to tell DexGuard where it can find the code push update and which javascript configuration you want to process the update with. Groovy dexguard { path = '/path/to/DexGuard' license = '/path/to/dexguard_license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } codePush { inputLocation = '/path/to/CodePush' configuration = '/path/to/javascript.yml' } } Kotlin dexguard { path = \"/path/to/DexGuard\" license = \"/path/to/dexguard_license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } codePush { inputLocation = \"/path/to/CodePush\" configuration = \"/path/to/javascript.yml\" } } Once you have configured the task, you can execute it with the following command: Linux/macOS ./gradlew processCodePushUpdateWithDexGuard Windows gradlew processCodePushUpdateWithDexGuard The task will place your protected code push update in the outputs/dexguard/codepush directory.","title":"Using the DexGuard gradle plugin"},{"location":"codepush.html#limitations","text":"","title":"Limitations"},{"location":"codepush.html#cordova","text":"When using the DexGuard Cordova plugin you can encrypt the app's asset files. This is not supported when processing your code push updates. You can still encrypt the assets when protecting your app (for upload to the Play store), but once these assets are updated as part of a code push update the encryption will be removed.","title":"Cordova"},{"location":"codepush.html#react-native","text":"When processing the app you cannot encrypt any asset or resource file, this includes the JavaScript bundle file. The same is true when processing the code push update, encrypting any of the asset or resource files is unsupported.","title":"React Native"},{"location":"codepush.html#organizational-tips","text":"","title":"Organizational tips"},{"location":"codepush.html#put-your-dexguard-options-in-a-file","text":"You can simplify the command you have to type by storing the DexGuard options in a file, dexguard-codepush.txt for example. React Native -injars CodePush -outjars CodePush-protected -obfuscatejavascript **.bundle -javascriptconfiguration javascript.yml Cordova -injars platforms/android/app/src/main/assets/www -outjars www-protected -obfuscatejavascript **.js,**.html -javascriptconfiguration javascript.yml You can then call DexGuard and pass in this file. java -jar <dexguard-dir>/lib/dexguard.jar -include dexguard-codepush.txt","title":"Put your DexGuard options in a file"},{"location":"codepush.html#share-your-configuration","text":"You may have noticed that you have to configure JavaScript obfuscation when processing both your app and code push update. It is possibe to share this configuration, simply put the common parts in a separate file, dexguard-javascript.txt for example. React- Native -obfuscatejavascript **.bundle -javascriptconfiguration javascript.yml Cordova -obfuscatejavascript **.js,**.html -javascriptconfiguration javascript.yml You can then include this file when processing your app and code push update Processing app (build.gradle) dexguard { ... configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'dexguard-javascript.txt' } } } Processing code push update java -jar <dexguard-dir>/lib/dexguard.jar \\ -include dexguard-codepush.txt \\ -include dexguard-javascript.txt Alternatively, you can also include the dexguard-javascript.txt configuration file in your configurations directory using the -include option. Below is an example of this in dexguard-codepush.txt . React Native -injars CodePush -outjars CodePush-protected -include dexguard-javascript.txt Cordova -injars platforms/android/app/src/main/assets/www -outjars www-protected -include dexguard-javascript.txt Differing paths Be warned that the files have a different path in the app than they have in the code push update, so the rules to target them might differ! For example, when using Cordova and trying to obfuscate the index.js file you would use the following rule for the app -obfuscatejavascript assets/www/js/index.js and this rule for the code push update -obfuscatejavascript www/js/index.js Android For React Native you would use this rule for the app -obfuscatejavascript assets/index.android.bundle and the rule below for the code push update (assuming the root directory we used in our examples above) -obfuscatejavascript CodePush/index.android.bundle iOS For React Native you would use this rule for the app -obfuscatejavascript assets/index.ios.bundle and the rule below for the code push update (assuming the root directory we used in our examples above) -obfuscatejavascript CodePush/index.ios.bundle The rules given as an example on this page work for both apps and code push updates due to the use of wildcards.","title":"Share your configuration"},{"location":"configuration.html","text":"When processing an application using DexGuard, the first step is to make sure that the processed application still works. In principle, DexGuard leaves the functionality of the application unchanged. However, if any code in the application performs reflection on classes, fields, methods, resources, resource files, asset files, or native libraries, then DexGuard may need some hints in its configuration, so it doesn't remove or rename these elements. These sections provide some tips to create a working configuration as quickly as possible. Iterating over your configuration \u00b6 Protection Report \u00b6 DexGuard automatically produces a visual HTML report to help you improve the overall security of your DexGuard hardened builds. This Protection Report allows you to continuously assess and improve the protection of your application or library. It provides: Key technical risk metrics. Protection feature status and impact overview. Tailored configuration improvement advice. When used as a stand-alone application, DexGuard generates the protection reports in the reports directory under the name protectionreport.html . When using the DexGuard Gradle plugin , the reports are generated in the default gradle output directory. In order to disable the generation of such reports after a DexGuard build, simply include the -disableprotectionreport setting in your configuration file. Telemetry \u00b6 Whenever your build system has an external connection to the internet, DexGuard sends telemetry data for Guardsquare's servers. The telemetry data is also dumped to a JSON file (telemetry_dump.json) so that you can review the data collected by Guardsquare. The collected telemetry data will be very helpful for us with effectively supporting you with your support tickets. Info The collected Telemetry data will never expose any sensitive info like string or class names. Rather, it will focus on the used features and their effectivenes. The collection of this data allows Guardsquare to further enhance DexGuard for you, based on real usage of its features. This behavior can be disabled by using the -disabletelemetry config option. Best Practices \u00b6 Consider any reflection in your application \u00b6 Your application may be calling any of the following methods with non-trivial (non-constant) arguments. You then need to preserve the corresponding element of the application. Class.forName(...) \u00b6 You may need to explicitly preserve the class or classes that are loaded dynamically, with their original names. For example: -keep class com.example.SomeClass Class#getField(...) Class#getDeclaredField(...) \u00b6 You may need to explicitly preserve the field or fields that are accessed dynamically, with their original names. For example: -keepclassmembers class com.example.SomeClass { <fields> ; } Class#getMethod(...) Class#getDeclaredMethod(...) \u00b6 You may need to explicitly preserve the method or methods that are accessed dynamically, with their original names. For example: -keepclassmembers class com.example.SomeClass { <methods> ; } AtomicIntegerFieldUpdater.newUpdater(...) AtomicLongFieldUpdater.newUpdater(...) AtomicReferenceFieldUpdater.newUpdater(...) \u00b6 You may need to explicitly preserve the field or fields that are accessed dynamically, with their original names. For example: -keepclassmembers class com.example.SomeClass { <fields> ; } Resources#getIdentifier(...) \u00b6 You may need to explicitly preserve the resource or resources that are accessed dynamically, with their original names. For example: -keepresources string/some_string AssetManager#open(...) AssetManager#openFd(...) Typeface.createFromAsset(...) \u00b6 You may need to explicitly preserve the asset file or files that are opened, with their original names. For example: -keepresourcefiles assets/some_assets.txt System.loadLibrary(...) \u00b6 You may need to explicitly preserve the native library or libraries that are loaded dynamically, with their original names. For example: -keepresourcefiles lib/*/libsomelibrary.so These constructs may of course be hidden inside third-party libraries. DexGuard's default configuration takes care of various popular libraries. Some common libraries require special attention: GSON \u00b6 The GSON library performs reflection on the names of the fields that it serializes and deserializes. These names directly correspond to the JSON strings. You therefore need to preserve them, in order not to break the strings. -keepclassmembers class com.example.SerializedClass { <fields> ; } You can find more details in the GSON example and a sample project in samples/advanced/GSON . Dagger \u00b6 The Dagger 1 framework generates classes at compile time and links them to their base classes at run-time, based on their names. You still need to manually preserve the corresponding base classes in your project. For example, for a generated class like com.example.SomeClass$$ModuleAdapter , you still need to specify: -keep class com.example.SomeClass That way, Dagger can combine the corresponding pairs of classes, based on their names. You can figure out the base classes by listing the generated classes in the gen directory of your project (e.g. com/examples/SomeClass$$ModuleAdapter.class ). You can find more details in the Dagger example and a sample project in samples/advanced/Dagger . Dagger 2 no longer relies on these naming conventions, which makes configuring for it a lot easier. In all of the above examples, you can use wildcards and more complex patterns in the specifications, e.g. to match all classes in specified packages. Get configuration suggestions at run-time \u00b6 DexGuard can instrument the application to debug the configuration: -addconfigurationdebugging If an error occurs at runtime due to shrinking or obfuscation, the application may print out configuration suggestions to solve the issue. You can find these messages in the run-time log of the application. You should make sure that you disable this setting again when you create an actual release version of your application. Tune the obfuscation level \u00b6 In case of problems, you can easily switch the default configuration in your Gradle configuration, with slightly different levels of obfuscation: Groovy dexguard { ... configurations { defaultConfiguration 'dexguard-release-aggressive.pro' ... } ... } or dexguard { ... configurations { defaultConfiguration 'dexguard-release.pro' ... } ... } or dexguard { ... configurations { defaultConfiguration 'dexguard-release-conservative.pro' ... } ... } Kotlin dexguard { ... configurations { defaultConfiguration ( \"dexguard-release-aggressive.pro\" ) ... } ... } or dexguard { ... configurations { defaultConfiguration ( \"dexguard-release.pro\" ) ... } ... } or dexguard { ... configurations { defaultConfiguration ( \"dexguard-release-conservative.pro\" ) ... } ... } Disable obfuscation for third-party libraries \u00b6 If a third-party library is causing problems, the most conservative approach is to disable its obfuscation: -keep , includecode class com.example.library.** { * ; } Such a configuration is generally not optimal, especially for large or sensitive libraries, but it can be a start. If it helps, you can try tuning the configuration, for example by only keeping the classes with their original names, but not necessarily their fields or methods: -keep class com.example.library.** Disable individual obfuscation features \u00b6 When tracking down issues, you can try disabling individual processing steps: -dontshrink -dontoptimize -dontobfuscate You can also disable individual optimization and obfuscation features on the entire code base: -keep class * { * ; } -keepattributes * -keepresources */ * -keepresourcefiles res/* * -keepresourcefiles assets/* * -keepresourcefiles lib/* * -keepresourcexmlattributenames * * None of these settings is a solution for all configuration issues, but they can help to narrow down the problem. The most effective approach is generally to get a working configuration to start from, and then tune it further. Obfuscating libraries \u00b6 An obfuscated library may get broken when it it is being processed a second time during the obfuscation/shrinking of the final application it is part of. For example, parts of the obfuscated library which are only called from encrypted classes may be removed while shrinking the final application. To prevent this, obfuscated libraries must provide their own configuration with keep rules for all classes, class members and resources that are seemingly unused after obfuscation of the library. DexGuard can automatically generate such a configuration from the input, by adding -printlibraryconfiguration my_library_configuration.txt to your DexGuard configuration. The output configuration will contain all keep rules from the input configuration that are still applicable after shrinking the library, as well as all required keep rules to preserve classes, class members and resources whose use is hidden after obfuscation due to reflection, encryption, etc. API entry points of a library have to be preserved during obfuscation of the library, but can be safely shrink/obfuscated while processing the final application. You can add the \u2018asapi\u2019 modifier to keep rules that specify such an API entry point: DexGuard will process them exactly the same way as other keep rules, but won't copy them to the generated library configuration. For all library projects that have at least one keep rule with the \u2018asapi\u2019 modifier and no -printlibraryconfiguration option, a library configuration will be automatically generated and written to the \u2018proguard.txt\u2019 file inside the resulting AAR.","title":"Overview"},{"location":"configuration.html#iterating-over-your-configuration","text":"","title":"Iterating over your configuration"},{"location":"configuration.html#protection-report","text":"DexGuard automatically produces a visual HTML report to help you improve the overall security of your DexGuard hardened builds. This Protection Report allows you to continuously assess and improve the protection of your application or library. It provides: Key technical risk metrics. Protection feature status and impact overview. Tailored configuration improvement advice. When used as a stand-alone application, DexGuard generates the protection reports in the reports directory under the name protectionreport.html . When using the DexGuard Gradle plugin , the reports are generated in the default gradle output directory. In order to disable the generation of such reports after a DexGuard build, simply include the -disableprotectionreport setting in your configuration file.","title":"Protection Report"},{"location":"configuration.html#telemetry","text":"Whenever your build system has an external connection to the internet, DexGuard sends telemetry data for Guardsquare's servers. The telemetry data is also dumped to a JSON file (telemetry_dump.json) so that you can review the data collected by Guardsquare. The collected telemetry data will be very helpful for us with effectively supporting you with your support tickets. Info The collected Telemetry data will never expose any sensitive info like string or class names. Rather, it will focus on the used features and their effectivenes. The collection of this data allows Guardsquare to further enhance DexGuard for you, based on real usage of its features. This behavior can be disabled by using the -disabletelemetry config option.","title":"Telemetry"},{"location":"configuration.html#best-practices","text":"","title":"Best Practices"},{"location":"configuration.html#consider-any-reflection-in-your-application","text":"Your application may be calling any of the following methods with non-trivial (non-constant) arguments. You then need to preserve the corresponding element of the application.","title":"Consider any reflection in your application"},{"location":"configuration.html#classforname","text":"You may need to explicitly preserve the class or classes that are loaded dynamically, with their original names. For example: -keep class com.example.SomeClass","title":"Class.forName(...)"},{"location":"configuration.html#classgetfieldclassgetdeclaredfield","text":"You may need to explicitly preserve the field or fields that are accessed dynamically, with their original names. For example: -keepclassmembers class com.example.SomeClass { <fields> ; }","title":"Class#getField(...)Class#getDeclaredField(...)"},{"location":"configuration.html#classgetmethodclassgetdeclaredmethod","text":"You may need to explicitly preserve the method or methods that are accessed dynamically, with their original names. For example: -keepclassmembers class com.example.SomeClass { <methods> ; }","title":"Class#getMethod(...)Class#getDeclaredMethod(...)"},{"location":"configuration.html#atomicintegerfieldupdaternewupdateratomiclongfieldupdaternewupdateratomicreferencefieldupdaternewupdater","text":"You may need to explicitly preserve the field or fields that are accessed dynamically, with their original names. For example: -keepclassmembers class com.example.SomeClass { <fields> ; }","title":"AtomicIntegerFieldUpdater.newUpdater(...)AtomicLongFieldUpdater.newUpdater(...)AtomicReferenceFieldUpdater.newUpdater(...)"},{"location":"configuration.html#resourcesgetidentifier","text":"You may need to explicitly preserve the resource or resources that are accessed dynamically, with their original names. For example: -keepresources string/some_string","title":"Resources#getIdentifier(...)"},{"location":"configuration.html#assetmanageropenassetmanageropenfdtypefacecreatefromasset","text":"You may need to explicitly preserve the asset file or files that are opened, with their original names. For example: -keepresourcefiles assets/some_assets.txt","title":"AssetManager#open(...)AssetManager#openFd(...)Typeface.createFromAsset(...)"},{"location":"configuration.html#systemloadlibrary","text":"You may need to explicitly preserve the native library or libraries that are loaded dynamically, with their original names. For example: -keepresourcefiles lib/*/libsomelibrary.so These constructs may of course be hidden inside third-party libraries. DexGuard's default configuration takes care of various popular libraries. Some common libraries require special attention:","title":"System.loadLibrary(...)"},{"location":"configuration.html#gson","text":"The GSON library performs reflection on the names of the fields that it serializes and deserializes. These names directly correspond to the JSON strings. You therefore need to preserve them, in order not to break the strings. -keepclassmembers class com.example.SerializedClass { <fields> ; } You can find more details in the GSON example and a sample project in samples/advanced/GSON .","title":"GSON"},{"location":"configuration.html#dagger","text":"The Dagger 1 framework generates classes at compile time and links them to their base classes at run-time, based on their names. You still need to manually preserve the corresponding base classes in your project. For example, for a generated class like com.example.SomeClass$$ModuleAdapter , you still need to specify: -keep class com.example.SomeClass That way, Dagger can combine the corresponding pairs of classes, based on their names. You can figure out the base classes by listing the generated classes in the gen directory of your project (e.g. com/examples/SomeClass$$ModuleAdapter.class ). You can find more details in the Dagger example and a sample project in samples/advanced/Dagger . Dagger 2 no longer relies on these naming conventions, which makes configuring for it a lot easier. In all of the above examples, you can use wildcards and more complex patterns in the specifications, e.g. to match all classes in specified packages.","title":"Dagger"},{"location":"configuration.html#get-configuration-suggestions-at-run-time","text":"DexGuard can instrument the application to debug the configuration: -addconfigurationdebugging If an error occurs at runtime due to shrinking or obfuscation, the application may print out configuration suggestions to solve the issue. You can find these messages in the run-time log of the application. You should make sure that you disable this setting again when you create an actual release version of your application.","title":"Get configuration suggestions at run-time"},{"location":"configuration.html#tune-the-obfuscation-level","text":"In case of problems, you can easily switch the default configuration in your Gradle configuration, with slightly different levels of obfuscation: Groovy dexguard { ... configurations { defaultConfiguration 'dexguard-release-aggressive.pro' ... } ... } or dexguard { ... configurations { defaultConfiguration 'dexguard-release.pro' ... } ... } or dexguard { ... configurations { defaultConfiguration 'dexguard-release-conservative.pro' ... } ... } Kotlin dexguard { ... configurations { defaultConfiguration ( \"dexguard-release-aggressive.pro\" ) ... } ... } or dexguard { ... configurations { defaultConfiguration ( \"dexguard-release.pro\" ) ... } ... } or dexguard { ... configurations { defaultConfiguration ( \"dexguard-release-conservative.pro\" ) ... } ... }","title":"Tune the obfuscation level"},{"location":"configuration.html#disable-obfuscation-for-third-party-libraries","text":"If a third-party library is causing problems, the most conservative approach is to disable its obfuscation: -keep , includecode class com.example.library.** { * ; } Such a configuration is generally not optimal, especially for large or sensitive libraries, but it can be a start. If it helps, you can try tuning the configuration, for example by only keeping the classes with their original names, but not necessarily their fields or methods: -keep class com.example.library.**","title":"Disable obfuscation for third-party libraries"},{"location":"configuration.html#disable-individual-obfuscation-features","text":"When tracking down issues, you can try disabling individual processing steps: -dontshrink -dontoptimize -dontobfuscate You can also disable individual optimization and obfuscation features on the entire code base: -keep class * { * ; } -keepattributes * -keepresources */ * -keepresourcefiles res/* * -keepresourcefiles assets/* * -keepresourcefiles lib/* * -keepresourcexmlattributenames * * None of these settings is a solution for all configuration issues, but they can help to narrow down the problem. The most effective approach is generally to get a working configuration to start from, and then tune it further.","title":"Disable individual obfuscation features"},{"location":"configuration.html#obfuscating-libraries","text":"An obfuscated library may get broken when it it is being processed a second time during the obfuscation/shrinking of the final application it is part of. For example, parts of the obfuscated library which are only called from encrypted classes may be removed while shrinking the final application. To prevent this, obfuscated libraries must provide their own configuration with keep rules for all classes, class members and resources that are seemingly unused after obfuscation of the library. DexGuard can automatically generate such a configuration from the input, by adding -printlibraryconfiguration my_library_configuration.txt to your DexGuard configuration. The output configuration will contain all keep rules from the input configuration that are still applicable after shrinking the library, as well as all required keep rules to preserve classes, class members and resources whose use is hidden after obfuscation due to reflection, encryption, etc. API entry points of a library have to be preserved during obfuscation of the library, but can be safely shrink/obfuscated while processing the final application. You can add the \u2018asapi\u2019 modifier to keep rules that specify such an API entry point: DexGuard will process them exactly the same way as other keep rules, but won't copy them to the generated library configuration. For all library projects that have at least one keep rule with the \u2018asapi\u2019 modifier and no -printlibraryconfiguration option, a library configuration will be automatically generated and written to the \u2018proguard.txt\u2019 file inside the resulting AAR.","title":"Obfuscating libraries"},{"location":"defaultconfigurations.html","text":"DexGuard offers various default configurations to cover most use-cases. It is highly recommended to use one of the default configurations together with project-specific rules like this. You can do this by using the -include option with the path to a default configuration in the dexguard.jar: # Standard release configuration, keeps all asset files. -include /lib/dexguard-release.pro # Your own configuration -injars your-app.apk -outjars your-app-protected.apk -libraryjars ... -keep class com.example.MyClass ... Debug build types \u00b6 The following table lists all available default configurations for debug type builds (application and library projects): Configuration Description dexguard-debug.pro Disables shrinking , optimization , obfuscation . dexguard-debug-instantapp.pro Same as dexguard-debug.pro but is also allowed to change the AndroidManifest.xml and resources.arsc as needed to process Android Instant Apps. dexguard-debug-shrink.pro Like dexguard-debug.pro , but with shrinking enabled. This configuration can be useful to avoid multidexing, if the Dalvik bytecode is becoming too large. You do need to make sure that you have a working project-specific configuration, like for release builds. dexguard-library-debug.pro Like dexguard-debug.pro , but for library projects. Release build types \u00b6 Application projects \u00b6 The following table lists all available default configurations for release type builds of application projects: Configuration Description dexguard-release.pro Standard release configuration, keeps all asset files. dexguard-release-aggressive.pro Like dexguard-release.pro but will also allow name obfuscation and shrinking of asset files. dexguard-release-conservative.pro Like dexguard-release.pro but will also prevent any native methods from being obfuscated and native libraries from being modified. Library projects \u00b6 The following table lists all available default configurations for release type builds of library projects: Configuration Description dexguard-library-release.pro Standard release configuration, will keep all public classes together with their public / protected fields / methods as well as all asset files. Additionally disables optimization code/allocation/variable . dexguard-library-release-aggressive.pro Like dexguard-library-release.pro but will obfuscate by default all classes and asset files. You need to make sure that you specify the public API of the library that has to be kept. dexguard-library-release-conservative.pro Like dexguard-library-release.pro but will also prevent any native methods from being obfuscated and native libraries from being modified. Additional compatibility configurations \u00b6 Additional configuration files that can be included if needed, e.g. when uploading the application to a specific store or using certain libraries (androidx): Configuration Description dexguard-compatibility-android-9.pro Uses a simplified resourcefilenameobfuscationdictionary to avoid problems with UTF-8 characters on devices with API level 9 (Android 2.3, Gingerbread). dexguard-compatibility-chinese-stores.pro Prevent obfuscation of certain elements in the AndroidManifest.xml to be able to upload to various stores. dexguard-compatibility-samsung-galaxy-tab-4.4.pro Uses a simplified classobfuscationdictionary to avoid problems with UTF-8 characters on Samsung Galaxy Tab devices. dexguard-compatibility-samsung-store.pro Prevent obfuscation of package and versionName in the AndroidManifest.xml to be able to upload to the Samsung store. dexguard-androidx.pro Adapted default rules for the use of the AndroidX repackaging of the Android support libraries. dexguard-alternative-classobfuscationdictionary.pro Specifies a different class obfuscation dictionary that avoids UTF-8 characters which might not be supported on some devices. dexguard-gson.pro Prevent obfuscation of Gson classes; required if Gson optimizations are disabled.","title":"Default Configs"},{"location":"defaultconfigurations.html#debug-build-types","text":"The following table lists all available default configurations for debug type builds (application and library projects): Configuration Description dexguard-debug.pro Disables shrinking , optimization , obfuscation . dexguard-debug-instantapp.pro Same as dexguard-debug.pro but is also allowed to change the AndroidManifest.xml and resources.arsc as needed to process Android Instant Apps. dexguard-debug-shrink.pro Like dexguard-debug.pro , but with shrinking enabled. This configuration can be useful to avoid multidexing, if the Dalvik bytecode is becoming too large. You do need to make sure that you have a working project-specific configuration, like for release builds. dexguard-library-debug.pro Like dexguard-debug.pro , but for library projects.","title":"Debug build types"},{"location":"defaultconfigurations.html#release-build-types","text":"","title":"Release build types"},{"location":"defaultconfigurations.html#application-projects","text":"The following table lists all available default configurations for release type builds of application projects: Configuration Description dexguard-release.pro Standard release configuration, keeps all asset files. dexguard-release-aggressive.pro Like dexguard-release.pro but will also allow name obfuscation and shrinking of asset files. dexguard-release-conservative.pro Like dexguard-release.pro but will also prevent any native methods from being obfuscated and native libraries from being modified.","title":"Application projects"},{"location":"defaultconfigurations.html#library-projects","text":"The following table lists all available default configurations for release type builds of library projects: Configuration Description dexguard-library-release.pro Standard release configuration, will keep all public classes together with their public / protected fields / methods as well as all asset files. Additionally disables optimization code/allocation/variable . dexguard-library-release-aggressive.pro Like dexguard-library-release.pro but will obfuscate by default all classes and asset files. You need to make sure that you specify the public API of the library that has to be kept. dexguard-library-release-conservative.pro Like dexguard-library-release.pro but will also prevent any native methods from being obfuscated and native libraries from being modified.","title":"Library projects"},{"location":"defaultconfigurations.html#additional-compatibility-configurations","text":"Additional configuration files that can be included if needed, e.g. when uploading the application to a specific store or using certain libraries (androidx): Configuration Description dexguard-compatibility-android-9.pro Uses a simplified resourcefilenameobfuscationdictionary to avoid problems with UTF-8 characters on devices with API level 9 (Android 2.3, Gingerbread). dexguard-compatibility-chinese-stores.pro Prevent obfuscation of certain elements in the AndroidManifest.xml to be able to upload to various stores. dexguard-compatibility-samsung-galaxy-tab-4.4.pro Uses a simplified classobfuscationdictionary to avoid problems with UTF-8 characters on Samsung Galaxy Tab devices. dexguard-compatibility-samsung-store.pro Prevent obfuscation of package and versionName in the AndroidManifest.xml to be able to upload to the Samsung store. dexguard-androidx.pro Adapted default rules for the use of the AndroidX repackaging of the Android support libraries. dexguard-alternative-classobfuscationdictionary.pro Specifies a different class obfuscation dictionary that avoids UTF-8 characters which might not be supported on some devices. dexguard-gson.pro Prevent obfuscation of Gson classes; required if Gson optimizations are disabled.","title":"Additional compatibility configurations"},{"location":"examples.html","text":"The DexGuard default configurations already provide support for the following libraries: ActionBarSherlock Amazon Ads Apache logging ButterKnife Cordova Cordova Crosswalk Couchbase Lite Crashlytics Dagger Droidsonroids Gif Ektorp Eyes-two Facebook API Facebook Conceal Facebook Fresco Glide Google API Google Cloud Messaging Google GData Google Play Services Google Play market LVL Google Play market expansion Greenrobot EventBus Guava IOCipher Jackson Java Mail JNA LibGDX LogBack MediaPlayerSDK MorphoSmart Nuance Vocalizer OkHttp OkIo OrmLite Otto Paypal card.io React Native Realm Retrofit RoboGuice RxJava SQLCipher Tapjoy Tess-two ZBar You can browse through this section if you are creating a build process from scratch, or if your project requires further customization. A simple Android application \u00b6 The DexGuard default configurations already specify these settings for you. If you're constructing a build process from scratch : these options shrink, optimize, and obfuscate all public activities, services, broadcast receivers, and content providers from the compiled classes and external libraries: -injars bin/classes -injars bin/resources.ap_ -injars libs -outjars bin/application.apk -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -dalvik -repackageclasses ' x ' -allowaccessmodification -keepresourcefiles AndroidManifest.xml -adaptresourcefilecontents AndroidManifest.xml,resources.arsc, ! res / raw** , res / **.xml -dontcompress resources.arsc,**.jpg,**.jpeg,**.png,**.gif -keepresourcexmlattributenames manifest/installLocation, manifest / versionCode , manifest / application / * / intent - filter / * / name -keepattributes *Annotation* -keep public class * extends android.view.View { public <init> ( android.content.Context ); public <init> ( android.content.Context , android.util.AttributeSet ); public <init> ( android.content.Context , android.util.AttributeSet , int ); public void set* ( ... ); } -keepclasseswithmembers class * { public <init> ( android.content.Context , android.util.AttributeSet ); } -keepclasseswithmembers class * { public <init> ( android.content.Context , android.util.AttributeSet , int ); } -keepclassmembers class * extends android.content.Context { public void * ( android.view.View ); public void * ( android.view.MenuItem ); } -keepclassmembers class * implements android.os.Parcelable { static ** CREATOR ; } -keepclassmembers class **.R$* { public static <fields> ; } -keepclassmembers class * { @ android.webkit.JavascriptInterface <methods> ; } We're specifying the input, the output, and the underlying run-time. We're targeting the Android run-time and the Dalvik virtual machine, with the -dalvik option. With -keepresourcefiles , we're keeping the Android manifest file as the main entry point of the application. DexGuard can then determine which resources and which code are required and how they can be optimized and obfuscated. With -adaptresourcefilecontents , we're adapting the obfuscated names inside the Android manifest file and the various binary resource files. The -dontcompress option specifies which files should not be compressed inside apk files, typically because they are already compressed themselves. The DexGuard plugins provide a long list of such files. Inside the Android manifest file, we're keeping some attribute names. The Android runtime somewhat arbitrarily requires them to launch the application. Names of other attributes that have numeric identifiers can be discarded. We're keeping annotations, since they might be used by custom RemoteViews and by various frameworks. We're keeping any custom View extensions and other classes with typical constructors, since they might be referenced from XML layout files. We're also keeping possible onClick handlers in custom Context extensions, since they might be referenced from XML layout files. We're also keeping the required static fields in Parcelable implementations, since they are accessed by introspection. We're keeping the static fields of referenced inner classes of auto-generated R classes, just in case your code is accessing those fields by introspection. Note that the compiler already inlines primitive fields, so DexGuard can generally remove all these classes entirely anyway (because the classes are not referenced and therefore not required). Finally, we're keeping annotated Javascript interface methods, so they can be exported and accessed by their original names. Javascript interface methods that are not annotated (in code targeted at Android versions older than 4.2) still need to be preserved manually. If you're using additional Google APIs, you'll have to specify those as well, for instance: -libraryjars /usr/local/java/android-sdk/extras/android/support/v4/android-support-v4.jar -libraryjars /usr/local/java/android-sdk/add-ons/addon-google_apis-google-21/libs/maps.jar If you're using Google's optional License Verification Library, you can obfuscate its code along with your own code. You do have to preserve its ILicensingService interface for the library to work: -keep public interface com.android.vending.licensing.ILicensingService If you're using the Android Compatibility library, you should add the following line, to let DexGuard know it's ok that the library references some classes that are not available in all versions of the API: -dontwarn android.support.** If applicable, you should add options for processing native methods , callback methods , enumerations , Android resources , and resource files . You may also want to add options for producing useful stack traces and to remove logging . You can find a complete sample configuration in extras/android.pro in the DexGuard distribution. Working sample project: samples/basic/HelloWorld Applications with the Scala runtime \u00b6 These additional options shrink, optimize, and obfuscate Scala applications in bin/classes : -injars bin/classes -injars bin/resources.ap_ -injars libs -injars /usr/local/scala-2.9.1/lib/scala-library.jar -outjars bin/application.apk -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar // ... Add the standard settings for Android applications ... -dontwarn scala.** -keep class * implements org.xml.sax.EntityResolver -keepclassmembers class * { ** MODULE$ ; } -keepclassmembernames class scala.concurrent.forkjoin.ForkJoinPool { long eventCount ; int workerCounts ; int runControl ; scala.concurrent.forkjoin.ForkJoinPool $ WaitQueueNode syncStack ; scala.concurrent.forkjoin.ForkJoinPool $ WaitQueueNode spareStack ; } -keepclassmembernames class scala.concurrent.forkjoin.ForkJoinWorkerThread { int base ; int sp ; int runState ; } -keepclassmembernames class scala.concurrent.forkjoin.ForkJoinTask { int status ; } -keepclassmembernames class scala.concurrent.forkjoin.LinkedTransferQueue { scala.concurrent.forkjoin.LinkedTransferQueue $ PaddedAtomicReference head ; scala.concurrent.forkjoin.LinkedTransferQueue $ PaddedAtomicReference tail ; scala.concurrent.forkjoin.LinkedTransferQueue $ PaddedAtomicReference cleanMe ; } The configuration is an extension of the configuration for processing activities , because Scala is compiled to ordinary Java bytecode. However, the example processes the Scala runtime library as well. The processed jar can be an order of magnitude smaller and a few times faster than the original code (for the Scala code examples, for instance). The -dontwarn option tells DexGuard not to complain about some artefacts in the Scala runtime, the way it is compiled by the scalac compiler (at least in Scala 2.9.1 and older). Note that this option should always be used with care. The additional -keep options make sure that some classes and some fields that are accessed by means of introspection are not removed or renamed. If applicable, you should add options for processing native methods , callback methods , enumerations , serializable classes , bean classes , annotations , and resource files . A typical library \u00b6 The DexGuard default configurations already specify these settings for you. If you're constructing a build process from scratch: these options shrink, optimize, and obfuscate an entire library, keeping all public and protected classes and class members, native method names, and serialization code. The processed version of the library can then still be used as such, for developing code based on its public API. -injars in.jar -outjars out.jar -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -printmapping out.map -keepresourcefiles * * -keepresources */ * -keep public class * { public protected * ; } -keepparameternames -renamesourcefileattribute SourceFile -keepattributes Signature , Exceptions , *Annotation* , InnerClasses , PermittedSubclasses , EnclosingMethod , Deprecated , SourceFile , LineNumberTable -keepclasseswithmembernames , includedescriptorclasses class * { native <methods> ; } -keepclassmembers , allowoptimization enum * { public static ** [] values (); public static ** valueOf ( java.lang.String ); } -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID ; private static final java.io.ObjectStreamField [] serialPersistentFields ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } This configuration should preserve everything a developer ever needs to access in the library: all Android resources and all public and protected classes, fields, and methods. We could refine the wildcards if we only want to include part of the resources (only one language, for instance) or part of the code (only a few packages, for instance). If there are any non-public classes, fields, or methods that are invoked dynamically, we should be specify them using additional -keep options. The \"Signature\" attribute is required to be able to access generic types. The \"Exceptions\" attribute has to be preserved, so the compiler knows which exceptions methods may throw. The \"InnerClasses\" attribute (or more precisely, its source name part) has to be preserved too, for any inner classes that can be referenced from outside the library. The javac compiler would be unable to find the inner classes otherwise. The \"PermittedSubclasses\" attribute defines sealed classes, which developers can't extend further. The \"EnclosingMethod\" attribute marks classes that are defined inside methods. The \"Deprecated\" attribute marks any deprecated classes, fields, or methods, which may be useful for developers to know. The -keepparameternames option keeps the parameter names in the \"LocalVariableTable\" and \"LocalVariableTypeTable\" attributes of public library methods. Some IDEs can present these names to the developers who use the library. Finally, we're keeping the \"Deprecated\" attribute and the attributes for producing useful stack traces . We've also added some options for for processing native methods , enumerations , serializable classes , and annotations , which are all discussed in their respective examples. Creating an Instant App \u00b6 DexGuard can automatically transform a traditional installed app into an Instant App. You only need to specify the Instant app features. For example, if your Android manifest specifies two activities, HelloActivity and GoodbyeActivity, you can create Instant app feature apks and a base apk for them: - instantappfeature hello com.example.HelloActivity https : // example.com / hello - instantappfeature bye com.example.GoodbyeActivity https : // example.com / bye You can freely choose the feature names. The activities should be present in the Android manifest. You can also freely choose the URLs through which you can access the features when they are installed. Processing native methods \u00b6 The default configuration of the DexGuard plugins already specifies these settings for you. If your application contains native methods, you'll want to preserve their names and their classes' names, so they can still be linked to the native library. The following additional option will ensure that: -keepclasseswithmembernames , includedescriptorclasses class * { native <methods> ; } Note the use of -keepclasseswithmembernames . We don't want to preserve all classes or all native methods; we just want to keep the relevant names from being obfuscated. The modifier includedescriptorclasses additionally makes sure that the return types and parameter types aren't renamed either, so the entire signatures remain compatible with the native libraries. DexGuard doesn't look at your native code, so it won't automatically preserve the classes or class members that are invoked by the native code. These are entry points, which you'll have to specify explicitly. Callback methods are discussed below as a typical example. Working sample project: samples/basic/NativeLibraryEncryption Processing callback methods \u00b6 If your application contains callback methods, which are called from external code (native code, scripts,...), you'll want to preserve them, and probably their classes too. They are just entry points to your code, much like, say, the main method of an application. If they aren't preserved by other -keep options, something like the following option will keep the callback class and method: -keep class com.example.MyCallbackClass { void myCallbackMethod ( java.lang.String ); } This will preserve the given class and method from being removed or renamed. Processing enumeration classes \u00b6 The DexGuard default configurations already specify these settings for you. If your application contains enumeration classes, you'll have to preserve some special methods. Enumerations were introduced in Java 5. The java compiler translates enumerations into classes with a special structure. Notably, the classes contain implementations of some static methods that the run-time environment accesses by introspection (Isn't that just grand? Introspection is the self-modifying code of a new generation). You have to specify these explicitly, to make sure they aren't removed or obfuscated: -keepclassmembers , allowoptimization enum * { public static ** [] values (); public static ** valueOf ( java.lang.String ); } Processing serializable classes \u00b6 More complex applications may contain classes that are serialized. Depending on the way in which they are used, they may require special attention: Often, serialization is simply a means of transporting data, without long-term storage. Classes that are shrunk and obfuscated should then continue to function fine with the following additional options: -keepclassmembers class * implements java.io.Serializable { private static final java.io.ObjectStreamField [] serialPersistentFields ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } The -keepclassmembers option makes sure that any serialization methods are kept. By using this option instead of the basic -keep option, we're not forcing preservation of all serializable classes, just preservation of the listed members of classes that are actually used. Sometimes, the serialized data are stored, and read back later into newer versions of the serializable classes. One then has to take care the classes remain compatible with their unprocessed versions and with future processed versions. In such cases, the relevant classes will most likely have serialVersionUID fields. The following options should then be sufficient to ensure compatibility over time: -keepnames class * implements java.io.Serializable -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID ; private static final java.io.ObjectStreamField [] serialPersistentFields ; !static !transient <fields> ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } The serialVersionUID and serialPersistentFields lines makes sure those fields are preserved, if they are present. The <fields> line preserves all non-static, non-transient fields, with their original names. The introspection of the serialization process and the de-serialization process will then find consistent names. Occasionally, the serialized data have to remain compatible, but the classes involved lack serialVersionUID fields. I imagine the original code will then be hard to maintain, since the serial version UID is then computed from a list of features the serializable class. Changing the class ever so slightly may change the computed serial version UID. The list of features is specified in the section on Stream Unique Identifiers of Sun's Java Object Serialization Specification . The following directives should at least partially ensure compatibility with the original classes: -keepnames class * implements java.io.Serializable -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID ; private static final java.io.ObjectStreamField [] serialPersistentFields ; !static !transient <fields> ; !private <fields> ; !private <methods> ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } The new options force preservation of the elements involved in the UID computation. In addition, the user will have to manually specify all interfaces of the serializable classes (using something like \" -keep interface MyInterface \"), since these names are also used when computing the UID. A fast but sub-optimal alternative would be simply keeping all interfaces with \" -keep interface * \". In the rare event that you are serializing lambda expressions in Java 8 or higher, you need to preserve some methods and adapt the hard-coded names of the classes in which they occur: -keepclassmembers class * { private static synthetic java.lang.Object $deserializeLambda$ ( java.lang.invoke.SerializedLambda ); } -keepclassmembernames class * { private static synthetic *** lambda$* ( ... ); } -adaptclassstrings com.example.Test This should satisfy the reflection in the deserialization code of the Java run-time. Note that the above options may preserve more classes and class members than strictly necessary. For instance, a large number of classes may implement the Serialization interface, yet only a small number may actually ever be serialized. Knowing your application and tuning the configuration often produces more compact results. Processing bean classes \u00b6 If your application makes extensive use of introspection on bean classes to find bean editor classes, or getter and setter methods, then configuration may become painful. There's not much else you can do than making sure the bean class names, or the getter and setter names don't change. For instance: -keep public class com.example.MyBean { public void setMyProperty ( int ); public int getMyProperty (); } -keep public class com.example.MyBeanEditor If there are too many elements to list explicitly, wildcards in class names and method signatures might be helpful. This example preserves all possible setters and getters in classes in the package mybeans : -keep class mybeans.** { void set* ( *** ); void set* ( int , *** ); boolean is* (); boolean is* ( int ); *** get* (); *** get* ( int ); } The ' *** ' wildcard matches any type (primitive or non-primitive, array or non-array). The methods with the ' int ' arguments matches properties that are lists. Processing annotations \u00b6 The default configuration of the DexGuard plugins already specifies these settings for you. If your application uses annotations, you may want to preserve them in the processed output. Annotations are represented by attributes that have no direct effect on the execution of the code. However, their values can be retrieved through introspection, allowing developers to adapt the execution behavior accordingly. By default, DexGuard treats annotation attributes as optional, and removes them in the obfuscation step. If they are required, you'll have to specify this explicitly: -keepattributes *Annotation* For brevity, we're specifying a wildcarded attribute name, which will match RuntimeVisibleAnnotations , RuntimeInvisibleAnnotations , RuntimeVisibleParameterAnnotations , RuntimeInvisibleParameterAnnotations , and AnnotationDefault . Depending on the purpose of the processed code, you could refine this selection, for instance not keeping the run-time invisible annotations (which are only used at compile-time). Some code may make further use of introspection to figure out the enclosing methods of anonymous inner classes. In that case, the corresponding attribute has to be preserved as well: -keepattributes EnclosingMethod Processing database drivers \u00b6 Database drivers are implementations of the Driver interface. Since they are often created dynamically, you may want to preserve any implementations that you are processing as entry points: -keep class * implements java.sql.Driver This option also gets rid of the note that DexGuard prints out about (java.sql.Driver)Class.forName constructs, if you are instantiating a driver in your code (without necessarily implementing any drivers yourself). Optimizing GSON code \u00b6 DexGuard optimizes Gson code , by detecting which domain classes are serialized using the Gson library, and then replacing the reflection-based implementation by more efficient hard-coded serialization. The GSON optimization is enabled by default and doesn't require any additional configuration. If you've disabled optimization, the GSON library still relies on reflection on the fields of the classes that it serializes. You then need to preserve the parameterless constructor and the serialized fields from being removed, optimized, or obfuscated. For example: -keepclassmembers class com.example.SerializedClass { <fields> ; <init> (); } While creating the configuration, you can specify the option -addconfigurationdebugging , to get feedback on the necessary settings at run-time. Alternatively, you can make sure the fields are explicitly annotated with @SerializedName , so the names of the fields can be obfuscated. You can then keep all of them at the same time with: -keepclasseswithmembers , allowobfuscation , includedescriptorclasses class * { @ com.google.gson.annotations.SerializedName <fields> ; } -keepclassmembers enum * { @ com.google.gson.annotations.SerializedName <fields> ; } Working sample project: samples/advanced/Gson Processing dependency injection \u00b6 The DexGuard default configurations already specify these settings for you. Your application may be using a framework for dependency injection, such as Spring. Such frameworks automatically assign instances of resource classes to fields and method parameters. They heavily rely on annotations and introspection, even accessing private class members directly. We then have to avoid that such fields or methods are removed or renamed. For example: -keepclassmembers class * { @ javax.annotation.Resource * ; } The Spring framework has another similar annotation @Autowired : -keepclassmembers class * { @ org.springframework.beans.factory.annotation.Autowired * ; } Processing Dagger code \u00b6 The DexGuard default configurations already specify these settings for you. Your application may be using the Dagger library for its dependency injection. Dagger 1 relies heavily on reflection, so you may need some additional configuration to make sure it continues to work. DexGuard's default configuration already keeps some required classes: -keepclassmembers , allowobfuscation class * { @ dagger.** * ; } -keep class **$$ModuleAdapter -keep class **$$InjectAdapter -keep class **$$StaticInjection -if class **$$ModuleAdapter -keep class < 1 > -if class **$$InjectAdapter -keep class < 1 > -if class **$$StaticInjection -keep class < 1 > -keepnames class dagger.Lazy That way, Dagger can combine the corresponding pairs of classes, based on their names. Furthermore, if your code injects dependencies into some given classes with an annotation like @Module(injects = { SomeClass.class }, ...) , you need to preserve the specified names as well: -keep class com.example.SomeClass Dagger 2 no longer relies on reflection. You don't need to preserve any classes there. Working sample project: samples/advanced/Dagger Processing Butterknife code \u00b6 If your application includes Butterknife to inject views, you also need a few lines of configuration, since Butterknife relies on reflection to tie together the code at runtime: -keep @ interface butterknife.* -keepclasseswithmembers class * { @ butterknife.* <fields> ; } -keepclasseswithmembers class * { @ butterknife.* <methods> ; } -keepclasseswithmembers class * { @ butterknife.On* <methods> ; } -keep class **$$ViewInjector { public static void inject ( ... ); public static void reset ( ... ); } -keep class **$$ViewBinder { public static void bind ( ... ); public static void unbind ( ... ); } -if class **$$ViewBinder -keep class < 1 > -keep class ** _ViewBinding { <init> ( < 1 > , android.view.View ); } -if class ** _ViewBinding -keep class < 1 > These settings preserve the Butterknife annotations, the annotated fields and methods, and the generated classes and methods that Butterknife accesses by reflection. Processing Restring code \u00b6 If you application includes the Restring library to dynamically replace resource strings, you need some additional configuration. Restring relies on the names of resource strings (with Resources#getResourceEntryName ) and the names of attributes in resource XML files (with AttributeSet#getAttributeName ). Conservatively, you can keep all resource strings with their original names, and all attribute names: -keepresources string/* * -keepresourcexmlattributenames * * For more fine-tuned settings without the broad wildcards, you can inspect the StringsLoader implementation in your code or specify the option -addconfigurationdebugging , to get feedback on the necessary settings at run-time. Processing Android resources \u00b6 Your Android application typically contains resources and resource files. It will generally access them through their numeric IDs from R classes, for example R.drawable.my_icon . The shrinking, optimization, and obfuscation steps handle such use automatically. However, if your application accesses some resources by reflection, based on their name strings, you need to preserve these names from being obfuscated. For example, for resources.getIdentifier(\"my_icon\", \"drawable\", package) , you need to preserve the corresponding resource with its original name: -keepresources drawable/my_icon The -keepresources option preserves the specified resources. You can use wildcards. For a quick test, you can preserve all resources with their original names: -keepresources */ * In some rare cases, your application may be referring to the resource files directly, by their names. You then need to preserve them with their original names. For example: -keepresourcefiles res/drawable*/my_icon.png The -keepresourcefiles option preserves the specified resource files, which are technically independent from the corresponding resources. With wild-cards: -keepresourcefiles res/*/ * Processing general resource files \u00b6 If your application contains resource files, it may be necessary to adapt their names and/or their contents when the application is obfuscated. The following two options can achieve this automatically: -adaptresourcefilenames **.properties , **.gif , **.jpg -adaptresourcefilecontents **.properties,META-INF/MANIFEST.MF The -adaptresourcefilenames option in this case renames properties files and image files in the processed output, based on the obfuscated names of their corresponding class files (if any). The -adaptresourcefilecontents option looks for class names in properties files and in the manifest file, and replaces these names by the obfuscated names (if any). You'll probably want to adapt the filters to suit your application. Processing manifest files \u00b6 As illustrated in the previous section, manifest files can be treated like ordinary resource files. DexGuard can adapt obfuscated class names in the files, but it won't make any other changes. If you want anything else, you should apply an external tool. For instance, if a manifest file contains signing information, you should sign the jar again after it has been processed. If you're merging several input jars into a single output jar, you'll have to pick one, typically by specifying filters : -injars in1.jar -injars in2.jar(!META-INF/MANIFEST.MF) -injars in3.jar(!META-INF/MANIFEST.MF) -outjars out.jar The filters will let DexGuard copy the manifest file from the first jar and ignore any manifest files in the second and third input jars. Note that DexGuard will leave the order of the files in the jars unchanged; manifest files are not necessarily put first. Adding reflection for sensitive APIs \u00b6 You can add reflection to obfuscate access to sensitive APIs, with the option -accessthroughreflection . For instance, this option replaces access to the standard cryptographic SecretKey class by equivalent reflective code: -accessthroughreflection class javax.crypto.SecretKey { byte ] getEncoded (); } For better obfuscation, you'll typically want to encrypt the resulting strings: -encryptstrings \" javax.crypto.SecretKey \" , \" getEncoded \" or simply all strings in the class from which the cryptographic class is called: -encryptstrings class com.example.MySecretClass Finally, you can add another layer of obfuscation by also encrypting the latter class: -encryptclasses com.example.MySecretClass Working sample project: samples/basic/Reflection Encrypting classes \u00b6 You can encrypt entire classes by specifying them with the option -encryptclasses . It accepts a filter , which can contain wildcards and negators. For example: -encryptclasses com.example.MySecretClass , com.example.MySecretClass $ * This option instructs to encrypt the specified class and all of its inner classes. The latter classes are easy to forget, because they are defined in the same source file, but they may be important too. Working sample project: samples/basic/ClassEncryption Encrypting strings \u00b6 There are a few alternative ways to specify which constant strings in the code should be encrypted, with the option -encryptstrings . The shortest way is to specify the strings literally: -encryptstrings \" Some secret string \" , \" Some other secret string \" In this case, the option has a filter , which can contain wildcards and negators. Alternatively, you can specify final String fields, whose strings should be encrypted wherever they occur. For example: -encryptstrings public class com.example.MyConstants { public static final java.lang.String SECRET_KEY ; } Alternatively, you can specify methods whose constant strings should all be encrypted. For example: -encryptstrings public class com.example.MySensitiveClass { public void mySecretMethod (); } Finally, you can just specify classes whose constant strings should all be encrypted. For example: -encryptstrings public class com.example.MySecretClass In these last three cases, the options have class specifications that specify one or more classes, fields, or methods. These specifications support multiple elements and various wildcards. Working sample project: samples/basic/StringEncryption Producing useful obfuscated stack traces \u00b6 The DexGuard default configurations already specify these settings for you. These options let obfuscated applications or libraries produce stack traces that can still be deciphered later on: -printmapping out.map -renamesourcefileattribute SourceFile -keepattributes SourceFile , LineNumberTable We're keeping all source file attributes, but we're replacing their values by the string \"SourceFile\". We could use any string. We're also keeping the line number tables of all methods. Whenever both of these attributes are present, the Java run-time environment will include line number information when printing out exception stack traces. The information will only be useful if we can map the obfuscated names back to their original names, so we're saving the mapping to a file out.map . The information can then be used by the ReTrace tool to restore the original stack trace. Obfuscating package names \u00b6 The DexGuard default configurations already specify these settings for you. Package names can be obfuscated in various ways, with increasing levels of obfuscation and compactness. For example, consider the following classes: mycompany.myapplication.MyMain mycompany.myapplication.Foo mycompany.myapplication.Bar mycompany.myapplication.extra.FirstExtra mycompany.myapplication.extra.SecondExtra mycompany.util.FirstUtil mycompany.util.SecondUtil Let's assume the class name mycompany.myapplication.MyMain is the main application class that is kept by the configuration. All other class names can be obfuscated. By default, packages that contain classes that can't be renamed aren't renamed either, and the package hierarchy is preserved. This results in obfuscated class names like these: mycompany.myapplication.MyMain mycompany.myapplication.a mycompany.myapplication.b mycompany.myapplication.a.a mycompany.myapplication.a.b mycompany.a.a mycompany.a.b The -flattenpackagehierarchy option obfuscates the package names further, by flattening the package hierarchy of obfuscated packages: -flattenpackagehierarchy ' myobfuscated ' The obfuscated class names then look as follows: mycompany.myapplication.MyMain mycompany.myapplication.a mycompany.myapplication.b myobfuscated.a.a myobfuscated.a.b myobfuscated.b.a myobfuscated.b.b Alternatively, the -repackageclasses option obfuscates the entire packaging, by combining obfuscated classes into a single package: -repackageclasses ' myobfuscated ' The obfuscated class names then look as follows: mycompany.myapplication.MyMain mycompany.myapplication.a mycompany.myapplication.b myobfuscated.a myobfuscated.b myobfuscated.c myobfuscated.d Additionally specifying the -allowaccessmodification option allows access permissions of classes and class members to be broadened, opening up the opportunity to repackage all obfuscated classes: -repackageclasses ' myobfuscated ' -allowaccessmodification The obfuscated class names then look as follows: mycompany.myapplication.MyMain myobfuscated.a myobfuscated.b myobfuscated.c myobfuscated.d myobfuscated.e myobfuscated.f The specified target package can always be the root package. For instance: -repackageclasses '' -allowaccessmodification The obfuscated class names are then the shortest possible names: mycompany.myapplication.MyMain a b c d e f Note that not all levels of obfuscation of package names may be acceptable for all code. Notably, you may have to take into account that your application may contain resource files that have to be adapted. Publishing on the Samsung app market \u00b6 If you're publishing your Android application on the Samsung app market, and you get \"File upload has failed. There is no application ID(PackageName) or Version information(VersionName) in the Android Manifest.xml file you have registered.\", then you need to preserve the mentioned resource XML attribute names in the AndroidManifest.xml : -keepresourcexmlattributenames manifest/package,manifest/versionName The Samsung market parses these attributes when you upload your application, and they can't handle obfuscated names. Other markets may try to read even more attributes. You could then refine your configuration experimentally, or just not obfuscate any attributes in the manifest at all: -keepresourcexmlattributenames manifest/* * Removing logging code \u00b6 You can let DexGuard remove logging code. The trick is to specify that the logging methods don't have side-effects \u2014 even though they actually do, since they write to the console or to a log file. DexGuard will take your word for it and remove the invocations (in the optimization step) and if possible the logging classes and methods themselves (in the shrinking step). For example, this configuration removes invocations of the Android logging methods: -assumenosideeffects class android.util.Log { public static boolean isLoggable ( java.lang.String , int ); public static int v ( ... ); public static int i ( ... ); public static int w ( ... ); public static int d ( ... ); public static int e ( ... ); } The wildcards are a shortcut to match all versions of the methods. Be careful not to use a * wildcard to match all methods, because it would also match methods like wait() , higher up the hierarchy. Removing those invocations will generally break your code. Note that you generally can't remove logging code that uses System.out.println , since you would be removing all invocations of java.io.PrintStream#println , which could break your application. You can work around it by creating your own logging methods and let DexGuard remove those. Working sample project: samples/basic/LoggingRemoval Restructuring the output archives \u00b6 In simple applications, all output classes and resources files are merged into a single jar. For example: -injars classes -injars in1.jar -injars in2.jar -injars in3.jar -outjars out.jar This configuration merges the processed versions of the files in the classes directory and the three jars into a single output jar out.jar . If you want to preserve the structure of your input jars (and/or apks, aars, aabs, wars, ears, jmods, zips, or directories), you can specify an output directory (or an apk, an aar, an aab, a war, an ear, a jmod, or a zip). For example: -injars in1.jar -injars in2.jar -injars in3.jar -outjars out The input jars will then be reconstructed in the directory out , with their original names. You can also combine archives into higher level archives. For example: -injars in1.jar -injars in2.jar -injars in3.jar -outjars out.war The other way around, you can flatten the archives inside higher level archives into simple archives: -injars in.war -outjars out.jar This configuration puts the processed contents of all jars inside in.war (plus any other contents of in.war ) into out.jar . If you want to combine input jars (and/or apks, aabs, aars, wars, ears, jmods, zips, or directories) into output jars (and/or apks, aabs, aars, wars, ears, jmods, zips, or directories), you can group the -injars and -outjars options. For example: -injars base_in1.jar -injars base_in2.jar -injars base_in3.jar -outjars base_out.jar -injars extra_in.jar -outjars extra_out.jar This configuration puts the processed results of all base_in*.jar jars into base_out.jar , and the processed results of the extra_in.jar into extra_out.jar . Note that only the order of the options matters; the additional whitespace is just for clarity. This grouping, archiving, and flattening can be arbitrarily complex. DexGuard always tries to package output archives in a sensible way, reconstructing the input entries as much as required. Filtering the input and the output \u00b6 The default configuration of the DexGuard plugins already specifies these settings for you. If you want even greater control, you can add filters to the input and the output, filtering out apks, aabs, jars, aars, wars, ears, jmods, zips, and/or ordinary files. For example, if you want to disregard certain files from an input jar: -injars in.jar(!images/**) -outjars out.jar This configuration removes any files in the images directory and its subdirectories. Such filters can be convenient for avoiding warnings about duplicate files in the output. For example, only keeping the manifest file from a first input jar: -injars in1.jar -injars in2.jar(!META-INF/MANIFEST.MF) -injars in3.jar(!META-INF/MANIFEST.MF) -outjars out.jar It is also possible to filter the jars (and/or apks, aabs, aars, wars, ears, jmods, zips) themselves, based on their names. For example: -injars in(**/acme_*.jar;) -outjars out.jar Note the semi-colon in the filter; the filter in front of it applies to jar names. In this case, only acme_*.jar jars are read from the directory in and its subdirectories. Filters for war names, ear names, and zip names can be prefixed with additional semi-colons. All types of filters can be combined. They are orthogonal. On the other hand, you can also filter the output, in order to control what content goes where. For example: -injars in.jar -outjars code_out.jar(**.class) -outjars resources_out.jar This configuration splits the processed output, sending **.class files to code_out.jar , and all remaining files to resources_out.jar . Again, the filtering can be arbitrarily complex, especially when combined with grouping input and output. Finding dead code \u00b6 These options list unused classes, fields, and methods in the application com.example.MyApplication : -injars in.jar -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -dontoptimize -dontobfuscate -dontpreverify -printusage -keep public class com.example.MyApplication { public static void main ( java.lang.String [] ); } We're not specifying an output jar, just printing out some results. We're saving some processing time by skipping the other processing steps. The java compiler inlines primitive constants and String constants ( static final fields). DexGuard would therefore list such fields as not being used in the class files that it analyzes, even if they are used in the source files. We can add a -keepclassmembers option that keeps those fields a priori, in order to avoid having them listed: -keepclassmembers class * { static final % * ; static final java.lang.String * ; } Using annotations to configure DexGuard \u00b6 The traditional DexGuard configuration allows to keep a clean separation between the code and the configuration for shrinking, optimization, and obfuscation. However, it is also possible to define specific annotations, and then annotate the code to configure the processing. You can find a set of such predefined annotations in the directory extras/annotations/lib in the DexGuard distribution. The annotation classes are defined in annotations.jar . The corresponding DexGuard configuration (or meta-configuration, if you prefer) is specified in annotations.pro . With these files, you can start annotating your code. For instance, a java source file Application.java can be annotated as follows: @KeepApplication public class Application { // .... } The DexGuard configuration file for the application can then be simplified by leveraging these annotations: -injars in.jar -outjars out.jar -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -include lib/annotations.pro The annotations are effectively replacing the application-dependent -keep options. You may still wish to add traditional -keep options for processing native methods , enumerations , serializable classes , and annotations . The directory extras/annotations contains more examples that illustrate some of the possibilities.","title":"Examples"},{"location":"examples.html#android","text":"The DexGuard default configurations already specify these settings for you. If you're constructing a build process from scratch : these options shrink, optimize, and obfuscate all public activities, services, broadcast receivers, and content providers from the compiled classes and external libraries: -injars bin/classes -injars bin/resources.ap_ -injars libs -outjars bin/application.apk -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -dalvik -repackageclasses ' x ' -allowaccessmodification -keepresourcefiles AndroidManifest.xml -adaptresourcefilecontents AndroidManifest.xml,resources.arsc, ! res / raw** , res / **.xml -dontcompress resources.arsc,**.jpg,**.jpeg,**.png,**.gif -keepresourcexmlattributenames manifest/installLocation, manifest / versionCode , manifest / application / * / intent - filter / * / name -keepattributes *Annotation* -keep public class * extends android.view.View { public <init> ( android.content.Context ); public <init> ( android.content.Context , android.util.AttributeSet ); public <init> ( android.content.Context , android.util.AttributeSet , int ); public void set* ( ... ); } -keepclasseswithmembers class * { public <init> ( android.content.Context , android.util.AttributeSet ); } -keepclasseswithmembers class * { public <init> ( android.content.Context , android.util.AttributeSet , int ); } -keepclassmembers class * extends android.content.Context { public void * ( android.view.View ); public void * ( android.view.MenuItem ); } -keepclassmembers class * implements android.os.Parcelable { static ** CREATOR ; } -keepclassmembers class **.R$* { public static <fields> ; } -keepclassmembers class * { @ android.webkit.JavascriptInterface <methods> ; } We're specifying the input, the output, and the underlying run-time. We're targeting the Android run-time and the Dalvik virtual machine, with the -dalvik option. With -keepresourcefiles , we're keeping the Android manifest file as the main entry point of the application. DexGuard can then determine which resources and which code are required and how they can be optimized and obfuscated. With -adaptresourcefilecontents , we're adapting the obfuscated names inside the Android manifest file and the various binary resource files. The -dontcompress option specifies which files should not be compressed inside apk files, typically because they are already compressed themselves. The DexGuard plugins provide a long list of such files. Inside the Android manifest file, we're keeping some attribute names. The Android runtime somewhat arbitrarily requires them to launch the application. Names of other attributes that have numeric identifiers can be discarded. We're keeping annotations, since they might be used by custom RemoteViews and by various frameworks. We're keeping any custom View extensions and other classes with typical constructors, since they might be referenced from XML layout files. We're also keeping possible onClick handlers in custom Context extensions, since they might be referenced from XML layout files. We're also keeping the required static fields in Parcelable implementations, since they are accessed by introspection. We're keeping the static fields of referenced inner classes of auto-generated R classes, just in case your code is accessing those fields by introspection. Note that the compiler already inlines primitive fields, so DexGuard can generally remove all these classes entirely anyway (because the classes are not referenced and therefore not required). Finally, we're keeping annotated Javascript interface methods, so they can be exported and accessed by their original names. Javascript interface methods that are not annotated (in code targeted at Android versions older than 4.2) still need to be preserved manually. If you're using additional Google APIs, you'll have to specify those as well, for instance: -libraryjars /usr/local/java/android-sdk/extras/android/support/v4/android-support-v4.jar -libraryjars /usr/local/java/android-sdk/add-ons/addon-google_apis-google-21/libs/maps.jar If you're using Google's optional License Verification Library, you can obfuscate its code along with your own code. You do have to preserve its ILicensingService interface for the library to work: -keep public interface com.android.vending.licensing.ILicensingService If you're using the Android Compatibility library, you should add the following line, to let DexGuard know it's ok that the library references some classes that are not available in all versions of the API: -dontwarn android.support.** If applicable, you should add options for processing native methods , callback methods , enumerations , Android resources , and resource files . You may also want to add options for producing useful stack traces and to remove logging . You can find a complete sample configuration in extras/android.pro in the DexGuard distribution. Working sample project: samples/basic/HelloWorld","title":"A simple Android application"},{"location":"examples.html#scala","text":"These additional options shrink, optimize, and obfuscate Scala applications in bin/classes : -injars bin/classes -injars bin/resources.ap_ -injars libs -injars /usr/local/scala-2.9.1/lib/scala-library.jar -outjars bin/application.apk -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar // ... Add the standard settings for Android applications ... -dontwarn scala.** -keep class * implements org.xml.sax.EntityResolver -keepclassmembers class * { ** MODULE$ ; } -keepclassmembernames class scala.concurrent.forkjoin.ForkJoinPool { long eventCount ; int workerCounts ; int runControl ; scala.concurrent.forkjoin.ForkJoinPool $ WaitQueueNode syncStack ; scala.concurrent.forkjoin.ForkJoinPool $ WaitQueueNode spareStack ; } -keepclassmembernames class scala.concurrent.forkjoin.ForkJoinWorkerThread { int base ; int sp ; int runState ; } -keepclassmembernames class scala.concurrent.forkjoin.ForkJoinTask { int status ; } -keepclassmembernames class scala.concurrent.forkjoin.LinkedTransferQueue { scala.concurrent.forkjoin.LinkedTransferQueue $ PaddedAtomicReference head ; scala.concurrent.forkjoin.LinkedTransferQueue $ PaddedAtomicReference tail ; scala.concurrent.forkjoin.LinkedTransferQueue $ PaddedAtomicReference cleanMe ; } The configuration is an extension of the configuration for processing activities , because Scala is compiled to ordinary Java bytecode. However, the example processes the Scala runtime library as well. The processed jar can be an order of magnitude smaller and a few times faster than the original code (for the Scala code examples, for instance). The -dontwarn option tells DexGuard not to complain about some artefacts in the Scala runtime, the way it is compiled by the scalac compiler (at least in Scala 2.9.1 and older). Note that this option should always be used with care. The additional -keep options make sure that some classes and some fields that are accessed by means of introspection are not removed or renamed. If applicable, you should add options for processing native methods , callback methods , enumerations , serializable classes , bean classes , annotations , and resource files .","title":"Applications with the Scala runtime"},{"location":"examples.html#library","text":"The DexGuard default configurations already specify these settings for you. If you're constructing a build process from scratch: these options shrink, optimize, and obfuscate an entire library, keeping all public and protected classes and class members, native method names, and serialization code. The processed version of the library can then still be used as such, for developing code based on its public API. -injars in.jar -outjars out.jar -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -printmapping out.map -keepresourcefiles * * -keepresources */ * -keep public class * { public protected * ; } -keepparameternames -renamesourcefileattribute SourceFile -keepattributes Signature , Exceptions , *Annotation* , InnerClasses , PermittedSubclasses , EnclosingMethod , Deprecated , SourceFile , LineNumberTable -keepclasseswithmembernames , includedescriptorclasses class * { native <methods> ; } -keepclassmembers , allowoptimization enum * { public static ** [] values (); public static ** valueOf ( java.lang.String ); } -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID ; private static final java.io.ObjectStreamField [] serialPersistentFields ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } This configuration should preserve everything a developer ever needs to access in the library: all Android resources and all public and protected classes, fields, and methods. We could refine the wildcards if we only want to include part of the resources (only one language, for instance) or part of the code (only a few packages, for instance). If there are any non-public classes, fields, or methods that are invoked dynamically, we should be specify them using additional -keep options. The \"Signature\" attribute is required to be able to access generic types. The \"Exceptions\" attribute has to be preserved, so the compiler knows which exceptions methods may throw. The \"InnerClasses\" attribute (or more precisely, its source name part) has to be preserved too, for any inner classes that can be referenced from outside the library. The javac compiler would be unable to find the inner classes otherwise. The \"PermittedSubclasses\" attribute defines sealed classes, which developers can't extend further. The \"EnclosingMethod\" attribute marks classes that are defined inside methods. The \"Deprecated\" attribute marks any deprecated classes, fields, or methods, which may be useful for developers to know. The -keepparameternames option keeps the parameter names in the \"LocalVariableTable\" and \"LocalVariableTypeTable\" attributes of public library methods. Some IDEs can present these names to the developers who use the library. Finally, we're keeping the \"Deprecated\" attribute and the attributes for producing useful stack traces . We've also added some options for for processing native methods , enumerations , serializable classes , and annotations , which are all discussed in their respective examples.","title":"A typical library"},{"location":"examples.html#instantapp","text":"DexGuard can automatically transform a traditional installed app into an Instant App. You only need to specify the Instant app features. For example, if your Android manifest specifies two activities, HelloActivity and GoodbyeActivity, you can create Instant app feature apks and a base apk for them: - instantappfeature hello com.example.HelloActivity https : // example.com / hello - instantappfeature bye com.example.GoodbyeActivity https : // example.com / bye You can freely choose the feature names. The activities should be present in the Android manifest. You can also freely choose the URLs through which you can access the features when they are installed.","title":"Creating an Instant App"},{"location":"examples.html#native","text":"The default configuration of the DexGuard plugins already specifies these settings for you. If your application contains native methods, you'll want to preserve their names and their classes' names, so they can still be linked to the native library. The following additional option will ensure that: -keepclasseswithmembernames , includedescriptorclasses class * { native <methods> ; } Note the use of -keepclasseswithmembernames . We don't want to preserve all classes or all native methods; we just want to keep the relevant names from being obfuscated. The modifier includedescriptorclasses additionally makes sure that the return types and parameter types aren't renamed either, so the entire signatures remain compatible with the native libraries. DexGuard doesn't look at your native code, so it won't automatically preserve the classes or class members that are invoked by the native code. These are entry points, which you'll have to specify explicitly. Callback methods are discussed below as a typical example. Working sample project: samples/basic/NativeLibraryEncryption","title":"Processing native methods"},{"location":"examples.html#callback","text":"If your application contains callback methods, which are called from external code (native code, scripts,...), you'll want to preserve them, and probably their classes too. They are just entry points to your code, much like, say, the main method of an application. If they aren't preserved by other -keep options, something like the following option will keep the callback class and method: -keep class com.example.MyCallbackClass { void myCallbackMethod ( java.lang.String ); } This will preserve the given class and method from being removed or renamed.","title":"Processing callback methods"},{"location":"examples.html#enumerations","text":"The DexGuard default configurations already specify these settings for you. If your application contains enumeration classes, you'll have to preserve some special methods. Enumerations were introduced in Java 5. The java compiler translates enumerations into classes with a special structure. Notably, the classes contain implementations of some static methods that the run-time environment accesses by introspection (Isn't that just grand? Introspection is the self-modifying code of a new generation). You have to specify these explicitly, to make sure they aren't removed or obfuscated: -keepclassmembers , allowoptimization enum * { public static ** [] values (); public static ** valueOf ( java.lang.String ); }","title":"Processing enumeration classes"},{"location":"examples.html#serializable","text":"More complex applications may contain classes that are serialized. Depending on the way in which they are used, they may require special attention: Often, serialization is simply a means of transporting data, without long-term storage. Classes that are shrunk and obfuscated should then continue to function fine with the following additional options: -keepclassmembers class * implements java.io.Serializable { private static final java.io.ObjectStreamField [] serialPersistentFields ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } The -keepclassmembers option makes sure that any serialization methods are kept. By using this option instead of the basic -keep option, we're not forcing preservation of all serializable classes, just preservation of the listed members of classes that are actually used. Sometimes, the serialized data are stored, and read back later into newer versions of the serializable classes. One then has to take care the classes remain compatible with their unprocessed versions and with future processed versions. In such cases, the relevant classes will most likely have serialVersionUID fields. The following options should then be sufficient to ensure compatibility over time: -keepnames class * implements java.io.Serializable -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID ; private static final java.io.ObjectStreamField [] serialPersistentFields ; !static !transient <fields> ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } The serialVersionUID and serialPersistentFields lines makes sure those fields are preserved, if they are present. The <fields> line preserves all non-static, non-transient fields, with their original names. The introspection of the serialization process and the de-serialization process will then find consistent names. Occasionally, the serialized data have to remain compatible, but the classes involved lack serialVersionUID fields. I imagine the original code will then be hard to maintain, since the serial version UID is then computed from a list of features the serializable class. Changing the class ever so slightly may change the computed serial version UID. The list of features is specified in the section on Stream Unique Identifiers of Sun's Java Object Serialization Specification . The following directives should at least partially ensure compatibility with the original classes: -keepnames class * implements java.io.Serializable -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID ; private static final java.io.ObjectStreamField [] serialPersistentFields ; !static !transient <fields> ; !private <fields> ; !private <methods> ; private void writeObject ( java.io.ObjectOutputStream ); private void readObject ( java.io.ObjectInputStream ); java.lang.Object writeReplace (); java.lang.Object readResolve (); } The new options force preservation of the elements involved in the UID computation. In addition, the user will have to manually specify all interfaces of the serializable classes (using something like \" -keep interface MyInterface \"), since these names are also used when computing the UID. A fast but sub-optimal alternative would be simply keeping all interfaces with \" -keep interface * \". In the rare event that you are serializing lambda expressions in Java 8 or higher, you need to preserve some methods and adapt the hard-coded names of the classes in which they occur: -keepclassmembers class * { private static synthetic java.lang.Object $deserializeLambda$ ( java.lang.invoke.SerializedLambda ); } -keepclassmembernames class * { private static synthetic *** lambda$* ( ... ); } -adaptclassstrings com.example.Test This should satisfy the reflection in the deserialization code of the Java run-time. Note that the above options may preserve more classes and class members than strictly necessary. For instance, a large number of classes may implement the Serialization interface, yet only a small number may actually ever be serialized. Knowing your application and tuning the configuration often produces more compact results.","title":"Processing serializable classes"},{"location":"examples.html#beans","text":"If your application makes extensive use of introspection on bean classes to find bean editor classes, or getter and setter methods, then configuration may become painful. There's not much else you can do than making sure the bean class names, or the getter and setter names don't change. For instance: -keep public class com.example.MyBean { public void setMyProperty ( int ); public int getMyProperty (); } -keep public class com.example.MyBeanEditor If there are too many elements to list explicitly, wildcards in class names and method signatures might be helpful. This example preserves all possible setters and getters in classes in the package mybeans : -keep class mybeans.** { void set* ( *** ); void set* ( int , *** ); boolean is* (); boolean is* ( int ); *** get* (); *** get* ( int ); } The ' *** ' wildcard matches any type (primitive or non-primitive, array or non-array). The methods with the ' int ' arguments matches properties that are lists.","title":"Processing bean classes"},{"location":"examples.html#annotations","text":"The default configuration of the DexGuard plugins already specifies these settings for you. If your application uses annotations, you may want to preserve them in the processed output. Annotations are represented by attributes that have no direct effect on the execution of the code. However, their values can be retrieved through introspection, allowing developers to adapt the execution behavior accordingly. By default, DexGuard treats annotation attributes as optional, and removes them in the obfuscation step. If they are required, you'll have to specify this explicitly: -keepattributes *Annotation* For brevity, we're specifying a wildcarded attribute name, which will match RuntimeVisibleAnnotations , RuntimeInvisibleAnnotations , RuntimeVisibleParameterAnnotations , RuntimeInvisibleParameterAnnotations , and AnnotationDefault . Depending on the purpose of the processed code, you could refine this selection, for instance not keeping the run-time invisible annotations (which are only used at compile-time). Some code may make further use of introspection to figure out the enclosing methods of anonymous inner classes. In that case, the corresponding attribute has to be preserved as well: -keepattributes EnclosingMethod","title":"Processing annotations"},{"location":"examples.html#database","text":"Database drivers are implementations of the Driver interface. Since they are often created dynamically, you may want to preserve any implementations that you are processing as entry points: -keep class * implements java.sql.Driver This option also gets rid of the note that DexGuard prints out about (java.sql.Driver)Class.forName constructs, if you are instantiating a driver in your code (without necessarily implementing any drivers yourself).","title":"Processing database drivers"},{"location":"examples.html#gson","text":"DexGuard optimizes Gson code , by detecting which domain classes are serialized using the Gson library, and then replacing the reflection-based implementation by more efficient hard-coded serialization. The GSON optimization is enabled by default and doesn't require any additional configuration. If you've disabled optimization, the GSON library still relies on reflection on the fields of the classes that it serializes. You then need to preserve the parameterless constructor and the serialized fields from being removed, optimized, or obfuscated. For example: -keepclassmembers class com.example.SerializedClass { <fields> ; <init> (); } While creating the configuration, you can specify the option -addconfigurationdebugging , to get feedback on the necessary settings at run-time. Alternatively, you can make sure the fields are explicitly annotated with @SerializedName , so the names of the fields can be obfuscated. You can then keep all of them at the same time with: -keepclasseswithmembers , allowobfuscation , includedescriptorclasses class * { @ com.google.gson.annotations.SerializedName <fields> ; } -keepclassmembers enum * { @ com.google.gson.annotations.SerializedName <fields> ; } Working sample project: samples/advanced/Gson","title":"Optimizing GSON code"},{"location":"examples.html#injection","text":"The DexGuard default configurations already specify these settings for you. Your application may be using a framework for dependency injection, such as Spring. Such frameworks automatically assign instances of resource classes to fields and method parameters. They heavily rely on annotations and introspection, even accessing private class members directly. We then have to avoid that such fields or methods are removed or renamed. For example: -keepclassmembers class * { @ javax.annotation.Resource * ; } The Spring framework has another similar annotation @Autowired : -keepclassmembers class * { @ org.springframework.beans.factory.annotation.Autowired * ; }","title":"Processing dependency injection"},{"location":"examples.html#dagger","text":"The DexGuard default configurations already specify these settings for you. Your application may be using the Dagger library for its dependency injection. Dagger 1 relies heavily on reflection, so you may need some additional configuration to make sure it continues to work. DexGuard's default configuration already keeps some required classes: -keepclassmembers , allowobfuscation class * { @ dagger.** * ; } -keep class **$$ModuleAdapter -keep class **$$InjectAdapter -keep class **$$StaticInjection -if class **$$ModuleAdapter -keep class < 1 > -if class **$$InjectAdapter -keep class < 1 > -if class **$$StaticInjection -keep class < 1 > -keepnames class dagger.Lazy That way, Dagger can combine the corresponding pairs of classes, based on their names. Furthermore, if your code injects dependencies into some given classes with an annotation like @Module(injects = { SomeClass.class }, ...) , you need to preserve the specified names as well: -keep class com.example.SomeClass Dagger 2 no longer relies on reflection. You don't need to preserve any classes there. Working sample project: samples/advanced/Dagger","title":"Processing Dagger code"},{"location":"examples.html#butterknife","text":"If your application includes Butterknife to inject views, you also need a few lines of configuration, since Butterknife relies on reflection to tie together the code at runtime: -keep @ interface butterknife.* -keepclasseswithmembers class * { @ butterknife.* <fields> ; } -keepclasseswithmembers class * { @ butterknife.* <methods> ; } -keepclasseswithmembers class * { @ butterknife.On* <methods> ; } -keep class **$$ViewInjector { public static void inject ( ... ); public static void reset ( ... ); } -keep class **$$ViewBinder { public static void bind ( ... ); public static void unbind ( ... ); } -if class **$$ViewBinder -keep class < 1 > -keep class ** _ViewBinding { <init> ( < 1 > , android.view.View ); } -if class ** _ViewBinding -keep class < 1 > These settings preserve the Butterknife annotations, the annotated fields and methods, and the generated classes and methods that Butterknife accesses by reflection.","title":"Processing Butterknife code"},{"location":"examples.html#restring","text":"If you application includes the Restring library to dynamically replace resource strings, you need some additional configuration. Restring relies on the names of resource strings (with Resources#getResourceEntryName ) and the names of attributes in resource XML files (with AttributeSet#getAttributeName ). Conservatively, you can keep all resource strings with their original names, and all attribute names: -keepresources string/* * -keepresourcexmlattributenames * * For more fine-tuned settings without the broad wildcards, you can inspect the StringsLoader implementation in your code or specify the option -addconfigurationdebugging , to get feedback on the necessary settings at run-time.","title":"Processing Restring code"},{"location":"examples.html#resources","text":"Your Android application typically contains resources and resource files. It will generally access them through their numeric IDs from R classes, for example R.drawable.my_icon . The shrinking, optimization, and obfuscation steps handle such use automatically. However, if your application accesses some resources by reflection, based on their name strings, you need to preserve these names from being obfuscated. For example, for resources.getIdentifier(\"my_icon\", \"drawable\", package) , you need to preserve the corresponding resource with its original name: -keepresources drawable/my_icon The -keepresources option preserves the specified resources. You can use wildcards. For a quick test, you can preserve all resources with their original names: -keepresources */ * In some rare cases, your application may be referring to the resource files directly, by their names. You then need to preserve them with their original names. For example: -keepresourcefiles res/drawable*/my_icon.png The -keepresourcefiles option preserves the specified resource files, which are technically independent from the corresponding resources. With wild-cards: -keepresourcefiles res/*/ *","title":"Processing Android resources"},{"location":"examples.html#resourcefiles","text":"If your application contains resource files, it may be necessary to adapt their names and/or their contents when the application is obfuscated. The following two options can achieve this automatically: -adaptresourcefilenames **.properties , **.gif , **.jpg -adaptresourcefilecontents **.properties,META-INF/MANIFEST.MF The -adaptresourcefilenames option in this case renames properties files and image files in the processed output, based on the obfuscated names of their corresponding class files (if any). The -adaptresourcefilecontents option looks for class names in properties files and in the manifest file, and replaces these names by the obfuscated names (if any). You'll probably want to adapt the filters to suit your application.","title":"Processing general resource files"},{"location":"examples.html#manifestfiles","text":"As illustrated in the previous section, manifest files can be treated like ordinary resource files. DexGuard can adapt obfuscated class names in the files, but it won't make any other changes. If you want anything else, you should apply an external tool. For instance, if a manifest file contains signing information, you should sign the jar again after it has been processed. If you're merging several input jars into a single output jar, you'll have to pick one, typically by specifying filters : -injars in1.jar -injars in2.jar(!META-INF/MANIFEST.MF) -injars in3.jar(!META-INF/MANIFEST.MF) -outjars out.jar The filters will let DexGuard copy the manifest file from the first jar and ignore any manifest files in the second and third input jars. Note that DexGuard will leave the order of the files in the jars unchanged; manifest files are not necessarily put first.","title":"Processing manifest files"},{"location":"examples.html#reflection","text":"You can add reflection to obfuscate access to sensitive APIs, with the option -accessthroughreflection . For instance, this option replaces access to the standard cryptographic SecretKey class by equivalent reflective code: -accessthroughreflection class javax.crypto.SecretKey { byte ] getEncoded (); } For better obfuscation, you'll typically want to encrypt the resulting strings: -encryptstrings \" javax.crypto.SecretKey \" , \" getEncoded \" or simply all strings in the class from which the cryptographic class is called: -encryptstrings class com.example.MySecretClass Finally, you can add another layer of obfuscation by also encrypting the latter class: -encryptclasses com.example.MySecretClass Working sample project: samples/basic/Reflection","title":"Adding reflection for sensitive APIs"},{"location":"examples.html#classencryption","text":"You can encrypt entire classes by specifying them with the option -encryptclasses . It accepts a filter , which can contain wildcards and negators. For example: -encryptclasses com.example.MySecretClass , com.example.MySecretClass $ * This option instructs to encrypt the specified class and all of its inner classes. The latter classes are easy to forget, because they are defined in the same source file, but they may be important too. Working sample project: samples/basic/ClassEncryption","title":"Encrypting classes"},{"location":"examples.html#stringencryption","text":"There are a few alternative ways to specify which constant strings in the code should be encrypted, with the option -encryptstrings . The shortest way is to specify the strings literally: -encryptstrings \" Some secret string \" , \" Some other secret string \" In this case, the option has a filter , which can contain wildcards and negators. Alternatively, you can specify final String fields, whose strings should be encrypted wherever they occur. For example: -encryptstrings public class com.example.MyConstants { public static final java.lang.String SECRET_KEY ; } Alternatively, you can specify methods whose constant strings should all be encrypted. For example: -encryptstrings public class com.example.MySensitiveClass { public void mySecretMethod (); } Finally, you can just specify classes whose constant strings should all be encrypted. For example: -encryptstrings public class com.example.MySecretClass In these last three cases, the options have class specifications that specify one or more classes, fields, or methods. These specifications support multiple elements and various wildcards. Working sample project: samples/basic/StringEncryption","title":"Encrypting strings"},{"location":"examples.html#stacktrace","text":"The DexGuard default configurations already specify these settings for you. These options let obfuscated applications or libraries produce stack traces that can still be deciphered later on: -printmapping out.map -renamesourcefileattribute SourceFile -keepattributes SourceFile , LineNumberTable We're keeping all source file attributes, but we're replacing their values by the string \"SourceFile\". We could use any string. We're also keeping the line number tables of all methods. Whenever both of these attributes are present, the Java run-time environment will include line number information when printing out exception stack traces. The information will only be useful if we can map the obfuscated names back to their original names, so we're saving the mapping to a file out.map . The information can then be used by the ReTrace tool to restore the original stack trace.","title":"Producing useful obfuscated stack traces"},{"location":"examples.html#repackaging","text":"The DexGuard default configurations already specify these settings for you. Package names can be obfuscated in various ways, with increasing levels of obfuscation and compactness. For example, consider the following classes: mycompany.myapplication.MyMain mycompany.myapplication.Foo mycompany.myapplication.Bar mycompany.myapplication.extra.FirstExtra mycompany.myapplication.extra.SecondExtra mycompany.util.FirstUtil mycompany.util.SecondUtil Let's assume the class name mycompany.myapplication.MyMain is the main application class that is kept by the configuration. All other class names can be obfuscated. By default, packages that contain classes that can't be renamed aren't renamed either, and the package hierarchy is preserved. This results in obfuscated class names like these: mycompany.myapplication.MyMain mycompany.myapplication.a mycompany.myapplication.b mycompany.myapplication.a.a mycompany.myapplication.a.b mycompany.a.a mycompany.a.b The -flattenpackagehierarchy option obfuscates the package names further, by flattening the package hierarchy of obfuscated packages: -flattenpackagehierarchy ' myobfuscated ' The obfuscated class names then look as follows: mycompany.myapplication.MyMain mycompany.myapplication.a mycompany.myapplication.b myobfuscated.a.a myobfuscated.a.b myobfuscated.b.a myobfuscated.b.b Alternatively, the -repackageclasses option obfuscates the entire packaging, by combining obfuscated classes into a single package: -repackageclasses ' myobfuscated ' The obfuscated class names then look as follows: mycompany.myapplication.MyMain mycompany.myapplication.a mycompany.myapplication.b myobfuscated.a myobfuscated.b myobfuscated.c myobfuscated.d Additionally specifying the -allowaccessmodification option allows access permissions of classes and class members to be broadened, opening up the opportunity to repackage all obfuscated classes: -repackageclasses ' myobfuscated ' -allowaccessmodification The obfuscated class names then look as follows: mycompany.myapplication.MyMain myobfuscated.a myobfuscated.b myobfuscated.c myobfuscated.d myobfuscated.e myobfuscated.f The specified target package can always be the root package. For instance: -repackageclasses '' -allowaccessmodification The obfuscated class names are then the shortest possible names: mycompany.myapplication.MyMain a b c d e f Note that not all levels of obfuscation of package names may be acceptable for all code. Notably, you may have to take into account that your application may contain resource files that have to be adapted.","title":"Obfuscating package names"},{"location":"examples.html#samsungmarket","text":"If you're publishing your Android application on the Samsung app market, and you get \"File upload has failed. There is no application ID(PackageName) or Version information(VersionName) in the Android Manifest.xml file you have registered.\", then you need to preserve the mentioned resource XML attribute names in the AndroidManifest.xml : -keepresourcexmlattributenames manifest/package,manifest/versionName The Samsung market parses these attributes when you upload your application, and they can't handle obfuscated names. Other markets may try to read even more attributes. You could then refine your configuration experimentally, or just not obfuscate any attributes in the manifest at all: -keepresourcexmlattributenames manifest/* *","title":"Publishing on the Samsung app market"},{"location":"examples.html#logging","text":"You can let DexGuard remove logging code. The trick is to specify that the logging methods don't have side-effects \u2014 even though they actually do, since they write to the console or to a log file. DexGuard will take your word for it and remove the invocations (in the optimization step) and if possible the logging classes and methods themselves (in the shrinking step). For example, this configuration removes invocations of the Android logging methods: -assumenosideeffects class android.util.Log { public static boolean isLoggable ( java.lang.String , int ); public static int v ( ... ); public static int i ( ... ); public static int w ( ... ); public static int d ( ... ); public static int e ( ... ); } The wildcards are a shortcut to match all versions of the methods. Be careful not to use a * wildcard to match all methods, because it would also match methods like wait() , higher up the hierarchy. Removing those invocations will generally break your code. Note that you generally can't remove logging code that uses System.out.println , since you would be removing all invocations of java.io.PrintStream#println , which could break your application. You can work around it by creating your own logging methods and let DexGuard remove those. Working sample project: samples/basic/LoggingRemoval","title":"Removing logging code"},{"location":"examples.html#restructuring","text":"In simple applications, all output classes and resources files are merged into a single jar. For example: -injars classes -injars in1.jar -injars in2.jar -injars in3.jar -outjars out.jar This configuration merges the processed versions of the files in the classes directory and the three jars into a single output jar out.jar . If you want to preserve the structure of your input jars (and/or apks, aars, aabs, wars, ears, jmods, zips, or directories), you can specify an output directory (or an apk, an aar, an aab, a war, an ear, a jmod, or a zip). For example: -injars in1.jar -injars in2.jar -injars in3.jar -outjars out The input jars will then be reconstructed in the directory out , with their original names. You can also combine archives into higher level archives. For example: -injars in1.jar -injars in2.jar -injars in3.jar -outjars out.war The other way around, you can flatten the archives inside higher level archives into simple archives: -injars in.war -outjars out.jar This configuration puts the processed contents of all jars inside in.war (plus any other contents of in.war ) into out.jar . If you want to combine input jars (and/or apks, aabs, aars, wars, ears, jmods, zips, or directories) into output jars (and/or apks, aabs, aars, wars, ears, jmods, zips, or directories), you can group the -injars and -outjars options. For example: -injars base_in1.jar -injars base_in2.jar -injars base_in3.jar -outjars base_out.jar -injars extra_in.jar -outjars extra_out.jar This configuration puts the processed results of all base_in*.jar jars into base_out.jar , and the processed results of the extra_in.jar into extra_out.jar . Note that only the order of the options matters; the additional whitespace is just for clarity. This grouping, archiving, and flattening can be arbitrarily complex. DexGuard always tries to package output archives in a sensible way, reconstructing the input entries as much as required.","title":"Restructuring the output archives"},{"location":"examples.html#filtering","text":"The default configuration of the DexGuard plugins already specifies these settings for you. If you want even greater control, you can add filters to the input and the output, filtering out apks, aabs, jars, aars, wars, ears, jmods, zips, and/or ordinary files. For example, if you want to disregard certain files from an input jar: -injars in.jar(!images/**) -outjars out.jar This configuration removes any files in the images directory and its subdirectories. Such filters can be convenient for avoiding warnings about duplicate files in the output. For example, only keeping the manifest file from a first input jar: -injars in1.jar -injars in2.jar(!META-INF/MANIFEST.MF) -injars in3.jar(!META-INF/MANIFEST.MF) -outjars out.jar It is also possible to filter the jars (and/or apks, aabs, aars, wars, ears, jmods, zips) themselves, based on their names. For example: -injars in(**/acme_*.jar;) -outjars out.jar Note the semi-colon in the filter; the filter in front of it applies to jar names. In this case, only acme_*.jar jars are read from the directory in and its subdirectories. Filters for war names, ear names, and zip names can be prefixed with additional semi-colons. All types of filters can be combined. They are orthogonal. On the other hand, you can also filter the output, in order to control what content goes where. For example: -injars in.jar -outjars code_out.jar(**.class) -outjars resources_out.jar This configuration splits the processed output, sending **.class files to code_out.jar , and all remaining files to resources_out.jar . Again, the filtering can be arbitrarily complex, especially when combined with grouping input and output.","title":"Filtering the input and the output"},{"location":"examples.html#deadcode","text":"These options list unused classes, fields, and methods in the application com.example.MyApplication : -injars in.jar -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -dontoptimize -dontobfuscate -dontpreverify -printusage -keep public class com.example.MyApplication { public static void main ( java.lang.String [] ); } We're not specifying an output jar, just printing out some results. We're saving some processing time by skipping the other processing steps. The java compiler inlines primitive constants and String constants ( static final fields). DexGuard would therefore list such fields as not being used in the class files that it analyzes, even if they are used in the source files. We can add a -keepclassmembers option that keeps those fields a priori, in order to avoid having them listed: -keepclassmembers class * { static final % * ; static final java.lang.String * ; }","title":"Finding dead code"},{"location":"examples.html#annotations","text":"The traditional DexGuard configuration allows to keep a clean separation between the code and the configuration for shrinking, optimization, and obfuscation. However, it is also possible to define specific annotations, and then annotate the code to configure the processing. You can find a set of such predefined annotations in the directory extras/annotations/lib in the DexGuard distribution. The annotation classes are defined in annotations.jar . The corresponding DexGuard configuration (or meta-configuration, if you prefer) is specified in annotations.pro . With these files, you can start annotating your code. For instance, a java source file Application.java can be annotated as follows: @KeepApplication public class Application { // .... } The DexGuard configuration file for the application can then be simplified by leveraging these annotations: -injars in.jar -outjars out.jar -libraryjars /usr/local/android-sdk/platforms/android-28/android.jar -include lib/annotations.pro The annotations are effectively replacing the application-dependent -keep options. You may still wish to add traditional -keep options for processing native methods , enumerations , serializable classes , and annotations . The directory extras/annotations contains more examples that illustrate some of the possibilities.","title":"Processing annotations"},{"location":"fingerprinting.html","text":"DexGuard's device fingerprinting addon offers an API for generating persistent device identifiers . The identifiers are generated using various device specific attributes and algorithms. The API offers different configuration options for generating a device identifier that is tied to various aspects of the user's device. It is important to carefully choose the configuration options as these impact the lifetime of the unique identifier. Use Cases \u00b6 Second-layer security measures - The unique device identifiers can be used together with account credentials to verify the device that the user is authenticating on. If the identifier is not recognized by the server this might indicate that the credentials are stolen and the user needs to be verified using second factor authentication measures. Device Tracking - It is possible to generate device persistent hardware identifiers which are ideal for device tracking purposes in advertisement networks. Sessions tied to the device - It is possible to generate unique device identifiers which are limited in time. The configuration options enable the developer to choose the lifetime of a session identifier, e.g., between device reboots or tied to the application lifecycle. Analytics Tracking - Device identifiers can be used to track unique application installs or in more advanced analytics tracking solutions. Dependencies for device fingerprinting \u00b6 DexGuard comes with a separate Java API for generating unique device identifiers. You can find the library in the DexGuard distribution at: lib/devicefingerprinting-runtime.jar This JAR archive should be added to your application project in order to use the API in your application. Prerequisites \u00b6 Android Permissions \u00b6 The fingerprinting algorithm accesses various device specific attributes. It is therefore important to add the following permissions to the AndroidManifest.xml file in your project: <uses-permission android:name= \"android.permission.READ_PHONE_STATE\" /> <uses-permission android:name= \"android.permission.ACCESS_WIFI_STATE\" /> <uses-permission android:name= \"android.permission.INTERNET\" /> Note: the generated device fingerprint is directly affected by the amount of permissions it has. The user is able to revoke or grant one of these permissions in subsequent fingerprinting attempts, as such, the fingerprints might be different. Best practices are to ensure all the permissions are granted before generating the device fingerprint. Android 6.0+ \u00b6 On Android version 6.0 and higher, users are allowed to revoke permissions during runtime. As such, it is important to make sure that all the required permissions are available during runtime: /** * Check if we have all the necessary permissions, this is important on * Android 6.0+ as users are allowed to revoke permissions anytime. */ private void checkPermissions () { if ( Build . VERSION . SDK_INT >= 23 ) { ActivityCompat . requestPermissions ( this , FingerprintGenerator . REQUIRED_PERMISSIONS , PERMISSION_REQUEST_CODE ); } else { permissionGranted = true ; } } Generating Fingerprints \u00b6 Generating a fingerprint using the library can be achieved by using a single API call: Fingerprint fp = FingerprintGenerator . generateFingerprint ( context ); This will return a Fingerprint object that allows to access the calculated device identifier as raw byte array ( getBytes() ). isValid \u00b6 The boolean ( isValid() ) is an indication if the generated fingerprint is unique. A false value indicates that the fingerprint is not unique. Configuration Options \u00b6 By default, without configuration options, the fingerprinting API generates a hardware tied device fingerprint. This means that the fingerprint contains highly persistent information that does not change, even after system wipes or OS upgrades. However, it is also possible to configure the generated device fingerprint to capture additional information of the device: OS_BUILD_INFO - Add OS specific information to the fingerprint. This will tie the fingerprint to the currently installed operating system. OS_SESSION - Add session specific information to the fingerprint. This will tie the fingerprint to the current boot session. This fingerprint will change between reboot times. APP_PROCESS - Add process specific information to the fingerprint. This will tie the fingerprint to the current execution environment of the application. This fingerprint will change between application relaunches. For more information and usage we refer to the API Javadoc and the sample at samples/addons/DeviceFingerprinting/ .","title":"Device Fingerprinting"},{"location":"fingerprinting.html#use-cases","text":"Second-layer security measures - The unique device identifiers can be used together with account credentials to verify the device that the user is authenticating on. If the identifier is not recognized by the server this might indicate that the credentials are stolen and the user needs to be verified using second factor authentication measures. Device Tracking - It is possible to generate device persistent hardware identifiers which are ideal for device tracking purposes in advertisement networks. Sessions tied to the device - It is possible to generate unique device identifiers which are limited in time. The configuration options enable the developer to choose the lifetime of a session identifier, e.g., between device reboots or tied to the application lifecycle. Analytics Tracking - Device identifiers can be used to track unique application installs or in more advanced analytics tracking solutions.","title":"Use Cases"},{"location":"fingerprinting.html#dependencies-for-device-fingerprinting","text":"DexGuard comes with a separate Java API for generating unique device identifiers. You can find the library in the DexGuard distribution at: lib/devicefingerprinting-runtime.jar This JAR archive should be added to your application project in order to use the API in your application.","title":"Dependencies for device fingerprinting"},{"location":"fingerprinting.html#prerequisites","text":"","title":"Prerequisites"},{"location":"fingerprinting.html#android-permissions","text":"The fingerprinting algorithm accesses various device specific attributes. It is therefore important to add the following permissions to the AndroidManifest.xml file in your project: <uses-permission android:name= \"android.permission.READ_PHONE_STATE\" /> <uses-permission android:name= \"android.permission.ACCESS_WIFI_STATE\" /> <uses-permission android:name= \"android.permission.INTERNET\" /> Note: the generated device fingerprint is directly affected by the amount of permissions it has. The user is able to revoke or grant one of these permissions in subsequent fingerprinting attempts, as such, the fingerprints might be different. Best practices are to ensure all the permissions are granted before generating the device fingerprint.","title":"Android Permissions"},{"location":"fingerprinting.html#android-60","text":"On Android version 6.0 and higher, users are allowed to revoke permissions during runtime. As such, it is important to make sure that all the required permissions are available during runtime: /** * Check if we have all the necessary permissions, this is important on * Android 6.0+ as users are allowed to revoke permissions anytime. */ private void checkPermissions () { if ( Build . VERSION . SDK_INT >= 23 ) { ActivityCompat . requestPermissions ( this , FingerprintGenerator . REQUIRED_PERMISSIONS , PERMISSION_REQUEST_CODE ); } else { permissionGranted = true ; } }","title":"Android 6.0+"},{"location":"fingerprinting.html#generating-fingerprints","text":"Generating a fingerprint using the library can be achieved by using a single API call: Fingerprint fp = FingerprintGenerator . generateFingerprint ( context ); This will return a Fingerprint object that allows to access the calculated device identifier as raw byte array ( getBytes() ).","title":"Generating Fingerprints"},{"location":"fingerprinting.html#isvalid","text":"The boolean ( isValid() ) is an indication if the generated fingerprint is unique. A false value indicates that the fingerprint is not unique.","title":"isValid"},{"location":"fingerprinting.html#configuration-options","text":"By default, without configuration options, the fingerprinting API generates a hardware tied device fingerprint. This means that the fingerprint contains highly persistent information that does not change, even after system wipes or OS upgrades. However, it is also possible to configure the generated device fingerprint to capture additional information of the device: OS_BUILD_INFO - Add OS specific information to the fingerprint. This will tie the fingerprint to the currently installed operating system. OS_SESSION - Add session specific information to the fingerprint. This will tie the fingerprint to the current boot session. This fingerprint will change between reboot times. APP_PROCESS - Add process specific information to the fingerprint. This will tie the fingerprint to the current execution environment of the application. This fingerprint will change between application relaunches. For more information and usage we refer to the API Javadoc and the sample at samples/addons/DeviceFingerprinting/ .","title":"Configuration Options"},{"location":"introduction.html","text":"DexGuard processes Android applications and libraries, making them smaller, more efficient, and better hardened against reverse engineering and tampering. DexGuard reads the compiled input (jars, apks, aabs, aars, wars, ears, jmods, zips, or directories, containing class files, dex files, native libraries, resource files, asset files). DexGuard then optimizes and protects the code and the resources. DexGuard packages the processed output in output archives (jars, aars, wars, ears, zips, apks, or directories, containing Dalvik bytecode). DexGuard can optionally sign and align these archives, removing the need for external tools. DexGuard requires the platform libraries (jars, apks, aabs, aars, wars, ears, jmods, zips, or directories) to properly process the code. For the standard Android platform, this is simply android.jar . Optimizing and protecting applications \u00b6 DexGuard can be used to protect applications that have been produced by the Android build toolchain. Source code and resources Unprotected application (.apk) Optimized and protected application (.apk) Android manifest (text .xml) Java source code (.java) Native source code (.c, .cpp) Resources (text .xml) Resource files (text .xml, .png,...) Assets (.txt,...) R8 Android manifest Dalvik byte code native code resources resource files assets DexGuard Protected Android manifest Protected Dalvik byte code Protected native code Protected resources Protected resource files Protected assets DexGuard reads the input .apk file and optimizes and protects the code and the resources. DexGuard packages the processed output into an output apk. DexGuard can optionally sign and align the output, removing the need for external tools. Optimizing and protecting libraries \u00b6 You can also apply DexGuard to library projects , if the libraries are end-products that you wish to distribute. Libraries are inherently more difficult to protect, due to the surface area of their public APIs. Notably, all public classes, fields, and methods need to be preserved, so developers can actually use the libraries in their own projects. Also, .aar files contain all XML resources in their readable text form. Source code and resources Compiled code and resources Optimized and protected library (.aar or .jar) Android manifest (text .xml) Java source code (.java) javac Java byte code (.class) Native source code (.c, .cpp) clang Native code (.so) Resources (text .xml) Resource files (text .xml, .png,...) Assets (.txt,...) DexGuard Android manifest (text .xml) Protected Java byte code Protected native code Resources (text .xml) Resource files (text .xml, .png,...) Protected assets Within these constraints, DexGuard offers the same functionality for library projects as for application projects \u2014 optimization, name obfuscation, string encryption, asset encryption, etc. Tamper detection on the eventual .apk file is an exception, because compiling a library into an application is like tampering. You can include tamper detection based on the application's certificate hash, if you know the hash in advance. We recommend to process the final applications as well, if possible. DexGuard can then globally optimize and harden all compiled resources and code, creating a better overall results. Processing steps \u00b6 DexGuard processes the resources and the code in distinct but seamless steps. DexGuard processing steps Compiled code and resources Shrinking Optimization Obfuscation Encryption Protected code and resources The shrinking step detects and removes unused resources, resource files, native libraries, classes, fields, methods, and attributes. The optimization step analyzes and optimizes the resources and the bytecode of the methods. The obfuscation step renames the remaining resources, resource files, native libraries, classes, fields, and methods using short meaningless names. It obfuscates the bytecode inside specified methods. Finally, it encrypts specified strings, classes, native libraries, resource files, and assets. These steps make the code base smaller, more efficient, and harder to reverse-engineer. For application projects, a final conversion step also translates the Java bytecode ( *.class ) to Dalvik bytecode ( classes.dex ). Entry points \u00b6 In order to determine which resources and code have to be preserved and which resources and code can be discarded or obfuscated, DexGuard has to know the entry points to your code. For example, the main entry point for an application is the Android manifest. In all processing steps, preserving the entry points ensures that they can still be accessed by their original names: In the shrinking step , DexGuard starts from these seeds and recursively determines which resources, resource files, native libraries, classes, fields, and methods are actually used. It then discards all other resources, resource files, native libraries, classes, fields, and methods. In the optimization step , DexGuard further optimizes the code, while still preserving all entry points. Unused parameters may be removed; resources, constants, and entire methods may be inlined; classes, fields, and methods may be made private, static, or final, etc. In the obfuscation step , DexGuard renames resources, resource files, native libraries, classes, fields, and methods that are not entry points. DexGuard's default configuration takes care of the entry points for Android and for a number of common third-party libraries. Otherwise, the Usage section of this manual describes the necessary -keep options and the Examples section provides examples. Reflection \u00b6 Reflection and introspection present particular problems for any automatic processing of code. Resources, resource files, classes, fields, or methods that are accessed or instantiated dynamically (that is, by name) have to be specified as entry points too. For example, constructs with Resources#getIdentifier or Class.forName() may refer to any resource or any class at run-time. It is generally impossible to compute which resources or classes have to be preserved (with their original names), since the code may create their names dynamically. You therefore have to specify them in your DexGuard configuration, with the same simple -keep options. DexGuard already detects and handles the following cases for you: Class.forName(\"SomeClass\") SomeClass.class SomeClass.class.getField(\"someField\") SomeClass.class.getDeclaredField(\"someField\") SomeClass.class.getMethod(\"someMethod\", null) SomeClass.class.getMethod(\"someMethod\", new Class[] { A.class,... }) SomeClass.class.getDeclaredMethod(\"someMethod\", null) SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] { A.class,... }) AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, \"someField\") AtomicLongFieldUpdater.newUpdater(SomeClass.class, \"someField\") AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, \"someField\") resources.getIdentifier(\"someResource\", \"string\", \"com.example\") assetManager.open(\"someAsset\") assetManager.openFd(\"someAsset\") Typeface.createFromAsset(assetManager, \"someTypeface\") System.loadLibrary(\"someLibrary\") The string literals that refer to classes, class members, resources, asset files, and native libraries may of course be different, but the code patterns should be exactly the same for DexGuard to recognize them. DexGuard then preserves the referenced classes, class members, resources, asset files, and native libraries in the shrinking step, and consistently updates their names and the string literals in the obfuscation step. Furthermore, DexGuard will offer some suggestions if keeping some classes or class members appears necessary. For example, DexGuard will note constructs like \" (SomeClass)Class.forName(variable).newInstance() \". These might be an indication that the class or interface SomeClass and/or its implementations may need to be preserved. You can then adapt your configuration accordingly. Finally, DexGuard can also help for to find less obvious cases of reflection at run-time . The option -addconfigurationdebugging lets ProGuard instrument the processed code with debugging statements. These print out suggestions for missing ProGuard configuration. They can be very useful to get practical hints, if your processed code crashes because it still lacks some configuration. You can generally just copy/paste the suggestions from the console into your configuration file. For proper results, you should at least be somewhat familiar with the code that you are processing. Obfuscating code that performs a lot of reflection may require trial and error, especially without the necessary information about the internals of the code. Practically, these are the options that you can specify to preserve elements in the various components of your application: Reducing shrinking/optimization/obfuscation Android manifest (binary .xml) -keepresourcexmlattributenames Java byte code (.class) -keep -keepattributes Native code (.so) -keep -keepresourcefiles Resources (.arsc) -keepresources Resource files (binary .xml, .png,...) -keepresourcefiles Assets (.txt,...) -keepresourcefiles The options all have arguments to specify which elements exactly need to be preserved.","title":"Introduction"},{"location":"introduction.html#optimizing-and-protecting-applications","text":"DexGuard can be used to protect applications that have been produced by the Android build toolchain. Source code and resources Unprotected application (.apk) Optimized and protected application (.apk) Android manifest (text .xml) Java source code (.java) Native source code (.c, .cpp) Resources (text .xml) Resource files (text .xml, .png,...) Assets (.txt,...) R8 Android manifest Dalvik byte code native code resources resource files assets DexGuard Protected Android manifest Protected Dalvik byte code Protected native code Protected resources Protected resource files Protected assets DexGuard reads the input .apk file and optimizes and protects the code and the resources. DexGuard packages the processed output into an output apk. DexGuard can optionally sign and align the output, removing the need for external tools.","title":"Optimizing and protecting applications"},{"location":"introduction.html#optimizing-and-protecting-libraries","text":"You can also apply DexGuard to library projects , if the libraries are end-products that you wish to distribute. Libraries are inherently more difficult to protect, due to the surface area of their public APIs. Notably, all public classes, fields, and methods need to be preserved, so developers can actually use the libraries in their own projects. Also, .aar files contain all XML resources in their readable text form. Source code and resources Compiled code and resources Optimized and protected library (.aar or .jar) Android manifest (text .xml) Java source code (.java) javac Java byte code (.class) Native source code (.c, .cpp) clang Native code (.so) Resources (text .xml) Resource files (text .xml, .png,...) Assets (.txt,...) DexGuard Android manifest (text .xml) Protected Java byte code Protected native code Resources (text .xml) Resource files (text .xml, .png,...) Protected assets Within these constraints, DexGuard offers the same functionality for library projects as for application projects \u2014 optimization, name obfuscation, string encryption, asset encryption, etc. Tamper detection on the eventual .apk file is an exception, because compiling a library into an application is like tampering. You can include tamper detection based on the application's certificate hash, if you know the hash in advance. We recommend to process the final applications as well, if possible. DexGuard can then globally optimize and harden all compiled resources and code, creating a better overall results.","title":"Optimizing and protecting libraries"},{"location":"introduction.html#processing-steps","text":"DexGuard processes the resources and the code in distinct but seamless steps. DexGuard processing steps Compiled code and resources Shrinking Optimization Obfuscation Encryption Protected code and resources The shrinking step detects and removes unused resources, resource files, native libraries, classes, fields, methods, and attributes. The optimization step analyzes and optimizes the resources and the bytecode of the methods. The obfuscation step renames the remaining resources, resource files, native libraries, classes, fields, and methods using short meaningless names. It obfuscates the bytecode inside specified methods. Finally, it encrypts specified strings, classes, native libraries, resource files, and assets. These steps make the code base smaller, more efficient, and harder to reverse-engineer. For application projects, a final conversion step also translates the Java bytecode ( *.class ) to Dalvik bytecode ( classes.dex ).","title":"Processing steps"},{"location":"introduction.html#entry-points","text":"In order to determine which resources and code have to be preserved and which resources and code can be discarded or obfuscated, DexGuard has to know the entry points to your code. For example, the main entry point for an application is the Android manifest. In all processing steps, preserving the entry points ensures that they can still be accessed by their original names: In the shrinking step , DexGuard starts from these seeds and recursively determines which resources, resource files, native libraries, classes, fields, and methods are actually used. It then discards all other resources, resource files, native libraries, classes, fields, and methods. In the optimization step , DexGuard further optimizes the code, while still preserving all entry points. Unused parameters may be removed; resources, constants, and entire methods may be inlined; classes, fields, and methods may be made private, static, or final, etc. In the obfuscation step , DexGuard renames resources, resource files, native libraries, classes, fields, and methods that are not entry points. DexGuard's default configuration takes care of the entry points for Android and for a number of common third-party libraries. Otherwise, the Usage section of this manual describes the necessary -keep options and the Examples section provides examples.","title":"Entry points"},{"location":"introduction.html#reflection","text":"Reflection and introspection present particular problems for any automatic processing of code. Resources, resource files, classes, fields, or methods that are accessed or instantiated dynamically (that is, by name) have to be specified as entry points too. For example, constructs with Resources#getIdentifier or Class.forName() may refer to any resource or any class at run-time. It is generally impossible to compute which resources or classes have to be preserved (with their original names), since the code may create their names dynamically. You therefore have to specify them in your DexGuard configuration, with the same simple -keep options. DexGuard already detects and handles the following cases for you: Class.forName(\"SomeClass\") SomeClass.class SomeClass.class.getField(\"someField\") SomeClass.class.getDeclaredField(\"someField\") SomeClass.class.getMethod(\"someMethod\", null) SomeClass.class.getMethod(\"someMethod\", new Class[] { A.class,... }) SomeClass.class.getDeclaredMethod(\"someMethod\", null) SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] { A.class,... }) AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, \"someField\") AtomicLongFieldUpdater.newUpdater(SomeClass.class, \"someField\") AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, \"someField\") resources.getIdentifier(\"someResource\", \"string\", \"com.example\") assetManager.open(\"someAsset\") assetManager.openFd(\"someAsset\") Typeface.createFromAsset(assetManager, \"someTypeface\") System.loadLibrary(\"someLibrary\") The string literals that refer to classes, class members, resources, asset files, and native libraries may of course be different, but the code patterns should be exactly the same for DexGuard to recognize them. DexGuard then preserves the referenced classes, class members, resources, asset files, and native libraries in the shrinking step, and consistently updates their names and the string literals in the obfuscation step. Furthermore, DexGuard will offer some suggestions if keeping some classes or class members appears necessary. For example, DexGuard will note constructs like \" (SomeClass)Class.forName(variable).newInstance() \". These might be an indication that the class or interface SomeClass and/or its implementations may need to be preserved. You can then adapt your configuration accordingly. Finally, DexGuard can also help for to find less obvious cases of reflection at run-time . The option -addconfigurationdebugging lets ProGuard instrument the processed code with debugging statements. These print out suggestions for missing ProGuard configuration. They can be very useful to get practical hints, if your processed code crashes because it still lacks some configuration. You can generally just copy/paste the suggestions from the console into your configuration file. For proper results, you should at least be somewhat familiar with the code that you are processing. Obfuscating code that performs a lot of reflection may require trial and error, especially without the necessary information about the internals of the code. Practically, these are the options that you can specify to preserve elements in the various components of your application: Reducing shrinking/optimization/obfuscation Android manifest (binary .xml) -keepresourcexmlattributenames Java byte code (.class) -keep -keepattributes Native code (.so) -keep -keepresourcefiles Resources (.arsc) -keepresources Resource files (binary .xml, .png,...) -keepresourcefiles Assets (.txt,...) -keepresourcefiles The options all have arguments to specify which elements exactly need to be preserved.","title":"Reflection"},{"location":"java.html","text":"DexGuard supports the obfuscation, optimization and shrinking of Java bytecode, as well as other languages that compile to it, such as Kotlin and Scala. Java 8 support \u00b6 Starting from version 9.0, DexGuard operates in post-processing mode. This means that DexGuard is no longer part of the build chain but instead it processes the artifacts produced by the Android Gradle Plugin. Because of this change, the Android Gradle Plugin is now responsible for setting the supported Java language level and carrying out any backporting or desugaring transformations. This allows you to use new language features supported by the Android Gradle Plugin as soon as they become available, without needing explicit support or updates to DexGuard. Changes made to your project to enable Java 8 support in DexGuard can be rolled back in favor of the Java 8 support offered by version 4.0 and up of the Android Gradle Plugin. For more information, please consult the relevant Android developer documentation .","title":"Java"},{"location":"java.html#java-8-support","text":"Starting from version 9.0, DexGuard operates in post-processing mode. This means that DexGuard is no longer part of the build chain but instead it processes the artifacts produced by the Android Gradle Plugin. Because of this change, the Android Gradle Plugin is now responsible for setting the supported Java language level and carrying out any backporting or desugaring transformations. This allows you to use new language features supported by the Android Gradle Plugin as soon as they become available, without needing explicit support or updates to DexGuard. Changes made to your project to enable Java 8 support in DexGuard can be rolled back in favor of the Java 8 support offered by version 4.0 and up of the Android Gradle Plugin. For more information, please consult the relevant Android developer documentation .","title":"Java 8 support"},{"location":"javascript.html","text":"DexGuard can obfuscate the Javascript resource files in your application, to additionally raise the bar for attackers who try to reverse engineer and modify your applications. The greater the variation in the obfuscation of your applications, the harder it becomes for attackers and reverse engineering tools to decipher your code. DexGuard has a built-in Javascript obfuscator; please refer to the separate Javascript manual for more details on how to set up and configure the Javascript obfuscator.","title":"JavaScript"},{"location":"kotlin.html","text":"The Kotlin compiler injects code and metadata into the classes that it generates to support features not natively supported by the Java and Android environments. The metadata injected by the Kotlin compiler takes the shape of an annotation added to classes which leaks semantic information that can aid attackers. Configuration \u00b6 In most cases, you do not need to keep Kotlin metadata for app projects - therefore, no configuration changes are necessary and Dexguard can safely remove the Kotlin metadata. However there are two common reasons to explicitly keep the metadata, reflection and libraries . DexGuard only keeps the Kotlin metadata of a class if you explicitly keep that class or one of its members and you add -keepkotlinmetadata option to your configuration. For example, if you have the following keep rule for a Kotlin class named com.example.KotlinExample , by default the class is kept but its metadata is not: -keep class com.example.KotlinExample You can add -keepkotlinmetadata to your configuration to instruct DexGuard to keep and adapt Kotlin metadata: # Add this option to tell DexGuard to keep and adapt Kotlin metadata -keep kotlinmetadata Reflection \u00b6 The most common case to keep Kotlin metadata would be if you use the kotlin-reflect library. Just like when using Java reflection, -keep rules are required in your configuration to keep the specific classes and members accessed through reflection. In this case, to instruct DexGuard to keep and adapt the corresponding Kotlin metadata, add the following to your configuration: -keep kotlinmetadata A popular framework that relies on reflection is Jackson . See the sample basic/KotlinReflection for an example that shows why keeping and adapting Kotlin metadata is important for Kotlin reflection. Library Projects \u00b6 When developing an SDK that exposes Kotlin-specific features to its users, you need to preserve the metadata of the public API, so that Kotlin compiler can then detect and handle any Kotlin features. These include features such as named parameters, suspend functions, top-level functions and type aliases. In the case of a library, you would already be keeping the public API so you can simply add the following to your configuration: -keep kotlinmetadata Features \u00b6 The following features are applied if -keepkotlinmetadata is enabled: Stripping Kotlin metadata annotation from Java classes where there was not keep rule for the class or one of its members. Obfuscation is applied to Kotlin identifiers in metadata, such as class or member names, to match those in the Java class files. Kotlin specific features such as type aliases are also obfuscated. Special Kotlin identifier names are kept as expected by Kotlin where required, such as ensuring companion class names correspond with their internal field name. Kotlin parameter names are kept when using -keepparameternames . Default implementation classes ( $DefaultImpls ) of interface methods will be kept automatically when keeping the interface. Callable references are updated which ensures correct functionality and that unobfuscated strings do not remain in the code. Data Classes are adapted so that the names of properties in the autogenerated toString() methods match the obfuscated names. Intrinsics checks have their unobfuscated strings removed so that the resulting code contains no references to original parameter names, member names etc. Shrinking removes all unused Kotlin metadata components such as unused functions and properties. This ensures that, even where the Kotlin metadata is required, only the used components are kept. Optimizations are disabled for certain classes and members which are known to cause invalid metadata or, for example, where certain fields are required by the Kotlin. Kotlin Module files ( META-INF/*.kotlin_module ) are updated with obfuscated names and unused classes are removed.","title":"Kotlin"},{"location":"kotlin.html#configuration","text":"In most cases, you do not need to keep Kotlin metadata for app projects - therefore, no configuration changes are necessary and Dexguard can safely remove the Kotlin metadata. However there are two common reasons to explicitly keep the metadata, reflection and libraries . DexGuard only keeps the Kotlin metadata of a class if you explicitly keep that class or one of its members and you add -keepkotlinmetadata option to your configuration. For example, if you have the following keep rule for a Kotlin class named com.example.KotlinExample , by default the class is kept but its metadata is not: -keep class com.example.KotlinExample You can add -keepkotlinmetadata to your configuration to instruct DexGuard to keep and adapt Kotlin metadata: # Add this option to tell DexGuard to keep and adapt Kotlin metadata -keep kotlinmetadata","title":"Configuration"},{"location":"kotlin.html#reflection","text":"The most common case to keep Kotlin metadata would be if you use the kotlin-reflect library. Just like when using Java reflection, -keep rules are required in your configuration to keep the specific classes and members accessed through reflection. In this case, to instruct DexGuard to keep and adapt the corresponding Kotlin metadata, add the following to your configuration: -keep kotlinmetadata A popular framework that relies on reflection is Jackson . See the sample basic/KotlinReflection for an example that shows why keeping and adapting Kotlin metadata is important for Kotlin reflection.","title":"Reflection"},{"location":"kotlin.html#library-projects","text":"When developing an SDK that exposes Kotlin-specific features to its users, you need to preserve the metadata of the public API, so that Kotlin compiler can then detect and handle any Kotlin features. These include features such as named parameters, suspend functions, top-level functions and type aliases. In the case of a library, you would already be keeping the public API so you can simply add the following to your configuration: -keep kotlinmetadata","title":"Library Projects"},{"location":"kotlin.html#features","text":"The following features are applied if -keepkotlinmetadata is enabled: Stripping Kotlin metadata annotation from Java classes where there was not keep rule for the class or one of its members. Obfuscation is applied to Kotlin identifiers in metadata, such as class or member names, to match those in the Java class files. Kotlin specific features such as type aliases are also obfuscated. Special Kotlin identifier names are kept as expected by Kotlin where required, such as ensuring companion class names correspond with their internal field name. Kotlin parameter names are kept when using -keepparameternames . Default implementation classes ( $DefaultImpls ) of interface methods will be kept automatically when keeping the interface. Callable references are updated which ensures correct functionality and that unobfuscated strings do not remain in the code. Data Classes are adapted so that the names of properties in the autogenerated toString() methods match the obfuscated names. Intrinsics checks have their unobfuscated strings removed so that the resulting code contains no references to original parameter names, member names etc. Shrinking removes all unused Kotlin metadata components such as unused functions and properties. This ensures that, even where the Kotlin metadata is required, only the used components are kept. Optimizations are disabled for certain classes and members which are known to cause invalid metadata or, for example, where certain fields are required by the Kotlin. Kotlin Module files ( META-INF/*.kotlin_module ) are updated with obfuscated names and unused classes are removed.","title":"Features"},{"location":"license.html","text":"License, services and maintenance Agreement Version July 2020 This agreement (the \u201cAgreement\u201d) is concluded on the date of last signature of the Order in which it is included by reference (the \u201cEffective Date\u201d) by and between the GuardSquare group contracting entity specified in the relevant Order (\u201cGuardsquare\u201d), and the client contracting entity specified in the relevant Order (the \u201cClient\u201d). Guardsquare and the Client may individually be referred to as a \u201cParty\u201d and jointly as \u201cthe Parties\u201d. PREAMBLE \u00b6 Whereas Guardsquare has developed and owns certain software and is in the business of licensing such software and providing support, maintenance and other professional services in connection with such software; Whereas the Client wishes to obtain from Guardsquare the right to use such software and to be provided with support and other services in connection with such software; Whereas Guardsquare is willing to license such software to the Client and to provide the Client with maintenance and support services and other professional services in connection with such software as set forth in this Agreement. NOW THEREFORE, the Parties hereby agree as follows: 1. Definitions \u00b6 1.1 When used in this Agreement, the following terms shall have the meaning ascribed to them below: - \u201c Acceptance Date \u201d means the date on which the Licensed Products or Deliverables (as applicable) are agreed by the Client to conform to the relevant Specifications; - \u201c Applications \u201d means the (number of) applications as specified in an Order. An Application, published by the Client, may be used by several Client end users in which case the code, assets and libraries of the Application will be identical for each end user; - \u201c Confidential Information \u201d of a Party means the information of such Party, whether in written, oral, electronic or other form, which (i) is explicitly marked as confidential or proprietary, or (ii) should reasonably be considered confidential given its nature or the circumstances surrounding its disclosure, regardless of whether or not it is expressly marked as confidential, including (without being limitative) information and facts concerning a Party\u2019s and its affiliates\u2019 business plans, clients, prospects, personnel, suppliers, licensors, licensees, partners, investors, affiliates or others, training methods and materials, financial information, marketing plans, sales prospects, client lists, inventions, program devices, discoveries, ideas, concepts, know-how, techniques, formulas, blueprints, software (in object and source code form), documentation, designs, prototypes, methods, processes, procedures, codes, and any technical or trade secrets, including all copies of any of the foregoing and any analyses, studies or reports that contain, are based on, or reflect any of the foregoing. The Confidential Information of Guardsquare shall include, without being limitative, the Software and the Documentation; - \u201c Customisations Support Fee \u201d means the fees for the Support Services in respect of software Deliverables to the extent expressly agreed (in an Order) to be included under the Support Services; - \u201c Deliverable \u201d means a deliverable to be provided by Guardsquare pursuant to, and designated as such in, an Order; - \u201c Delivery Date \u201d means the agreed date on which the Licensed Products are made available to the Client by Guardsquare (which may include making available for download from a secure FTP site); - \u201c Documentation \u201d means the operating manual, including a description of the functions performed by the Software, user instructions, and all other related materials (excluding marketing material and any information posted on a (Guardsquare) website), as ordinarily supplied by Guardsquare to its customers to facilitate the use of the Software; - \u201c Employee \u201d means an individual who is hired pursuant to an employment contract in exchange for a wage. Agents, distributors, advisors, consultants, freelancers, (self-employed) (sub)contractors or any other third party shall not be considered Employees for the purposes of this Agreement; - \u201c Feedback \u201d means any suggestions or recommendations for improvement or modifications to the Software made by or on behalf of the Client; - \u201c Fees \u201d means the License Fees, Professional Services Fees, Support Fees, and fees in respect of General Support, and any other amounts payable by the Client to Guardsquare pursuant to this Agreement, as set out in an Order or as otherwise agreed in writing between duly authorized representatives of the Parties; - \u201c General Support \u201d means any support and maintenance services requested by the Client that are not in scope of the Support Services contracted by the Client (namely Basic Support or Gold Support, as specified in the relevant Order); - \u201c Intellectual Property Rights \u201d means patents, trade marks, service marks, trade secrets, copyrights, design rights, know how, Confidential Information, trade and business names, domain names, database rights, sui generis rights (including in software), rental rights and any other intellectual or industrial property or similar right throughout the world (whether registered or unregistered), including applications for registration, renewals, extensions, continuations, divisions, reissues or improvements relating to any of these rights and the right to apply for, maintain and enforce any of the preceding items; - \u201c Internal Business Purposes \u201d means use of the Software for the purpose for which it is licensed (as per the terms of the Documentation, Specifications and the license terms set out in this Agreement) with respect to the licensed (number of) Applications and SDKs only, excluding (without being limitative) sublicensing, reselling, redistribution, or otherwise commercializing or making the Software available to third parties (whether or not at a charge), and use of the Software with respect to applications or libraries other than the Applications and SDKs or with respect to Applications or SDKs that are not published by the Client; - \u201c License Fees \u201d means the annually recurring fees payable by the Client in respect of the user rights in respect of the Licensed Products granted hereunder, which License Fees also include \u2018Basic Support\u2019 Support Services; - \u201c License Parameters \u201d means the parameters defining and restricting the scope of the Software user rights granted pursuant to Section 2 of this Agreement, as specified in an Order and/or invoices issued by Guardsquare. License Parameters may include (non-exhaustive list) the (number of) Applications and SDKs, App Package names, Application names, SDK/library names, territorial restrictions, industry sector restrictions, number of Client end users and developers; - \u201c Licensed Products \u201d means the Software and the Documentation; - \u201c Object Code \u201d (or Bytecode) means software assembled or compiled in magnetic or electronic binary form on software media that is readable and usable by machines but not generally readable by humans without reverse assembly, reverse compiling or reverse engineering; - \u201c Order \u201d means an order entered into between the Parties pursuant to this Agreement, for the purchasing of Software licenses by the Client and the delivery of Support Services and/or Professional Services by Guardsquare to the Client; - \u201c App Package Name \u201d means the unique identifier of an Application (e.g. as per the app/build.gradle file), which is also unique in the Google Play store; - \u201c Professional Services \u201d means Software development, implementation and integration services, training, reviewing and testing services, or such other services in relation to the Software as may be agreed between the Parties from time to time, in an Order (but excluding Support Services); - \u201c Professional Services Fees \u201d means the Fees payable by the Client in respect of the Professional Services and Deliverables, as set out in the relevant Order; - \u201c Schedule \u201d means a schedule to this Agreement, if any; - \u201c SDK \u201d means the (number of) libraries as specified in an Order. An SDK, published by the Client, may be used by several Client end users in which case the code, assets and libraries of the SDK will be identical for each end user; - \u201c Software \u201d means the software listed in an Order, licensed to the Client by Guardsquare in accordance with the terms of this Agreement; - \u201c Source Code \u201d means the Software written in programming languages including all comments and procedural code such as job control language statements, in a form intelligible to programmers trained in and knowledgeable of the Software, and capable of being translated into the Object Code form of the Software for operation on computer equipment through assembly or compiling; - \u201c Specifications \u201d means the specifications for the Software or Deliverables, as applicable, as expressly agreed in writing between the Parties; - \u201c Support Fees \u201d means the fees for the Support Services in respect of the Software. Support Fees payable in respect of the \u2018Basic Support\u2019 Support Services are included in the License Fees. \u2018Gold Support\u2019 Support Services shall be charged at an additional fee, as per the terms of the relevant Order; - \u201c Support Services \u201d means \u2018Basic Support\u2019 or \u2018Gold Support\u2019, as specified in Section 4 of this Agreement; - \u201c Working Day \u201d means any day except Saturday, Sunday or an official holiday in Guardsquare\u2019s or the Client\u2019s country of incorporation, as applicable. 1.2 In this Agreement (unless the context requires otherwise): a) Words importing the singular include the plural, words importing a particular gender include the other gender and words importing persons include bodies corporate and incorporate; and each case vice versa; b) The headings and captions contained in this Agreement are for convenience only and shall not affect the meaning, construction or interpretation of this Agreement or of any of its terms or provisions; c) Whenever the word \u201cinclude(s)\u201d or \u201cincluding\u201d is used in this Agreement, the enumeration that follows shall be deemed to be non-exhaustive. 1.3 In the event of a conflict between the terms of the Agreement and a Schedule, the latter shall prevail (unless expressly stipulated otherwise in the relevant Schedule). 2. License \u00b6 2.1 Subject to the terms and conditions of this Agreement and timely payment of the License Fees by the Client, Guardsquare hereby grants to the Client a personal, restricted, non-exclusive, non-transferable, non-assignable license, without the right to sublicense, for the term specified in the relevant Order, to use the Licensed Products in accordance with the Documentation, in Object Code form only, exclusively in combination with the licensed (number of) Applications and SDKs and in accordance with the License Parameters, for the Client\u2019s Internal Business Purposes. The license shall commence on the Delivery Date of the Licensed Products, and shall continue unless and until terminated in accordance with the terms of this Agreement and the relevant Order. 2.2 The extent of the license granted under Section 2.1 is restricted to the scope expressly set forth herein, and there are no implied licenses under this Agreement. Guardsquare reserves any right in or to the Licensed Products not expressly granted to the Client hereunder. The Client acknowledges and agrees that any use of the Licensed Products outside the scope of the license granted under Section 2.1., unless such use has been expressly approved in writing by a Guardsquare duly authorized representative, will entitle Guardsquare to immediately terminate (or alternatively, at Guardsquare\u2019s option, suspend) the license granted hereunder and/or the Agreement for material breach by Client, without any formalities being required and without prejudice to any other right or remedy available to Guardsquare pursuant to this Agreement or under applicable law. 2.3 The Client may not provide access to the Software or the Documentation to any third party other than its Employees who need such access in connection with the performance of their responsibilities to the Client, subject always to the license terms set forth in this Agreement, and who have committed in writing to confidentiality provisions at least as stringent as those set forth herein. Guardsquare shall provide the Client with one copy of the Documentation (in a format and through such means as reasonably determined by Guardsquare), which copy shall not be distributed to third parties and otherwise shall be subject to the restrictions contained in this Section 2. Additional copies of the Documentation can be made available at a charge, at the Client\u2019s reasonable request. 2.4 The Client agrees that it shall not itself, or through any affiliate, agent, (sub)contractor or other third party: (i) use the Software or Documentation other than for the Client\u2019s Internal Business Purposes and in connection with the Applications and SDKs; (ii) sell, lease, commercialize, rent, display, license, sublicense, transfer, provide, disclose, or otherwise make available to, or permit the use of or access to, the Software or the Documentation, in whole or in part, to any third party, whether or not related to the Client, except as expressly permitted in this Agreement; (iii) modify the Software or Documentation or develop any derivative works based on the Software, Documentation or any Confidential Information of Guardsquare; (iv) use the Software except as expressly authorized herein; (v) decompile, disassemble, reverse engineer or attempt to reconstruct, identify or discover any Source Code, underlying ideas, underlying user interface techniques or algorithms of the Software by any means whatsoever (except to the extent such restriction is prohibited under applicable law), or disclose any of the foregoing; (vi) encumber or suffer to exist any lien or security interest on the Licensed Products; (vii) take any action that would cause the Software, the Source Code or the Documentation to be placed in the public domain; (viii) use the Software in an environment not expressly permitted under this Agreement; (ix) remove or alter any copyright or other proprietary notice on any of the Licensed Products; or (x) make any Software functionality in any way visible or accessible, or otherwise disclose it, to any third party (including Client\u2019s end users), whether on a standalone basis or embedded in the Client\u2019s products (e.g. in Client\u2019s Applications or SDKs); the Client shall take all such (technical and organizational) (security) measures, including in respect of its own products (including the Applications and SDKs) as is necessary to protect the Software against such unauthorized access or other disclosure. Upon Guardsquare\u2019s request, the Client shall provide Guardsquare with such information, certifications and access to its systems as may reasonably be requested by Guardsquare to verify compliance with the license terms and restrictions on the use of the Licensed Products as set forth herein. 2.5 The Client acknowledges and agrees that any modification or attempted modification of the Licensed Products by any party other than Guardsquare will void Guardsquare\u2019s warranties with respect to the Licensed Products and will be deemed to represent a material breach of this Agreement by the Client. 2.6 The Client shall maintain up-to-date electronic records of the number of copies of the Licensed Products in its possession and/or under its control at any given point in time and their locations and, upon Guardsquare\u2019s first request, shall forthwith provide Guardsquare with such records. 2.7 The Client shall comply with all applicable laws relating to the use of the Licensed Products. The Client acknowledges and agrees that the Licensed Products may include encryption and may, accordingly, be subject to additional export or other restrictions which the Client agrees to comply with. 3.Delivery and acceptance \u00b6 3.1 Guardsquare shall deliver the Licensed Products and Deliverables to the Client on the Delivery Date. The Delivery Date shall be the Licensed Products and Deliverables (as applicable) Acceptance Date, on which the Licensed Products and Deliverables (as applicable) shall be deemed accepted by the Client for their use as permitted under this Agreement, and as of which the Software (and the software Deliverables to the extent expressly agreed to be in scope of the Support Services) shall be supported by Guardsquare as set out in Section 4 of this Agreement, subject to timely payment of the Support Fees (and Customisations Support Fees, as applicable). From the time of delivery, all risk relating to loss of or damage to the Licensed Products and Deliverables shall pass to the Client. 3.2 Upon Guardsquare\u2019s first request, the Client shall without undue delay provide Guardsquare with a duly signed Software and software Deliverable delivery acknowledgement and/or acceptance form, in a Guardsquare approved format. 4. Support Services \u00b6 4.1 Guardsquare shall provide the Client with the Support Services and/or General Support in accordance with this Section 4 and the relevant Order, provided the Client pays the applicable Support Fees (and Customisations Support Fees where applicable) and Fees for General Support as set forth in the relevant Order. The Support Services may consist of \u2018Basic Support\u2019 or \u2018Gold Support\u2019. Whether \u2018Basic Support\u2019 or \u2018Gold Support\u2019 applies shall be specified in the relevant Order. \u2018 Basic Support \u2019 consists of the following*: Software updates and basic support for installing the Software in build processes (with Gradle, Maven, Ant, Eclipse) and support for resolving Software issues, such as bugs. The Basic Support response time is 3 Working Days from receipt of a duly reported support request (as per the process set out below). Support is provided by email only. \u2018 Gold Support \u2019 consists of the following*: Basic Support, provided that the response time is 1 Working Day from receipt of a duly reported support request (as per the process set out below), and full, step by step project assistance for configuring and troubleshooting Software settings. Support may be provided by email or phone. In summary*: \u27a2 Basic Support : bug fixes, setup assistance, response within 3 business days, support by e-mail. \u27a2 Gold Support : bug fixes, setup assistance, project-specific support, configuration optimization, priority handling within 1 business day, support by e-mail and phone. *as may be updated by Guardsquare from time to time Support Services cover the current version of the Software (as per Guardsquare\u2019s software versioning scheme). Bug fixing covered by the Support Services only covers defects attributable to the Software or to Guardsquare. Any onsite support is not in scope of the Support Services and, if requested by the Client, shall be additionally charged to the Client as General Support. The Client acknowledges and agrees that Guardsquare does not wish to receive any personal or other sensitive data (whether related to the Client, the Client\u2019s customers or otherwise) in providing the Support Services or General Support (unless expressly otherwise requested by Guardsquare for the purposes of fulfilling its obligations hereunder), and the Client undertakes to sanitise (including through anonymisation) any (personal) data submitted to Guardsquare for the purposes of the Support Services or General Support. If the Client fails to meet this obligation (save where Guardsquare expressly requested to receive such data), Guardsquare cannot be held to be in breach of any data protection, information security or confidentiality obligations under the Agreement by processing such data in performing the Support Services or General Support and cannot incur any liability, liquidated damages or penalties in this respect. 4.2 Support process: The Client shall appoint one or more representatives that are authorised to request Support Services and General Support. The Client may replace its authorized representatives from time to time by prior written notice to Guardsquare (including by email to the designated email address). Whenever the Client requires Guardsquare to perform either Support Services or General Support pursuant to this Section 4, the Client shall submit a request by means of its authorised representatives. The service desk may be contacted directly by email in case of Basic Support, and by email or telephone if Gold Support. Guardsquare shall provide contact details for the service desk to the Client and shall inform the Client of any changes to those contact details. When reporting issues to the service desk, the Client will provide the necessary diagnostic information to enable Guardsquare to reproduce any reported defect and adequately address the Client support request. The service desk contact details are as follows (as may be updated from time to time by Guardsquare): \u27a2 Email: support@Guardsquare.com \u27a2 Telephone Guardsquare: +32 16 920 646 \u27a2 Download site: https://www.Guardsquare.com 5. Intellectual Property Rights \u00b6 5.1 Licensed Products. The Software (in Object Code and Source Code form) and Documentation, and all copies thereof, including any rights, title and interest (including any Intellectual Property Rights) therein, shall at all times remain the sole and exclusive property of Guardsquare and/or its licensors, and the Client shall not obtain any rights, title or interest (including any Intellectual Property Rights) therein except for the restricted user rights expressly granted hereunder. The Client hereby acknowledges that Guardsquare and its licensors shall retain all right, title and interest (including any Intellectual Property Rights) to any derivative works (in Object Code and Source Code form) of the Software and Documentation (including to any customization, enhancement, modification, improvement, update, upgrade or new release of the Software and the Documentation). In the event that, notwithstanding any prohibition thereto, the Client (or any third party acting on its behalf or under its control) modifies or creates derivative works from the Software or Documentation (collectively \u201cImprovements\u201d), Guardsquare shall automatically and irrevocably own all right, title and interest, including any Intellectual Property Rights, in and to such Improvements and the Client hereby assigns any rights (including Intellectual Property Rights) in such Improvements to Guardsquare and agrees to secure any additional confirmations, assignments and other instruments and documents as may be necessary to vest title to any such Improvements in Guardsquare as contemplated by this Section 5.1. No amount shall be payable by Guardsquare to the Client for the assignment of such rights in the Improvements as set forth herein. 5.2 Deliverables. Guardsquare shall own all rights, title and interest, including any Intellectual Property Rights, in Deliverables developed by Guardsquare pursuant to the Agreement, and subject to timely payment of the corresponding Professional Services Fees, Guardsquare shall grant the Client the right to use such Deliverables on terms identical to those contained in Section 2 of the Agreement. Subject to Guardsquare\u2019s obligation of confidentiality as set forth in the Agreement, nothing in the Agreement, its Schedules or an Order shall prevent Guardsquare from acquiring, developing, marketing, using for itself or providing to third parties deliverables that are similar or identical to the Deliverables. Notwithstanding anything to the contrary in this Agreement, its Schedules or an Order, (i) Guardsquare shall be free to use the ideas, concepts, methodologies, processes and know-how developed or learned by Guardsquare in the course of performing the Professional Services, and (ii) Guardsquare shall in any event retain all rights, title and interest (including any Intellectual Property Rights) in its Pre-existing Intellectual Property and derivative works thereof. For the purposes of this clause 5.2, Guardsquare\u2019s Pre-existing Intellectual Property includes the proprietary tools, methodologies, materials, know-how, processes, technologies, modules, components, programs, analyses, and frameworks developed or used by Guardsquare prior to the Effective Date or developed independently from this Agreement. 5.3 The Client agrees not to remove, obscure or modify in any way any Guardsquare proprietary marking, including any trademark or copyright notice, on or in the Licensed Products and Deliverables or on any Licensed Product or Deliverables media. The Client shall reproduce and incorporate such proprietary markings in any Licensed Product and Deliverable back-up and other copies. 5.4 All rights, title and interest, including any Intellectual Property Rights, in any databases created by Guardsquare in connection with the data collected hereunder shall, as between the Parties, at all times remain the sole and exclusive property of Guardsquare, and the Client shall not obtain any rights, title or interest (including any Intellectual Property Rights) therein. Data collected hereunder shall however remain owned by their respective owners. 5.5 The Client agrees to promptly notify Guardsquare if the Client becomes aware that any third party is violating or infringing Guardsquare\u2019s rights of whatever nature in any of the Licensed Products or Deliverables. Guardsquare shall have the right (at its discretion), to prosecute such violator or infringer at its expense and to retain the full amount of any sums recovered as damages. The Client agrees to provide, at Guardsquare\u2019s request and expense, all necessary cooperation to Guardsquare in the event of the commencement of any such proceedings by Guardsquare. 5.6 The Client acknowledges and agrees that in order to use the Software and/or the Deliverables, the Client may need to obtain, at the Client\u2019s expense, the right to use any third party software as communicated by Guardsquare from time to time. 6. Confidentiality \u00b6 6.1 Each of the Parties agrees that it shall, both during the term of this Agreement and following termination or expiration of this Agreement (i) not disclose any Confidential Information of the other Party, except to those of its Employees, officers, directors, contractors and affiliates that have a demonstrable legitimate need to know such information in light of the Parties\u2019 rights and obligations hereunder, subject to each of them committing in writing to confidentiality obligations at least as stringent as those set forth herein prior to being granted access to such Confidential Information and subject to any other conditions and restrictions set out in this Agreement, and (ii) use any Confidential Information of the other Party only for the purpose of the performance of the Agreement, excluding any use for its own benefit or that of any third party, except as expressly permitted under this Agreement. 6.2 Each of the Parties shall ensure that each person to whom it provides/who otherwise receives (directly or indirectly) Confidential Information pursuant to this Agreement is made aware of and complies with the confidentiality obligations under this Agreement as if they were a party to this Agreement. Each of the Parties shall be responsible and liable towards the other Party for a breach of these confidentiality obligations by any party acting under their control or on their behalf or to whom they otherwise provided Confidential Information. 6.3 The confidentiality obligations set forth herein shall not apply in respect of information which: (i) is in the public domain at the time of disclosure or subsequently falls into the public domain through no breach of this Section 6 by the receiving Party, provided that the Client acknowledges and agrees that Confidential Information of Guardsquare shall not be deemed to be in the public domain merely because any part of said information is embodied in general disclosures or because individual features, components, or combinations thereof are now, or become, known to the public, through whatever means, including through means of the supply or commercialization of products or services based on or related to such Confidential Information; (ii) was rightfully in the receiving Party\u2019s possession, without any confidentiality restrictions attached to it, prior to receipt of such information from the disclosing Party hereunder; (iii) is rightfully and lawfully obtained from a third party which is not under an obligation of confidentiality with respect to such information; (iv) was independently developed by the receiving Party, without access or reference to, or use of, the disclosing Party\u2019s Confidential Information; each as can be demonstrated and substantiated by the receiving Party in reasonable detail. 6.4 The Parties\u2019 confidentiality obligations as set forth herein shall survive termination of the Agreement. Upon termination of the Agreement or a disclosing Party\u2019s earlier written request, the receiving Party shall promptly return to the disclosing Party or destroy (at the disclosing Party\u2019s option) all Confidential Information of the disclosing Party in its possession or under its control. 7. Fees \u00b6 7.1 As consideration for the Software licenses granted pursuant to an Order and for the Support Services/General Support and Professional Services, the Client agrees to pay to Guardsquare the Fees, in accordance with the invoicing schedule set forth in the relevant Order or other written agreement between the Parties. Expenses (including travel (incl. local transport and flights), accommodation and out-of-pocket expenses) incurred by Guardsquare in furtherance of this Agreement shall be charged to the Client at Guardsquare\u2019s cost, in addition to the Fees. Where reasonably possible, such expenses shall be subject to the Client\u2019s prior consent (such consent not to be unreasonably delayed or withheld) and shall be evidenced by receipts. 7.2 Undisputed invoices are due and payable by the Client within thirty (30) days from the invoice date. All payments made by the Client to Guardsquare under this Agreement shall be final and non refundable. The amount of any invoice which has not been paid within thirty (30) days from the invoice date shall automatically be subject to a late payment interest equal to 1.5% per month, which interest shall be compounded daily as of the due date until receipt of full payment by Guardsquare. In addition, the Client shall pay all costs incurred by Guardsquare as a result of the (extra)judicial enforcement of the Client\u2019s payment obligations hereunder. If the Client fails to pay any outstanding amounts by the due date, Guardsquare may also suspend its obligations and the Client\u2019s (user) rights hereunder until receipt of payment of such outstanding amounts. 7.3 All Fees payable to Guardsquare under this Agreement shall be paid without the right to set off or counterclaim. 7.4 If the Client disputes any portion of an invoice, the Client shall notify Guardsquare without undue delay and in any event within the payment term of the nature of any such dispute, the basis for the Client\u2019s dispute and the amount involved, together with any appropriate information supporting Client\u2019s position, failure of which shall result in the invoice being deemed accepted by the Client. The undisputed portion of the invoice shall be paid as set forth herein. 7.5 Sums stated to be payable under this Agreement do not include any applicable taxes, which shall be additionally charged to and paid by the Client. All fees payable to Guardsquare under this Agreement shall be paid free and clear of all deductions and withholdings whatsoever unless the same are required by law, in which case the Client undertakes to pay Guardsquare such additional amounts as is necessary in order that the net amounts received by Guardsquare after all deductions and withholdings shall not be less than such payments would have been in the absence of such deductions or withholding. 7.6 Guardsquare may annually (starting 1 January following the Effective Date) increase the Professional Services Fees (including any agreed rate card), the License Fees and the (Customisations) Support Fees (as well as any other recurring Fee component as may exist from time to time) on the basis of the Belgian consumer price index, without any formalities being required. 7.7 The Client shall keep accurate business records of its use of the Licensed Products for as long as it is entitled to use the Licensed Products as per the terms of this Agreement. Such business records must include details of the License Parameters. The Client shall retain those records for at least three years (3) after any termination of its right to use the relevant Licensed Products. Guardsquare and/or its agents may inspect and review such business records, the Client\u2019s premises and any other information relevant to verify the Client\u2019s compliance with this Agreement upon reasonable notice (except where such notice would defeat the purpose of the audit), during normal business hours during the term of the Client\u2019s user rights hereunder and for a period of three (3) years thereafter, provided that such inspection right may not be exercised more than twice during any calendar year period, except where Guardsquare has reasonable grounds to believe the Client is acting in breach of this Agreement. If such inspection shows that the Client has underpaid the amount of Fees due to Guardsquare (without limitation, as a result of the Client using the Software in excess of the licensed License Parameters), without prejudice to any other rights and remedies available to Guardsquare hereunder, the Client shall promptly pay the amount of any such underpayment to Guardsquare together with any applicable late payment interest (as per clause 7.2 hereof). The Client and Guardsquare shall each bear their own cost related to any such review and inspection, provided that in the event of an underpayment by the Client or any other contractual breach as determined by such review and inspection, all costs related to such review and inspection shall be borne by the Client, without prejudice to any other rights and remedies available to Guardsquare hereunder. 8. Warranties \u00b6 8.1 Guardsquare warrants to the Client as follows: (a) Guardsquare is a corporation duly organized and validly existing under the laws of its incorporation and has all requisite power and authority to execute and deliver this Agreement and to perform its obligations hereunder. The execution, delivery and performance of this Agreement have been duly authorized by all requisite action on the part of Guardsquare and this Agreement constitutes the legal, valid and binding obligation on Guardsquare, enforceable in accordance with its terms. (b) Guardsquare shall perform the Agreement in a professional manner, using reasonable skill and care. (c) Except as expressly set forth in this Section 8, the Licensed Products, Deliverables, Professional Services and Support Services/General Support are provided \u201cas is.\u201d The express warranties set forth in this section 8 are the only warranties made by Guardsquare with respect to this Agreement. Guardsquare makes no other warranties, express or implied, including warranties of merchantability and fitness for a particular purpose. The Client shall have the sole responsibility to adequately protect and backup its data and equipment used in connection with the Software. 8.2 The Client warrants to Guardsquare as follows: (a) the Client is duly organized, validly existing and in good standing under the laws of its incorporation and has all requisite power and authority to execute and deliver this Agreement and to perform its obligations hereunder, and the execution, delivery and performance of this Agreement have been duly authorized by all requisite action on the part of the Client and this Agreement constitutes the legal, valid and binding obligation of the Client, enforceable in accordance with its terms. (b) the information provided by the Client for Guardsquare to be able to determine the License Parameters (without limitation, the (number of) Applications and SDKs, number of Client end users and developers, (number of) App Package names) and thus also the License Fees, is correct. (c) the Applications and SDKs will be published by the Client. If at any time during this Agreement, the Client notices or suspects that wrong assumptions have been made or any of these warranties prove incorrect, it shall promptly notify Guardsquare thereof in writing. 9. Indemnification \u00b6 9.1 Guardsquare shall defend and indemnify the Client as specified herein against any claims brought by third parties to the extent such claim is based on an infringement of the Intellectual Property Rights of such third party by the Licensed Products and excluding any claims resulting from (i) the unauthorized use of the Licensed Products, (ii) the modification of any of the Licensed Products other than by Guardsquare, (iii) failure to use the most recent version of the Licensed Products made available to the Client, or failure to integrate or install any corrections to such Licensed Products issued by Guardsquare, if Guardsquare indicated that such update or correction was required to prevent a(n) (potential) infringement, (iv) use of the Licensed Products in combination with any non-Guardsquare products or services, or (v) the Software having been developed to the Client\u2019s design or incorporating documents, materials, ideas, data or other information, provided by or on behalf of the Client. Such indemnity obligation shall be conditional upon the following: (i) Guardsquare is given prompt written notice of any such claim; (ii) Guardsquare is granted sole control of the defense and settlement of such a claim; (iii) upon Guardsquare\u2019s request, the Client fully cooperates with Guardsquare in the defense and settlement of such a claim, at Guardsquare\u2019s expense; and (iv) the Client makes no admission as to Guardsquare\u2019s liability in respect of such a claim, nor does the Client agree to any settlement in respect of such a claim without Guardsquare\u2019s prior written consent. Provided these conditions are met, Guardsquare shall indemnify the Client for the damages and costs incurred by the Client as a result of such a claim, as awarded by a competent court of final instance or as agreed to by Guardsquare pursuant to a settlement agreement. 9.2 In the event the Licensed Products, in Guardsquare\u2019s reasonable opinion, are likely to become or become the subject of a third-party infringement claim (as per clause 9.1), Guardsquare shall have the right, at its sole option and expense, to: (i) modify the ((allegedly) infringing part of the Licensed Products so that they become non-infringing while preserving equivalent functionality; (ii) obtain for the Client a license to continue using the Licensed Products in accordance with this Agreement; or (iii) terminate the relevant license and pay to the Client an amount equal to a pro rata portion of the License Fee paid to Guardsquare hereunder for that portion of the Licensed Products which is the subject of such infringement, such portion equaling any pre-paid Fees covering the period after actual termination. 9.3 The foregoing states the entire liability and obligation of Guardsquare and the sole remedy of the Client with respect to any infringement or alleged infringement of any Intellectual Property Rights caused by the Licensed Products or any part thereof. 10. Limitations on Liability \u00b6 10.1 To the maximum extent permitted by applicable law, Guardsquare excludes its liability (whether in contract, warranty, tort (including as a result of negligence, product liability or other theory) or otherwise) to the Client or any other person for recovery or recoupment of any investment made by the Client, its affiliates or any third parties acting on their behalf or under their control, in connection with this Agreement, and for any indirect, punitive, special or consequential damages, or damages for loss of profit, revenue, business, contracts or clients, loss or corruption of data, loss of goodwill, reputational harm, opportunity loss, loss of anticipated savings, and the cost of procuring replacement goods or services, arising out of or relating to this Agreement, even if Guardsquare has been advised of the possibility of such costs or damages arising. 10.2 Without prejudice to and without limiting Section 10.1 of this Agreement, to the maximum extent permitted under applicable law, Guardsquare\u2019s liability arising out of or in connection: a) with this Agreement (other than as covered under (b), (c) and (d) below), whether in contract, warranty, tort (including negligence, product liability or other theory), or otherwise, shall not exceed the total License Fees (excl. taxes) paid to Guardsquare by the Client under this Agreement during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not exceed the total License Fees (excl. taxes) paid under the Agreement; b) with the Support Services provided by Guardsquare to Client under this Agreement, whether in contract, warranty, tort (including negligence, product liability or other theory), or otherwise, shall not exceed fifty (50) percent of the total License Fees (excl. taxes and expenses) paid to Guardsquare by the Client under this Agreement during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not, per contract year, exceed the total License Fees (excl. taxes and expenses) paid under the Agreement in respect of the relevant contract year; c) with General Support provided by Guardsquare to Client under this Agreement, whether in contract, warranty, tort (including negligence, product liability or other theory), or otherwise, shall not exceed the Fees for General Support (excl. taxes and expenses) paid to Guardsquare by the Client under this Agreement in respect of the General Support to which the applicable liability claim relates during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not exceed the total Fees for General Support (excl. taxes and expenses) paid under the relevant Order in respect of such General Support; d) with the Professional Services provided by Guardsquare to the Client under the Agreement, whether in contract, warranty, tort (including negligence, product liability or other theory) or otherwise, shall not exceed the total Professional Services Fees (excl. taxes and expenses) paid by the Client to Guardsquare in respect of such Professional Services under the Order to which the liability claim relates during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not exceed the total Professional Services Fees (excl. taxes and expenses) paid under such Order. 10.3 The Client agrees that Guardsquare can only be held liable as per the terms of this Section 10 to the extent damages suffered by the Client are directly and solely attributable to Guardsquare. The exclusions and limitations of liability under this Section shall operate to the benefit of Guardsquare\u2019s affiliates and subcontractors under this Agreement to the same extent such provisions operate to the benefit of Guardsquare. 10.4 The Client\u2019s exclusive remedy for any claim arising out of or in connection with this Agreement shall be for Guardsquare, upon receipt of written notice, to use reasonable efforts to cure the breach or default at its expense, and failing that, Guardsquare\u2019s liability shall be limited as set forth in this Agreement. The Client shall have a duty to mitigate damages for which Guardsquare is responsible. 11. Term and Termination \u00b6 11.1 This Agreement shall commence on the Effective Date and shall continue for the term of the Order to which it relates. As a default (unless deviated from in the relevant Order), Orders (including any Software licenses and Support Services contracted pursuant to such an Order) are entered into for an initial one (1) year term (the \u201cInitial Term\u201d). Upon expiry of this Initial Term, the Orders shall automatically renew for successive one (1) year periods (each a \u201cRenewal Term\u201d), unless terminated by either Party on giving at least three (3) months\u2019 written notice prior to the expiry of the Initial Term or then current Renewal Term. Neither Party shall be entitled to terminate the Agreement or an Order in whole or in part for convenience save as expressly permitted herein. 11.2 Termination of the Agreement shall not automatically result in termination of any Orders, which must be separately terminated as set forth herein. Time and Material Professional Services (portions of) Orders may be terminated by the Client for convenience only if expressly so stipulated in the relevant Order, on giving such notice as specified in such Order. Fixed price Professional Services (portions of) Orders may not be terminated for convenience, failure of which shall result in the full fixed price becoming payable by the Client upon termination. 11.3 Either Party may terminate this Agreement, the Support Services (if the default relates to the Support Services) or the portion of the Order that is the subject of the default, by written notice to the other Party, if the other Party materially breaches this Agreement, the Support Services related provisions or a specific portion of such Order (as applicable) and fails to (i) cure such breach within thirty (30) days from the date of receipt of a default notice by the defaulting Party, and (ii) make substantial progress to cure such breach and implement a remedial plan that results in a cure of such breach within sixty (60) days from receipt of such default notice, provided that Guardsquare shall be entitled to terminate this Agreement (in whole or in part) (or alternatively suspend its obligations and/or the Client\u2019s user rights granted hereunder) on giving written notice in the event the Client breaches the license terms hereunder or infringes Guardsquare\u2019s Intellectual Property Rights. 11.4 Either Party may terminate this Agreement or an Order by written notice to the other Party, effective as of the date of delivery of such notice, if the other Party becomes the subject of a voluntary or involuntary bankruptcy, insolvency or similar proceeding or otherwise liquidates or ceases to do business. Consequences of termination. 11.5 Upon termination of an Order for whatever reason, the licenses granted to the Client pursuant to such Order in accordance with Section 2 of this Agreement shall automatically terminate and the Client shall return to Guardsquare all copies (in whatever form or medium) of the Licensed Products. 11.6 Upon termination for convenience by the Client of an Order or any of the Licensed Product licenses other than as expressly permitted in Section 11.1, the full License Fees for the Initial Term and then current Renewal Term (as applicable) shall remain payable by the Client. In the event the Client terminates an Order or the Support Services for convenience other than as expressly permitted in Section 11.1, the Support Fees shall remain payable by the Client for the full then current term (Initial Term or then current Renewal Term, as applicable). In the event the Client terminates the Agreement or an Order for convenience other than as expressly permitted in Section 11.2, the full Professional Services Fees and reimbursable expenses payable in respect of such Order shall remain payable by the Client. 11.7 In the event Guardsquare terminates the Agreement, Licensed Product licenses, Support Services or an Order pursuant to Sections 11.3 or 11.4, the Client\u2019s payment obligations shall be as per Section 11.6 above. 11.8 In the event the Client terminates the Agreement, Support Services or an Order pursuant to Sections 11.3 or 11.4, the Client must pay Guardsquare the Fees and reimbursable expenses payable in respect of any of the aforelisted up to the actual termination date. 11.9 The provisions of this Agreement that are expressly or implicitly intended to survive termination, including Sections 5, 6, 7, 8, 10, 11 (consequences of termination) and 12 (as applicable) of this Agreement, shall survive any expiration or termination of this Agreement. 12. Miscellaneous \u00b6 12.1 All notices hereunder shall be in writing, addressed to the receiving Party's address as set forth below or to such other address as a Party may designate by notice hereunder, and either (i) delivered by hand, (ii) sent by overnight courier, or (iii) sent by registered mail, return receipt requested, postage prepaid: If to Guardsquare to: Depending on the Order contracting entity: \u27a2 GuardSquare NV, Tervuursevest 362 bus 1, 3000 Leuven, Belgium; or \u27a2 GuardSquare Inc., 711 Atlantic Ave Floor 6, Boston, MA 02111, USA. Contact as per the relevant Order. If to the Client to: As per the relevant Order. All notices shall be deemed to have been given either (i) if by hand, at the time of actual delivery thereof to the receiving Party at such Party\u2019s address as provided above, as reasonably demonstrated by the Party serving notice, (ii) if sent by overnight courier, on the day such notice is delivered to the receiving Party at such Party\u2019s address as provided above, as reasonably demonstrated by the Party serving notice, or (iii) if sent by registered mail, three (3) days following the day such mailing is made. 12.2 The Client acknowledges that Guardsquare\u2019s performance of this Agreement is dependent on the Client\u2019s cooperation and the Client agrees to cooperate with Guardsquare to enable the latter to adequately perform its obligations under this Agreement. Such cooperation shall include (i) timely making available management decisions, information, approvals and acceptances; and (ii) at no cost to Guardsquare, providing timely and appropriate access to Client facilities, personnel, equipment, resources and systems, including its owned and licensed software, tools, data, databases and methodologies, and any relevant information and documentation (such information and documentation to be accurate and complete) as necessary to facilitate performance of the Agreement. 12.3 The Client agrees that it shall not, during the term of this Agreement and for a period of one year after the expiration or termination of this Agreement, without Guardsquare\u2019s prior written consent, directly or indirectly (including through its affiliates or recruitment agencies), hire or otherwise engage, in whatever capacity (including as an employee or consultant), or solicit the services of, any personnel member of Guardsquare or its affiliates, while such person is employed or engaged by Guardsquare or its affiliates and during six months after such employment or engagement ends. For the purpose of this section, \u201chire\u201d means to employ an individual as an employee or engage such individual as an independent contractor, whether on a full-time, part-time or temporary basis. The Client agrees that it shall not encourage third parties to act in a manner that would constitute a breach of this section, if such action had been performed by the Client. In case the above non-solicitation/non-hire obligations are not complied with and give rise to actual employment/engagement of Guardsquare\u2019s or its affiliates\u2019 personnel, the Client shall compensate Guardsquare by paying, upon a first request, a lump-sum amount corresponding to twelve times the gross salary/compensation each such person so hired/engaged earned with Guardsquare or its affiliates (as applicable) during the last full month such person worked for Guardsquare or its affiliates. 12.4 Any timeframe for performance specified in this Agreement or an Order shall be indicative target dates only, unless expressly stipulated to be binding milestones. 12.5 The terms and conditions of this Agreement may be modified or amended only by written agreement executed by a duly authorized representative of both Parties. The terms and conditions of this Agreement may be waived only by a written document signed by the Party entitled to the benefit of such terms or conditions. No such waiver or consent shall be deemed to be or shall constitute a waiver or consent with respect to any other terms or conditions of this Agreement, whether or not similar. Each such waiver or consent shall be effective only in the specific instance and for the purpose for which it was given, and shall not constitute a continuing waiver or consent. 12.6 The Client may not assign or transfer this Agreement (whether in whole or in part) to any third party (including without limitation its affiliates) without the prior written consent of Guardsquare. Guardsquare shall be free to transfer or assign the Agreement (whether in whole or in part). Guardsquare shall also be free to subcontract performance of this Agreement to its affiliates, to contractors and to third party service providers without having to obtain the Client\u2019s prior consent, provided that Guardsquare shall remain responsible towards the Client in respect of such subcontracted services. 12.7 In the event that any Party is prevented from performing or is unable to perform any of its non-monetary obligations under this Agreement due to any Act of God, fire, casualty, flood, earthquake, war, strike, lockout, epidemic, destruction of production facilities, riot, insurrection, material unavailability, or any other cause beyond the reasonable control of the Party invoking this section, such Party shall give prompt written notice to the other Party, its performance shall be excused, and the time for the performance shall be extended for the period of delay or inability to perform due to such occurrences (or such longer period as is reasonably required as reasonably demonstrated and substantiated by the affected Party). 12.8 The Client acknowledges that, in using the Software pursuant to the Agreement, the Software may collect and process (telemetry) data, which data allows Guardsquare to monitor the Client\u2019s use of the Software and which data may be used by Guardsquare for (among others) marketing, trend analysis, benchmarking purposes, or to further develop the Software. To the extent such consent is legally required, the Client hereby expressly consents to such data collection and processing. Such data may include (without being limitative) anonymized (namely without sensitive data regarding strings and classes related to Application source code being captured, however such data may still be linked to the Client\u2019s account) configuration data (providing (among others) information regarding the Software features used by the Client), and environmental data (including information regarding the build systems and program languages used by the Client). The actual types of data captured will be detailed in the Documentation (as it may change over time). The Client may at any time decide to disable these data capturing functionalities, by changing the Software configuration settings to this effect. In such event, no more data capturing as per the terms of this clause will take place once these functionalities have been disabled. The Client will also be able to configure the Software such that the Client obtains a copy of the telemetry data uploaded to Guardsquare, allowing the Client to keep visibility on the data so captured. As at the Effective Date, no personal data is envisaged to be collected or otherwise processed by Guardsquare pursuant to this clause 12.8 (\u201cprocess\u201d and \u201cpersonal data\u201d each as defined in the General Data Protection Regulation (Regulation (EU) 2016/679) (\u201cGDPR\u201d)). If and to the extent Guardsquare is considered \u2013 under applicable law \u2013 to process personal data in capturing and processing data pursuant to this clause, (i) the Client hereby consents to such data processing to the maximum extent permitted under applicable law and subject to the disabling option set out above, and (ii) Guardsquare shall be the data controller (as defined in the GDPR) in respect of such processing and shall comply with its obligations under applicable data protection laws in this respect. In the event such personal data processing were to take place: - Guardsquare shall inform (posting such information on a designated Guardsquare webpage accessible by the Client shall suffice for such purpose) the Client of the details of such processing as may be required under applicable law; - upon the Client\u2019s reasonable written request and no more than once per Agreement contract year (unless required under applicable law), Guardsquare shall make available to the Client such information as reasonably deemed necessary by Guardsquare to demonstrate its compliance with its personal data processing obligations hereunder (posting such information on a designated Guardsquare webpage accessible by the Client shall suffice for such purpose). To this end, Guardsquare may allow a reputable third-party auditor chosen by Guardsquare to perform audits on the Client\u2019s behalf (to the extent such audit right is available to the Client under applicable law) and the Client hereby authorizes Guardsquare to issue such mandate to the third-party auditor; - upon the Client\u2019s written request, Guardsquare shall destroy the personal data, subject to Guardsquare retaining any copies as may be required by applicable law. The Client acknowledges and agrees that Guardsquare may retain and use data collected hereunder for the purposes set out herein during the term of the Agreement as well as after its termination, subject always to any applicable legal limitations in this respect. 12.9 Guardsquare may freely use Feedback without attribution or the need for Guardsquare (or any third party) to pay the Client or any third party any royalties or other fees of any kind. 12.10 This Agreement and the rights and obligations of the Parties hereunder shall be governed by and construed in accordance with the laws of Guardsquare\u2019s country/state of incorporation without giving effect to the conflict of law principles thereof. The United Nations Convention for the International Sale of Goods shall not apply to this Agreement. In case of any dispute arising in respect of this Agreement, whether during or after its term, the Parties shall first attempt to amicably settle such dispute. Where no such amicable settlement can be reached within a reasonable period from the dispute having arisen, the dispute shall be submitted to the exclusive jurisdiction of the courts of the city/state of incorporation of Guardsquare. 12.11 If a court of competent jurisdiction determines any provision, or any portion thereof, of this Agreement to be unenforceable or invalid, then such provision shall be deemed limited to the extent that such court deems it valid or enforceable and the remaining provisions of this Agreement shall nevertheless remain in full force and effect. 12.12 The Parties hereto acknowledge and agree that they have participated jointly in the negotiation and drafting of this Agreement and that in the event an ambiguity or question of intent or interpretation arises, this Agreement shall be construed as if drafted jointly by the Parties and no presumption or burden of proof shall arise favoring or disfavoring any Party by virtue of the authorship of any of the provisions of this Agreement. 12.13 This Agreement does not constitute a partnership agreement nor does it create a joint venture or agency relationship between Guardsquare and the Client. Neither Party shall take any action or make any representation to any third party that would be inconsistent with the foregoing sentence. Neither Party shall be liable for the representations, acts, or omissions of the other Party unless expressly provided otherwise under the terms of this Agreement. 12.14 No failure or delay by a Party hereto in exercising any right, power or remedy under this Agreement, and no course of dealing between the Parties hereto, shall operate as a waiver of any such right, power or remedy of the Party. No single or partial exercise of any right, power or remedy under this Agreement by a Party hereto, nor any abandonment or discontinuance of steps to enforce any such right, power or remedy, shall preclude such Party from any other or further exercise thereof or the exercise of any other right, power or remedy hereunder. The election of any remedy by a Party hereto shall not constitute a waiver of the right of such Party to pursue other available remedies, save as expressly stipulated otherwise in the Agreement. 12.15 As of the Effective Date, Guardsquare shall be entitled to reference the Client as a Guardsquare Client, in accordance with the Client\u2019s reasonable instructions (e.g. as regards use of Client logo) notified to Guardsquare in this respect. 12.16 This Agreement (including its Schedules and Orders) constitutes the entire agreement and understanding between the Parties with respect to the subject matter hereof and supersedes all prior oral or written agreements, representations or understandings between the Parties relating to the subject matter hereof. All such Schedules, as the same may be amended from time to time in accordance with the terms of this Agreement, are incorporated herein by reference and made a part hereof. The terms of this Agreement shall be deemed included in the Orders by reference. No statement, representation, warranty, covenant or agreement of any kind not expressly set forth in this Agreement or an Order shall affect, or be used to interpret, change or restrict, the express terms and conditions of this Agreement or an Order. Additional or deviating terms and conditions (such as, for example, purchase orders or other documents of the Client or third parties) are hereby expressly refused and rejected, even if Guardsquare does not refuse or reject such terms and conditions on a case by case basis. Additional notices \u00b6 A DexGuard runtime library is distributed with the following libraries, to which the following license applies. Library Version License Bionic library N/A Android open source license Chromium Crazy Linker library N/A Android open source license Cordova 3.7 + 5.1 (2 versions) Apache License 2.0 crosswalk 18.48.477.13 BSD License (3-clause) LibTomMath WTFPL or The Unlicense Bouncy Castle 1.69 MIT license","title":"License"},{"location":"license.html#preamble","text":"Whereas Guardsquare has developed and owns certain software and is in the business of licensing such software and providing support, maintenance and other professional services in connection with such software; Whereas the Client wishes to obtain from Guardsquare the right to use such software and to be provided with support and other services in connection with such software; Whereas Guardsquare is willing to license such software to the Client and to provide the Client with maintenance and support services and other professional services in connection with such software as set forth in this Agreement. NOW THEREFORE, the Parties hereby agree as follows:","title":"PREAMBLE"},{"location":"license.html#1-definitions","text":"1.1 When used in this Agreement, the following terms shall have the meaning ascribed to them below: - \u201c Acceptance Date \u201d means the date on which the Licensed Products or Deliverables (as applicable) are agreed by the Client to conform to the relevant Specifications; - \u201c Applications \u201d means the (number of) applications as specified in an Order. An Application, published by the Client, may be used by several Client end users in which case the code, assets and libraries of the Application will be identical for each end user; - \u201c Confidential Information \u201d of a Party means the information of such Party, whether in written, oral, electronic or other form, which (i) is explicitly marked as confidential or proprietary, or (ii) should reasonably be considered confidential given its nature or the circumstances surrounding its disclosure, regardless of whether or not it is expressly marked as confidential, including (without being limitative) information and facts concerning a Party\u2019s and its affiliates\u2019 business plans, clients, prospects, personnel, suppliers, licensors, licensees, partners, investors, affiliates or others, training methods and materials, financial information, marketing plans, sales prospects, client lists, inventions, program devices, discoveries, ideas, concepts, know-how, techniques, formulas, blueprints, software (in object and source code form), documentation, designs, prototypes, methods, processes, procedures, codes, and any technical or trade secrets, including all copies of any of the foregoing and any analyses, studies or reports that contain, are based on, or reflect any of the foregoing. The Confidential Information of Guardsquare shall include, without being limitative, the Software and the Documentation; - \u201c Customisations Support Fee \u201d means the fees for the Support Services in respect of software Deliverables to the extent expressly agreed (in an Order) to be included under the Support Services; - \u201c Deliverable \u201d means a deliverable to be provided by Guardsquare pursuant to, and designated as such in, an Order; - \u201c Delivery Date \u201d means the agreed date on which the Licensed Products are made available to the Client by Guardsquare (which may include making available for download from a secure FTP site); - \u201c Documentation \u201d means the operating manual, including a description of the functions performed by the Software, user instructions, and all other related materials (excluding marketing material and any information posted on a (Guardsquare) website), as ordinarily supplied by Guardsquare to its customers to facilitate the use of the Software; - \u201c Employee \u201d means an individual who is hired pursuant to an employment contract in exchange for a wage. Agents, distributors, advisors, consultants, freelancers, (self-employed) (sub)contractors or any other third party shall not be considered Employees for the purposes of this Agreement; - \u201c Feedback \u201d means any suggestions or recommendations for improvement or modifications to the Software made by or on behalf of the Client; - \u201c Fees \u201d means the License Fees, Professional Services Fees, Support Fees, and fees in respect of General Support, and any other amounts payable by the Client to Guardsquare pursuant to this Agreement, as set out in an Order or as otherwise agreed in writing between duly authorized representatives of the Parties; - \u201c General Support \u201d means any support and maintenance services requested by the Client that are not in scope of the Support Services contracted by the Client (namely Basic Support or Gold Support, as specified in the relevant Order); - \u201c Intellectual Property Rights \u201d means patents, trade marks, service marks, trade secrets, copyrights, design rights, know how, Confidential Information, trade and business names, domain names, database rights, sui generis rights (including in software), rental rights and any other intellectual or industrial property or similar right throughout the world (whether registered or unregistered), including applications for registration, renewals, extensions, continuations, divisions, reissues or improvements relating to any of these rights and the right to apply for, maintain and enforce any of the preceding items; - \u201c Internal Business Purposes \u201d means use of the Software for the purpose for which it is licensed (as per the terms of the Documentation, Specifications and the license terms set out in this Agreement) with respect to the licensed (number of) Applications and SDKs only, excluding (without being limitative) sublicensing, reselling, redistribution, or otherwise commercializing or making the Software available to third parties (whether or not at a charge), and use of the Software with respect to applications or libraries other than the Applications and SDKs or with respect to Applications or SDKs that are not published by the Client; - \u201c License Fees \u201d means the annually recurring fees payable by the Client in respect of the user rights in respect of the Licensed Products granted hereunder, which License Fees also include \u2018Basic Support\u2019 Support Services; - \u201c License Parameters \u201d means the parameters defining and restricting the scope of the Software user rights granted pursuant to Section 2 of this Agreement, as specified in an Order and/or invoices issued by Guardsquare. License Parameters may include (non-exhaustive list) the (number of) Applications and SDKs, App Package names, Application names, SDK/library names, territorial restrictions, industry sector restrictions, number of Client end users and developers; - \u201c Licensed Products \u201d means the Software and the Documentation; - \u201c Object Code \u201d (or Bytecode) means software assembled or compiled in magnetic or electronic binary form on software media that is readable and usable by machines but not generally readable by humans without reverse assembly, reverse compiling or reverse engineering; - \u201c Order \u201d means an order entered into between the Parties pursuant to this Agreement, for the purchasing of Software licenses by the Client and the delivery of Support Services and/or Professional Services by Guardsquare to the Client; - \u201c App Package Name \u201d means the unique identifier of an Application (e.g. as per the app/build.gradle file), which is also unique in the Google Play store; - \u201c Professional Services \u201d means Software development, implementation and integration services, training, reviewing and testing services, or such other services in relation to the Software as may be agreed between the Parties from time to time, in an Order (but excluding Support Services); - \u201c Professional Services Fees \u201d means the Fees payable by the Client in respect of the Professional Services and Deliverables, as set out in the relevant Order; - \u201c Schedule \u201d means a schedule to this Agreement, if any; - \u201c SDK \u201d means the (number of) libraries as specified in an Order. An SDK, published by the Client, may be used by several Client end users in which case the code, assets and libraries of the SDK will be identical for each end user; - \u201c Software \u201d means the software listed in an Order, licensed to the Client by Guardsquare in accordance with the terms of this Agreement; - \u201c Source Code \u201d means the Software written in programming languages including all comments and procedural code such as job control language statements, in a form intelligible to programmers trained in and knowledgeable of the Software, and capable of being translated into the Object Code form of the Software for operation on computer equipment through assembly or compiling; - \u201c Specifications \u201d means the specifications for the Software or Deliverables, as applicable, as expressly agreed in writing between the Parties; - \u201c Support Fees \u201d means the fees for the Support Services in respect of the Software. Support Fees payable in respect of the \u2018Basic Support\u2019 Support Services are included in the License Fees. \u2018Gold Support\u2019 Support Services shall be charged at an additional fee, as per the terms of the relevant Order; - \u201c Support Services \u201d means \u2018Basic Support\u2019 or \u2018Gold Support\u2019, as specified in Section 4 of this Agreement; - \u201c Working Day \u201d means any day except Saturday, Sunday or an official holiday in Guardsquare\u2019s or the Client\u2019s country of incorporation, as applicable. 1.2 In this Agreement (unless the context requires otherwise): a) Words importing the singular include the plural, words importing a particular gender include the other gender and words importing persons include bodies corporate and incorporate; and each case vice versa; b) The headings and captions contained in this Agreement are for convenience only and shall not affect the meaning, construction or interpretation of this Agreement or of any of its terms or provisions; c) Whenever the word \u201cinclude(s)\u201d or \u201cincluding\u201d is used in this Agreement, the enumeration that follows shall be deemed to be non-exhaustive. 1.3 In the event of a conflict between the terms of the Agreement and a Schedule, the latter shall prevail (unless expressly stipulated otherwise in the relevant Schedule).","title":"1. Definitions"},{"location":"license.html#2-license","text":"2.1 Subject to the terms and conditions of this Agreement and timely payment of the License Fees by the Client, Guardsquare hereby grants to the Client a personal, restricted, non-exclusive, non-transferable, non-assignable license, without the right to sublicense, for the term specified in the relevant Order, to use the Licensed Products in accordance with the Documentation, in Object Code form only, exclusively in combination with the licensed (number of) Applications and SDKs and in accordance with the License Parameters, for the Client\u2019s Internal Business Purposes. The license shall commence on the Delivery Date of the Licensed Products, and shall continue unless and until terminated in accordance with the terms of this Agreement and the relevant Order. 2.2 The extent of the license granted under Section 2.1 is restricted to the scope expressly set forth herein, and there are no implied licenses under this Agreement. Guardsquare reserves any right in or to the Licensed Products not expressly granted to the Client hereunder. The Client acknowledges and agrees that any use of the Licensed Products outside the scope of the license granted under Section 2.1., unless such use has been expressly approved in writing by a Guardsquare duly authorized representative, will entitle Guardsquare to immediately terminate (or alternatively, at Guardsquare\u2019s option, suspend) the license granted hereunder and/or the Agreement for material breach by Client, without any formalities being required and without prejudice to any other right or remedy available to Guardsquare pursuant to this Agreement or under applicable law. 2.3 The Client may not provide access to the Software or the Documentation to any third party other than its Employees who need such access in connection with the performance of their responsibilities to the Client, subject always to the license terms set forth in this Agreement, and who have committed in writing to confidentiality provisions at least as stringent as those set forth herein. Guardsquare shall provide the Client with one copy of the Documentation (in a format and through such means as reasonably determined by Guardsquare), which copy shall not be distributed to third parties and otherwise shall be subject to the restrictions contained in this Section 2. Additional copies of the Documentation can be made available at a charge, at the Client\u2019s reasonable request. 2.4 The Client agrees that it shall not itself, or through any affiliate, agent, (sub)contractor or other third party: (i) use the Software or Documentation other than for the Client\u2019s Internal Business Purposes and in connection with the Applications and SDKs; (ii) sell, lease, commercialize, rent, display, license, sublicense, transfer, provide, disclose, or otherwise make available to, or permit the use of or access to, the Software or the Documentation, in whole or in part, to any third party, whether or not related to the Client, except as expressly permitted in this Agreement; (iii) modify the Software or Documentation or develop any derivative works based on the Software, Documentation or any Confidential Information of Guardsquare; (iv) use the Software except as expressly authorized herein; (v) decompile, disassemble, reverse engineer or attempt to reconstruct, identify or discover any Source Code, underlying ideas, underlying user interface techniques or algorithms of the Software by any means whatsoever (except to the extent such restriction is prohibited under applicable law), or disclose any of the foregoing; (vi) encumber or suffer to exist any lien or security interest on the Licensed Products; (vii) take any action that would cause the Software, the Source Code or the Documentation to be placed in the public domain; (viii) use the Software in an environment not expressly permitted under this Agreement; (ix) remove or alter any copyright or other proprietary notice on any of the Licensed Products; or (x) make any Software functionality in any way visible or accessible, or otherwise disclose it, to any third party (including Client\u2019s end users), whether on a standalone basis or embedded in the Client\u2019s products (e.g. in Client\u2019s Applications or SDKs); the Client shall take all such (technical and organizational) (security) measures, including in respect of its own products (including the Applications and SDKs) as is necessary to protect the Software against such unauthorized access or other disclosure. Upon Guardsquare\u2019s request, the Client shall provide Guardsquare with such information, certifications and access to its systems as may reasonably be requested by Guardsquare to verify compliance with the license terms and restrictions on the use of the Licensed Products as set forth herein. 2.5 The Client acknowledges and agrees that any modification or attempted modification of the Licensed Products by any party other than Guardsquare will void Guardsquare\u2019s warranties with respect to the Licensed Products and will be deemed to represent a material breach of this Agreement by the Client. 2.6 The Client shall maintain up-to-date electronic records of the number of copies of the Licensed Products in its possession and/or under its control at any given point in time and their locations and, upon Guardsquare\u2019s first request, shall forthwith provide Guardsquare with such records. 2.7 The Client shall comply with all applicable laws relating to the use of the Licensed Products. The Client acknowledges and agrees that the Licensed Products may include encryption and may, accordingly, be subject to additional export or other restrictions which the Client agrees to comply with.","title":"2. License"},{"location":"license.html#3delivery-and-acceptance","text":"3.1 Guardsquare shall deliver the Licensed Products and Deliverables to the Client on the Delivery Date. The Delivery Date shall be the Licensed Products and Deliverables (as applicable) Acceptance Date, on which the Licensed Products and Deliverables (as applicable) shall be deemed accepted by the Client for their use as permitted under this Agreement, and as of which the Software (and the software Deliverables to the extent expressly agreed to be in scope of the Support Services) shall be supported by Guardsquare as set out in Section 4 of this Agreement, subject to timely payment of the Support Fees (and Customisations Support Fees, as applicable). From the time of delivery, all risk relating to loss of or damage to the Licensed Products and Deliverables shall pass to the Client. 3.2 Upon Guardsquare\u2019s first request, the Client shall without undue delay provide Guardsquare with a duly signed Software and software Deliverable delivery acknowledgement and/or acceptance form, in a Guardsquare approved format.","title":"3.Delivery and acceptance"},{"location":"license.html#4-support-services","text":"4.1 Guardsquare shall provide the Client with the Support Services and/or General Support in accordance with this Section 4 and the relevant Order, provided the Client pays the applicable Support Fees (and Customisations Support Fees where applicable) and Fees for General Support as set forth in the relevant Order. The Support Services may consist of \u2018Basic Support\u2019 or \u2018Gold Support\u2019. Whether \u2018Basic Support\u2019 or \u2018Gold Support\u2019 applies shall be specified in the relevant Order. \u2018 Basic Support \u2019 consists of the following*: Software updates and basic support for installing the Software in build processes (with Gradle, Maven, Ant, Eclipse) and support for resolving Software issues, such as bugs. The Basic Support response time is 3 Working Days from receipt of a duly reported support request (as per the process set out below). Support is provided by email only. \u2018 Gold Support \u2019 consists of the following*: Basic Support, provided that the response time is 1 Working Day from receipt of a duly reported support request (as per the process set out below), and full, step by step project assistance for configuring and troubleshooting Software settings. Support may be provided by email or phone. In summary*: \u27a2 Basic Support : bug fixes, setup assistance, response within 3 business days, support by e-mail. \u27a2 Gold Support : bug fixes, setup assistance, project-specific support, configuration optimization, priority handling within 1 business day, support by e-mail and phone. *as may be updated by Guardsquare from time to time Support Services cover the current version of the Software (as per Guardsquare\u2019s software versioning scheme). Bug fixing covered by the Support Services only covers defects attributable to the Software or to Guardsquare. Any onsite support is not in scope of the Support Services and, if requested by the Client, shall be additionally charged to the Client as General Support. The Client acknowledges and agrees that Guardsquare does not wish to receive any personal or other sensitive data (whether related to the Client, the Client\u2019s customers or otherwise) in providing the Support Services or General Support (unless expressly otherwise requested by Guardsquare for the purposes of fulfilling its obligations hereunder), and the Client undertakes to sanitise (including through anonymisation) any (personal) data submitted to Guardsquare for the purposes of the Support Services or General Support. If the Client fails to meet this obligation (save where Guardsquare expressly requested to receive such data), Guardsquare cannot be held to be in breach of any data protection, information security or confidentiality obligations under the Agreement by processing such data in performing the Support Services or General Support and cannot incur any liability, liquidated damages or penalties in this respect. 4.2 Support process: The Client shall appoint one or more representatives that are authorised to request Support Services and General Support. The Client may replace its authorized representatives from time to time by prior written notice to Guardsquare (including by email to the designated email address). Whenever the Client requires Guardsquare to perform either Support Services or General Support pursuant to this Section 4, the Client shall submit a request by means of its authorised representatives. The service desk may be contacted directly by email in case of Basic Support, and by email or telephone if Gold Support. Guardsquare shall provide contact details for the service desk to the Client and shall inform the Client of any changes to those contact details. When reporting issues to the service desk, the Client will provide the necessary diagnostic information to enable Guardsquare to reproduce any reported defect and adequately address the Client support request. The service desk contact details are as follows (as may be updated from time to time by Guardsquare): \u27a2 Email: support@Guardsquare.com \u27a2 Telephone Guardsquare: +32 16 920 646 \u27a2 Download site: https://www.Guardsquare.com","title":"4. Support Services"},{"location":"license.html#5-intellectual-property-rights","text":"5.1 Licensed Products. The Software (in Object Code and Source Code form) and Documentation, and all copies thereof, including any rights, title and interest (including any Intellectual Property Rights) therein, shall at all times remain the sole and exclusive property of Guardsquare and/or its licensors, and the Client shall not obtain any rights, title or interest (including any Intellectual Property Rights) therein except for the restricted user rights expressly granted hereunder. The Client hereby acknowledges that Guardsquare and its licensors shall retain all right, title and interest (including any Intellectual Property Rights) to any derivative works (in Object Code and Source Code form) of the Software and Documentation (including to any customization, enhancement, modification, improvement, update, upgrade or new release of the Software and the Documentation). In the event that, notwithstanding any prohibition thereto, the Client (or any third party acting on its behalf or under its control) modifies or creates derivative works from the Software or Documentation (collectively \u201cImprovements\u201d), Guardsquare shall automatically and irrevocably own all right, title and interest, including any Intellectual Property Rights, in and to such Improvements and the Client hereby assigns any rights (including Intellectual Property Rights) in such Improvements to Guardsquare and agrees to secure any additional confirmations, assignments and other instruments and documents as may be necessary to vest title to any such Improvements in Guardsquare as contemplated by this Section 5.1. No amount shall be payable by Guardsquare to the Client for the assignment of such rights in the Improvements as set forth herein. 5.2 Deliverables. Guardsquare shall own all rights, title and interest, including any Intellectual Property Rights, in Deliverables developed by Guardsquare pursuant to the Agreement, and subject to timely payment of the corresponding Professional Services Fees, Guardsquare shall grant the Client the right to use such Deliverables on terms identical to those contained in Section 2 of the Agreement. Subject to Guardsquare\u2019s obligation of confidentiality as set forth in the Agreement, nothing in the Agreement, its Schedules or an Order shall prevent Guardsquare from acquiring, developing, marketing, using for itself or providing to third parties deliverables that are similar or identical to the Deliverables. Notwithstanding anything to the contrary in this Agreement, its Schedules or an Order, (i) Guardsquare shall be free to use the ideas, concepts, methodologies, processes and know-how developed or learned by Guardsquare in the course of performing the Professional Services, and (ii) Guardsquare shall in any event retain all rights, title and interest (including any Intellectual Property Rights) in its Pre-existing Intellectual Property and derivative works thereof. For the purposes of this clause 5.2, Guardsquare\u2019s Pre-existing Intellectual Property includes the proprietary tools, methodologies, materials, know-how, processes, technologies, modules, components, programs, analyses, and frameworks developed or used by Guardsquare prior to the Effective Date or developed independently from this Agreement. 5.3 The Client agrees not to remove, obscure or modify in any way any Guardsquare proprietary marking, including any trademark or copyright notice, on or in the Licensed Products and Deliverables or on any Licensed Product or Deliverables media. The Client shall reproduce and incorporate such proprietary markings in any Licensed Product and Deliverable back-up and other copies. 5.4 All rights, title and interest, including any Intellectual Property Rights, in any databases created by Guardsquare in connection with the data collected hereunder shall, as between the Parties, at all times remain the sole and exclusive property of Guardsquare, and the Client shall not obtain any rights, title or interest (including any Intellectual Property Rights) therein. Data collected hereunder shall however remain owned by their respective owners. 5.5 The Client agrees to promptly notify Guardsquare if the Client becomes aware that any third party is violating or infringing Guardsquare\u2019s rights of whatever nature in any of the Licensed Products or Deliverables. Guardsquare shall have the right (at its discretion), to prosecute such violator or infringer at its expense and to retain the full amount of any sums recovered as damages. The Client agrees to provide, at Guardsquare\u2019s request and expense, all necessary cooperation to Guardsquare in the event of the commencement of any such proceedings by Guardsquare. 5.6 The Client acknowledges and agrees that in order to use the Software and/or the Deliverables, the Client may need to obtain, at the Client\u2019s expense, the right to use any third party software as communicated by Guardsquare from time to time.","title":"5. Intellectual Property Rights"},{"location":"license.html#6-confidentiality","text":"6.1 Each of the Parties agrees that it shall, both during the term of this Agreement and following termination or expiration of this Agreement (i) not disclose any Confidential Information of the other Party, except to those of its Employees, officers, directors, contractors and affiliates that have a demonstrable legitimate need to know such information in light of the Parties\u2019 rights and obligations hereunder, subject to each of them committing in writing to confidentiality obligations at least as stringent as those set forth herein prior to being granted access to such Confidential Information and subject to any other conditions and restrictions set out in this Agreement, and (ii) use any Confidential Information of the other Party only for the purpose of the performance of the Agreement, excluding any use for its own benefit or that of any third party, except as expressly permitted under this Agreement. 6.2 Each of the Parties shall ensure that each person to whom it provides/who otherwise receives (directly or indirectly) Confidential Information pursuant to this Agreement is made aware of and complies with the confidentiality obligations under this Agreement as if they were a party to this Agreement. Each of the Parties shall be responsible and liable towards the other Party for a breach of these confidentiality obligations by any party acting under their control or on their behalf or to whom they otherwise provided Confidential Information. 6.3 The confidentiality obligations set forth herein shall not apply in respect of information which: (i) is in the public domain at the time of disclosure or subsequently falls into the public domain through no breach of this Section 6 by the receiving Party, provided that the Client acknowledges and agrees that Confidential Information of Guardsquare shall not be deemed to be in the public domain merely because any part of said information is embodied in general disclosures or because individual features, components, or combinations thereof are now, or become, known to the public, through whatever means, including through means of the supply or commercialization of products or services based on or related to such Confidential Information; (ii) was rightfully in the receiving Party\u2019s possession, without any confidentiality restrictions attached to it, prior to receipt of such information from the disclosing Party hereunder; (iii) is rightfully and lawfully obtained from a third party which is not under an obligation of confidentiality with respect to such information; (iv) was independently developed by the receiving Party, without access or reference to, or use of, the disclosing Party\u2019s Confidential Information; each as can be demonstrated and substantiated by the receiving Party in reasonable detail. 6.4 The Parties\u2019 confidentiality obligations as set forth herein shall survive termination of the Agreement. Upon termination of the Agreement or a disclosing Party\u2019s earlier written request, the receiving Party shall promptly return to the disclosing Party or destroy (at the disclosing Party\u2019s option) all Confidential Information of the disclosing Party in its possession or under its control.","title":"6. Confidentiality"},{"location":"license.html#7-fees","text":"7.1 As consideration for the Software licenses granted pursuant to an Order and for the Support Services/General Support and Professional Services, the Client agrees to pay to Guardsquare the Fees, in accordance with the invoicing schedule set forth in the relevant Order or other written agreement between the Parties. Expenses (including travel (incl. local transport and flights), accommodation and out-of-pocket expenses) incurred by Guardsquare in furtherance of this Agreement shall be charged to the Client at Guardsquare\u2019s cost, in addition to the Fees. Where reasonably possible, such expenses shall be subject to the Client\u2019s prior consent (such consent not to be unreasonably delayed or withheld) and shall be evidenced by receipts. 7.2 Undisputed invoices are due and payable by the Client within thirty (30) days from the invoice date. All payments made by the Client to Guardsquare under this Agreement shall be final and non refundable. The amount of any invoice which has not been paid within thirty (30) days from the invoice date shall automatically be subject to a late payment interest equal to 1.5% per month, which interest shall be compounded daily as of the due date until receipt of full payment by Guardsquare. In addition, the Client shall pay all costs incurred by Guardsquare as a result of the (extra)judicial enforcement of the Client\u2019s payment obligations hereunder. If the Client fails to pay any outstanding amounts by the due date, Guardsquare may also suspend its obligations and the Client\u2019s (user) rights hereunder until receipt of payment of such outstanding amounts. 7.3 All Fees payable to Guardsquare under this Agreement shall be paid without the right to set off or counterclaim. 7.4 If the Client disputes any portion of an invoice, the Client shall notify Guardsquare without undue delay and in any event within the payment term of the nature of any such dispute, the basis for the Client\u2019s dispute and the amount involved, together with any appropriate information supporting Client\u2019s position, failure of which shall result in the invoice being deemed accepted by the Client. The undisputed portion of the invoice shall be paid as set forth herein. 7.5 Sums stated to be payable under this Agreement do not include any applicable taxes, which shall be additionally charged to and paid by the Client. All fees payable to Guardsquare under this Agreement shall be paid free and clear of all deductions and withholdings whatsoever unless the same are required by law, in which case the Client undertakes to pay Guardsquare such additional amounts as is necessary in order that the net amounts received by Guardsquare after all deductions and withholdings shall not be less than such payments would have been in the absence of such deductions or withholding. 7.6 Guardsquare may annually (starting 1 January following the Effective Date) increase the Professional Services Fees (including any agreed rate card), the License Fees and the (Customisations) Support Fees (as well as any other recurring Fee component as may exist from time to time) on the basis of the Belgian consumer price index, without any formalities being required. 7.7 The Client shall keep accurate business records of its use of the Licensed Products for as long as it is entitled to use the Licensed Products as per the terms of this Agreement. Such business records must include details of the License Parameters. The Client shall retain those records for at least three years (3) after any termination of its right to use the relevant Licensed Products. Guardsquare and/or its agents may inspect and review such business records, the Client\u2019s premises and any other information relevant to verify the Client\u2019s compliance with this Agreement upon reasonable notice (except where such notice would defeat the purpose of the audit), during normal business hours during the term of the Client\u2019s user rights hereunder and for a period of three (3) years thereafter, provided that such inspection right may not be exercised more than twice during any calendar year period, except where Guardsquare has reasonable grounds to believe the Client is acting in breach of this Agreement. If such inspection shows that the Client has underpaid the amount of Fees due to Guardsquare (without limitation, as a result of the Client using the Software in excess of the licensed License Parameters), without prejudice to any other rights and remedies available to Guardsquare hereunder, the Client shall promptly pay the amount of any such underpayment to Guardsquare together with any applicable late payment interest (as per clause 7.2 hereof). The Client and Guardsquare shall each bear their own cost related to any such review and inspection, provided that in the event of an underpayment by the Client or any other contractual breach as determined by such review and inspection, all costs related to such review and inspection shall be borne by the Client, without prejudice to any other rights and remedies available to Guardsquare hereunder.","title":"7. Fees"},{"location":"license.html#8-warranties","text":"8.1 Guardsquare warrants to the Client as follows: (a) Guardsquare is a corporation duly organized and validly existing under the laws of its incorporation and has all requisite power and authority to execute and deliver this Agreement and to perform its obligations hereunder. The execution, delivery and performance of this Agreement have been duly authorized by all requisite action on the part of Guardsquare and this Agreement constitutes the legal, valid and binding obligation on Guardsquare, enforceable in accordance with its terms. (b) Guardsquare shall perform the Agreement in a professional manner, using reasonable skill and care. (c) Except as expressly set forth in this Section 8, the Licensed Products, Deliverables, Professional Services and Support Services/General Support are provided \u201cas is.\u201d The express warranties set forth in this section 8 are the only warranties made by Guardsquare with respect to this Agreement. Guardsquare makes no other warranties, express or implied, including warranties of merchantability and fitness for a particular purpose. The Client shall have the sole responsibility to adequately protect and backup its data and equipment used in connection with the Software. 8.2 The Client warrants to Guardsquare as follows: (a) the Client is duly organized, validly existing and in good standing under the laws of its incorporation and has all requisite power and authority to execute and deliver this Agreement and to perform its obligations hereunder, and the execution, delivery and performance of this Agreement have been duly authorized by all requisite action on the part of the Client and this Agreement constitutes the legal, valid and binding obligation of the Client, enforceable in accordance with its terms. (b) the information provided by the Client for Guardsquare to be able to determine the License Parameters (without limitation, the (number of) Applications and SDKs, number of Client end users and developers, (number of) App Package names) and thus also the License Fees, is correct. (c) the Applications and SDKs will be published by the Client. If at any time during this Agreement, the Client notices or suspects that wrong assumptions have been made or any of these warranties prove incorrect, it shall promptly notify Guardsquare thereof in writing.","title":"8. Warranties"},{"location":"license.html#9-indemnification","text":"9.1 Guardsquare shall defend and indemnify the Client as specified herein against any claims brought by third parties to the extent such claim is based on an infringement of the Intellectual Property Rights of such third party by the Licensed Products and excluding any claims resulting from (i) the unauthorized use of the Licensed Products, (ii) the modification of any of the Licensed Products other than by Guardsquare, (iii) failure to use the most recent version of the Licensed Products made available to the Client, or failure to integrate or install any corrections to such Licensed Products issued by Guardsquare, if Guardsquare indicated that such update or correction was required to prevent a(n) (potential) infringement, (iv) use of the Licensed Products in combination with any non-Guardsquare products or services, or (v) the Software having been developed to the Client\u2019s design or incorporating documents, materials, ideas, data or other information, provided by or on behalf of the Client. Such indemnity obligation shall be conditional upon the following: (i) Guardsquare is given prompt written notice of any such claim; (ii) Guardsquare is granted sole control of the defense and settlement of such a claim; (iii) upon Guardsquare\u2019s request, the Client fully cooperates with Guardsquare in the defense and settlement of such a claim, at Guardsquare\u2019s expense; and (iv) the Client makes no admission as to Guardsquare\u2019s liability in respect of such a claim, nor does the Client agree to any settlement in respect of such a claim without Guardsquare\u2019s prior written consent. Provided these conditions are met, Guardsquare shall indemnify the Client for the damages and costs incurred by the Client as a result of such a claim, as awarded by a competent court of final instance or as agreed to by Guardsquare pursuant to a settlement agreement. 9.2 In the event the Licensed Products, in Guardsquare\u2019s reasonable opinion, are likely to become or become the subject of a third-party infringement claim (as per clause 9.1), Guardsquare shall have the right, at its sole option and expense, to: (i) modify the ((allegedly) infringing part of the Licensed Products so that they become non-infringing while preserving equivalent functionality; (ii) obtain for the Client a license to continue using the Licensed Products in accordance with this Agreement; or (iii) terminate the relevant license and pay to the Client an amount equal to a pro rata portion of the License Fee paid to Guardsquare hereunder for that portion of the Licensed Products which is the subject of such infringement, such portion equaling any pre-paid Fees covering the period after actual termination. 9.3 The foregoing states the entire liability and obligation of Guardsquare and the sole remedy of the Client with respect to any infringement or alleged infringement of any Intellectual Property Rights caused by the Licensed Products or any part thereof.","title":"9. Indemnification"},{"location":"license.html#10-limitations-on-liability","text":"10.1 To the maximum extent permitted by applicable law, Guardsquare excludes its liability (whether in contract, warranty, tort (including as a result of negligence, product liability or other theory) or otherwise) to the Client or any other person for recovery or recoupment of any investment made by the Client, its affiliates or any third parties acting on their behalf or under their control, in connection with this Agreement, and for any indirect, punitive, special or consequential damages, or damages for loss of profit, revenue, business, contracts or clients, loss or corruption of data, loss of goodwill, reputational harm, opportunity loss, loss of anticipated savings, and the cost of procuring replacement goods or services, arising out of or relating to this Agreement, even if Guardsquare has been advised of the possibility of such costs or damages arising. 10.2 Without prejudice to and without limiting Section 10.1 of this Agreement, to the maximum extent permitted under applicable law, Guardsquare\u2019s liability arising out of or in connection: a) with this Agreement (other than as covered under (b), (c) and (d) below), whether in contract, warranty, tort (including negligence, product liability or other theory), or otherwise, shall not exceed the total License Fees (excl. taxes) paid to Guardsquare by the Client under this Agreement during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not exceed the total License Fees (excl. taxes) paid under the Agreement; b) with the Support Services provided by Guardsquare to Client under this Agreement, whether in contract, warranty, tort (including negligence, product liability or other theory), or otherwise, shall not exceed fifty (50) percent of the total License Fees (excl. taxes and expenses) paid to Guardsquare by the Client under this Agreement during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not, per contract year, exceed the total License Fees (excl. taxes and expenses) paid under the Agreement in respect of the relevant contract year; c) with General Support provided by Guardsquare to Client under this Agreement, whether in contract, warranty, tort (including negligence, product liability or other theory), or otherwise, shall not exceed the Fees for General Support (excl. taxes and expenses) paid to Guardsquare by the Client under this Agreement in respect of the General Support to which the applicable liability claim relates during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not exceed the total Fees for General Support (excl. taxes and expenses) paid under the relevant Order in respect of such General Support; d) with the Professional Services provided by Guardsquare to the Client under the Agreement, whether in contract, warranty, tort (including negligence, product liability or other theory) or otherwise, shall not exceed the total Professional Services Fees (excl. taxes and expenses) paid by the Client to Guardsquare in respect of such Professional Services under the Order to which the liability claim relates during the twelve (12) month period preceding the date on which the applicable liability claim arose, provided that Guardsquare\u2019s aggregate liability in this respect shall not exceed the total Professional Services Fees (excl. taxes and expenses) paid under such Order. 10.3 The Client agrees that Guardsquare can only be held liable as per the terms of this Section 10 to the extent damages suffered by the Client are directly and solely attributable to Guardsquare. The exclusions and limitations of liability under this Section shall operate to the benefit of Guardsquare\u2019s affiliates and subcontractors under this Agreement to the same extent such provisions operate to the benefit of Guardsquare. 10.4 The Client\u2019s exclusive remedy for any claim arising out of or in connection with this Agreement shall be for Guardsquare, upon receipt of written notice, to use reasonable efforts to cure the breach or default at its expense, and failing that, Guardsquare\u2019s liability shall be limited as set forth in this Agreement. The Client shall have a duty to mitigate damages for which Guardsquare is responsible.","title":"10. Limitations on Liability"},{"location":"license.html#11-term-and-termination","text":"11.1 This Agreement shall commence on the Effective Date and shall continue for the term of the Order to which it relates. As a default (unless deviated from in the relevant Order), Orders (including any Software licenses and Support Services contracted pursuant to such an Order) are entered into for an initial one (1) year term (the \u201cInitial Term\u201d). Upon expiry of this Initial Term, the Orders shall automatically renew for successive one (1) year periods (each a \u201cRenewal Term\u201d), unless terminated by either Party on giving at least three (3) months\u2019 written notice prior to the expiry of the Initial Term or then current Renewal Term. Neither Party shall be entitled to terminate the Agreement or an Order in whole or in part for convenience save as expressly permitted herein. 11.2 Termination of the Agreement shall not automatically result in termination of any Orders, which must be separately terminated as set forth herein. Time and Material Professional Services (portions of) Orders may be terminated by the Client for convenience only if expressly so stipulated in the relevant Order, on giving such notice as specified in such Order. Fixed price Professional Services (portions of) Orders may not be terminated for convenience, failure of which shall result in the full fixed price becoming payable by the Client upon termination. 11.3 Either Party may terminate this Agreement, the Support Services (if the default relates to the Support Services) or the portion of the Order that is the subject of the default, by written notice to the other Party, if the other Party materially breaches this Agreement, the Support Services related provisions or a specific portion of such Order (as applicable) and fails to (i) cure such breach within thirty (30) days from the date of receipt of a default notice by the defaulting Party, and (ii) make substantial progress to cure such breach and implement a remedial plan that results in a cure of such breach within sixty (60) days from receipt of such default notice, provided that Guardsquare shall be entitled to terminate this Agreement (in whole or in part) (or alternatively suspend its obligations and/or the Client\u2019s user rights granted hereunder) on giving written notice in the event the Client breaches the license terms hereunder or infringes Guardsquare\u2019s Intellectual Property Rights. 11.4 Either Party may terminate this Agreement or an Order by written notice to the other Party, effective as of the date of delivery of such notice, if the other Party becomes the subject of a voluntary or involuntary bankruptcy, insolvency or similar proceeding or otherwise liquidates or ceases to do business. Consequences of termination. 11.5 Upon termination of an Order for whatever reason, the licenses granted to the Client pursuant to such Order in accordance with Section 2 of this Agreement shall automatically terminate and the Client shall return to Guardsquare all copies (in whatever form or medium) of the Licensed Products. 11.6 Upon termination for convenience by the Client of an Order or any of the Licensed Product licenses other than as expressly permitted in Section 11.1, the full License Fees for the Initial Term and then current Renewal Term (as applicable) shall remain payable by the Client. In the event the Client terminates an Order or the Support Services for convenience other than as expressly permitted in Section 11.1, the Support Fees shall remain payable by the Client for the full then current term (Initial Term or then current Renewal Term, as applicable). In the event the Client terminates the Agreement or an Order for convenience other than as expressly permitted in Section 11.2, the full Professional Services Fees and reimbursable expenses payable in respect of such Order shall remain payable by the Client. 11.7 In the event Guardsquare terminates the Agreement, Licensed Product licenses, Support Services or an Order pursuant to Sections 11.3 or 11.4, the Client\u2019s payment obligations shall be as per Section 11.6 above. 11.8 In the event the Client terminates the Agreement, Support Services or an Order pursuant to Sections 11.3 or 11.4, the Client must pay Guardsquare the Fees and reimbursable expenses payable in respect of any of the aforelisted up to the actual termination date. 11.9 The provisions of this Agreement that are expressly or implicitly intended to survive termination, including Sections 5, 6, 7, 8, 10, 11 (consequences of termination) and 12 (as applicable) of this Agreement, shall survive any expiration or termination of this Agreement.","title":"11. Term and Termination"},{"location":"license.html#12-miscellaneous","text":"12.1 All notices hereunder shall be in writing, addressed to the receiving Party's address as set forth below or to such other address as a Party may designate by notice hereunder, and either (i) delivered by hand, (ii) sent by overnight courier, or (iii) sent by registered mail, return receipt requested, postage prepaid: If to Guardsquare to: Depending on the Order contracting entity: \u27a2 GuardSquare NV, Tervuursevest 362 bus 1, 3000 Leuven, Belgium; or \u27a2 GuardSquare Inc., 711 Atlantic Ave Floor 6, Boston, MA 02111, USA. Contact as per the relevant Order. If to the Client to: As per the relevant Order. All notices shall be deemed to have been given either (i) if by hand, at the time of actual delivery thereof to the receiving Party at such Party\u2019s address as provided above, as reasonably demonstrated by the Party serving notice, (ii) if sent by overnight courier, on the day such notice is delivered to the receiving Party at such Party\u2019s address as provided above, as reasonably demonstrated by the Party serving notice, or (iii) if sent by registered mail, three (3) days following the day such mailing is made. 12.2 The Client acknowledges that Guardsquare\u2019s performance of this Agreement is dependent on the Client\u2019s cooperation and the Client agrees to cooperate with Guardsquare to enable the latter to adequately perform its obligations under this Agreement. Such cooperation shall include (i) timely making available management decisions, information, approvals and acceptances; and (ii) at no cost to Guardsquare, providing timely and appropriate access to Client facilities, personnel, equipment, resources and systems, including its owned and licensed software, tools, data, databases and methodologies, and any relevant information and documentation (such information and documentation to be accurate and complete) as necessary to facilitate performance of the Agreement. 12.3 The Client agrees that it shall not, during the term of this Agreement and for a period of one year after the expiration or termination of this Agreement, without Guardsquare\u2019s prior written consent, directly or indirectly (including through its affiliates or recruitment agencies), hire or otherwise engage, in whatever capacity (including as an employee or consultant), or solicit the services of, any personnel member of Guardsquare or its affiliates, while such person is employed or engaged by Guardsquare or its affiliates and during six months after such employment or engagement ends. For the purpose of this section, \u201chire\u201d means to employ an individual as an employee or engage such individual as an independent contractor, whether on a full-time, part-time or temporary basis. The Client agrees that it shall not encourage third parties to act in a manner that would constitute a breach of this section, if such action had been performed by the Client. In case the above non-solicitation/non-hire obligations are not complied with and give rise to actual employment/engagement of Guardsquare\u2019s or its affiliates\u2019 personnel, the Client shall compensate Guardsquare by paying, upon a first request, a lump-sum amount corresponding to twelve times the gross salary/compensation each such person so hired/engaged earned with Guardsquare or its affiliates (as applicable) during the last full month such person worked for Guardsquare or its affiliates. 12.4 Any timeframe for performance specified in this Agreement or an Order shall be indicative target dates only, unless expressly stipulated to be binding milestones. 12.5 The terms and conditions of this Agreement may be modified or amended only by written agreement executed by a duly authorized representative of both Parties. The terms and conditions of this Agreement may be waived only by a written document signed by the Party entitled to the benefit of such terms or conditions. No such waiver or consent shall be deemed to be or shall constitute a waiver or consent with respect to any other terms or conditions of this Agreement, whether or not similar. Each such waiver or consent shall be effective only in the specific instance and for the purpose for which it was given, and shall not constitute a continuing waiver or consent. 12.6 The Client may not assign or transfer this Agreement (whether in whole or in part) to any third party (including without limitation its affiliates) without the prior written consent of Guardsquare. Guardsquare shall be free to transfer or assign the Agreement (whether in whole or in part). Guardsquare shall also be free to subcontract performance of this Agreement to its affiliates, to contractors and to third party service providers without having to obtain the Client\u2019s prior consent, provided that Guardsquare shall remain responsible towards the Client in respect of such subcontracted services. 12.7 In the event that any Party is prevented from performing or is unable to perform any of its non-monetary obligations under this Agreement due to any Act of God, fire, casualty, flood, earthquake, war, strike, lockout, epidemic, destruction of production facilities, riot, insurrection, material unavailability, or any other cause beyond the reasonable control of the Party invoking this section, such Party shall give prompt written notice to the other Party, its performance shall be excused, and the time for the performance shall be extended for the period of delay or inability to perform due to such occurrences (or such longer period as is reasonably required as reasonably demonstrated and substantiated by the affected Party). 12.8 The Client acknowledges that, in using the Software pursuant to the Agreement, the Software may collect and process (telemetry) data, which data allows Guardsquare to monitor the Client\u2019s use of the Software and which data may be used by Guardsquare for (among others) marketing, trend analysis, benchmarking purposes, or to further develop the Software. To the extent such consent is legally required, the Client hereby expressly consents to such data collection and processing. Such data may include (without being limitative) anonymized (namely without sensitive data regarding strings and classes related to Application source code being captured, however such data may still be linked to the Client\u2019s account) configuration data (providing (among others) information regarding the Software features used by the Client), and environmental data (including information regarding the build systems and program languages used by the Client). The actual types of data captured will be detailed in the Documentation (as it may change over time). The Client may at any time decide to disable these data capturing functionalities, by changing the Software configuration settings to this effect. In such event, no more data capturing as per the terms of this clause will take place once these functionalities have been disabled. The Client will also be able to configure the Software such that the Client obtains a copy of the telemetry data uploaded to Guardsquare, allowing the Client to keep visibility on the data so captured. As at the Effective Date, no personal data is envisaged to be collected or otherwise processed by Guardsquare pursuant to this clause 12.8 (\u201cprocess\u201d and \u201cpersonal data\u201d each as defined in the General Data Protection Regulation (Regulation (EU) 2016/679) (\u201cGDPR\u201d)). If and to the extent Guardsquare is considered \u2013 under applicable law \u2013 to process personal data in capturing and processing data pursuant to this clause, (i) the Client hereby consents to such data processing to the maximum extent permitted under applicable law and subject to the disabling option set out above, and (ii) Guardsquare shall be the data controller (as defined in the GDPR) in respect of such processing and shall comply with its obligations under applicable data protection laws in this respect. In the event such personal data processing were to take place: - Guardsquare shall inform (posting such information on a designated Guardsquare webpage accessible by the Client shall suffice for such purpose) the Client of the details of such processing as may be required under applicable law; - upon the Client\u2019s reasonable written request and no more than once per Agreement contract year (unless required under applicable law), Guardsquare shall make available to the Client such information as reasonably deemed necessary by Guardsquare to demonstrate its compliance with its personal data processing obligations hereunder (posting such information on a designated Guardsquare webpage accessible by the Client shall suffice for such purpose). To this end, Guardsquare may allow a reputable third-party auditor chosen by Guardsquare to perform audits on the Client\u2019s behalf (to the extent such audit right is available to the Client under applicable law) and the Client hereby authorizes Guardsquare to issue such mandate to the third-party auditor; - upon the Client\u2019s written request, Guardsquare shall destroy the personal data, subject to Guardsquare retaining any copies as may be required by applicable law. The Client acknowledges and agrees that Guardsquare may retain and use data collected hereunder for the purposes set out herein during the term of the Agreement as well as after its termination, subject always to any applicable legal limitations in this respect. 12.9 Guardsquare may freely use Feedback without attribution or the need for Guardsquare (or any third party) to pay the Client or any third party any royalties or other fees of any kind. 12.10 This Agreement and the rights and obligations of the Parties hereunder shall be governed by and construed in accordance with the laws of Guardsquare\u2019s country/state of incorporation without giving effect to the conflict of law principles thereof. The United Nations Convention for the International Sale of Goods shall not apply to this Agreement. In case of any dispute arising in respect of this Agreement, whether during or after its term, the Parties shall first attempt to amicably settle such dispute. Where no such amicable settlement can be reached within a reasonable period from the dispute having arisen, the dispute shall be submitted to the exclusive jurisdiction of the courts of the city/state of incorporation of Guardsquare. 12.11 If a court of competent jurisdiction determines any provision, or any portion thereof, of this Agreement to be unenforceable or invalid, then such provision shall be deemed limited to the extent that such court deems it valid or enforceable and the remaining provisions of this Agreement shall nevertheless remain in full force and effect. 12.12 The Parties hereto acknowledge and agree that they have participated jointly in the negotiation and drafting of this Agreement and that in the event an ambiguity or question of intent or interpretation arises, this Agreement shall be construed as if drafted jointly by the Parties and no presumption or burden of proof shall arise favoring or disfavoring any Party by virtue of the authorship of any of the provisions of this Agreement. 12.13 This Agreement does not constitute a partnership agreement nor does it create a joint venture or agency relationship between Guardsquare and the Client. Neither Party shall take any action or make any representation to any third party that would be inconsistent with the foregoing sentence. Neither Party shall be liable for the representations, acts, or omissions of the other Party unless expressly provided otherwise under the terms of this Agreement. 12.14 No failure or delay by a Party hereto in exercising any right, power or remedy under this Agreement, and no course of dealing between the Parties hereto, shall operate as a waiver of any such right, power or remedy of the Party. No single or partial exercise of any right, power or remedy under this Agreement by a Party hereto, nor any abandonment or discontinuance of steps to enforce any such right, power or remedy, shall preclude such Party from any other or further exercise thereof or the exercise of any other right, power or remedy hereunder. The election of any remedy by a Party hereto shall not constitute a waiver of the right of such Party to pursue other available remedies, save as expressly stipulated otherwise in the Agreement. 12.15 As of the Effective Date, Guardsquare shall be entitled to reference the Client as a Guardsquare Client, in accordance with the Client\u2019s reasonable instructions (e.g. as regards use of Client logo) notified to Guardsquare in this respect. 12.16 This Agreement (including its Schedules and Orders) constitutes the entire agreement and understanding between the Parties with respect to the subject matter hereof and supersedes all prior oral or written agreements, representations or understandings between the Parties relating to the subject matter hereof. All such Schedules, as the same may be amended from time to time in accordance with the terms of this Agreement, are incorporated herein by reference and made a part hereof. The terms of this Agreement shall be deemed included in the Orders by reference. No statement, representation, warranty, covenant or agreement of any kind not expressly set forth in this Agreement or an Order shall affect, or be used to interpret, change or restrict, the express terms and conditions of this Agreement or an Order. Additional or deviating terms and conditions (such as, for example, purchase orders or other documents of the Client or third parties) are hereby expressly refused and rejected, even if Guardsquare does not refuse or reject such terms and conditions on a case by case basis.","title":"12. Miscellaneous"},{"location":"license.html#additional-notices","text":"A DexGuard runtime library is distributed with the following libraries, to which the following license applies. Library Version License Bionic library N/A Android open source license Chromium Crazy Linker library N/A Android open source license Cordova 3.7 + 5.1 (2 versions) Apache License 2.0 crosswalk 18.48.477.13 BSD License (3-clause) LibTomMath WTFPL or The Unlicense Bouncy Castle 1.69 MIT license","title":"Additional notices"},{"location":"loggingremoval.html","text":"DexGuard can remove logging calls in your application, to improve performance and to prevent leaking sensitive information in the code and at run-time. Prerequisites \u00b6 In order to remove logging calls, the optimization step has to be enabled (including optimization code/removal/advanced ). Configurations \u00b6 The following sections provide sample configurations for various logging frameworks. Android Logging \u00b6 # Remove Android logging calls (in this case, including errors). -assumenosideeffects class android.util.Log { public static boolean isLoggable ( java.lang.String , int ); public static int v ( ... ); public static int d ( ... ); public static int i ( ... ); public static int w ( ... ); public static int e ( ... ); public static int println ( int , java.lang.String , java.lang.String ); public static java.lang.String getStackTraceString ( java.lang.Throwable ); # Warning: removing terrible failure logging calls might change behavior # for devices < API Level 23. public static int wtf ( ... ); } Java Logging \u00b6 # Remove Java logging calls. -assumenosideeffects class java.util.logging.Logger { public static java.util.logging.Logger getLogger ( ... ); public boolean isLoggable ( java.util.logging.Level ); public void entering ( ... ); public void exiting ( ... ); public void finest ( ... ); public void finer ( ... ); public void fine ( ... ); public void config ( ... ); public void info ( ... ); public void warning ( ... ); public void severe ( ... ); } Apache Commons Logging \u00b6 # Remove Apache Commons logging calls. -assumenosideeffects class org.apache.commons.logging.Log { public boolean is*Enabled (); public void trace ( ... ); public void debug ( ... ); public void info ( ... ); public void warn ( ... ); public void error ( ... ); public void fatal ( ... ); } SLF4J \u00b6 # Remove SLF4J logging calls. -assumenosideeffects class org.slf4j.Logger { public boolean is*Enabled (); public void trace ( ... ); public void debug ( ... ); public void info ( ... ); public void warn ( ... ); public void error ( ... ); } Apache Cordova \u00b6 # Remove Cordova logging calls. -assumenosideeffects class org.apache.cordova.LOG { public static boolean isLoggable ( int ); public static void v ( ... ); public static void d ( ... ); public static void i ( ... ); public static void w ( ... ); public static void e ( ... ); } Fabric.io \u00b6 # Remove IOFabric logging calls. -assumenosideeffects class io.fabric.sdk.android.Logger { public void v ( ... ); public void d ( ... ); public void i ( ... ); public void w ( ... ); public void e ( ... ); public void log ( ... ); }","title":"Logging Removal"},{"location":"loggingremoval.html#prerequisites","text":"In order to remove logging calls, the optimization step has to be enabled (including optimization code/removal/advanced ).","title":"Prerequisites"},{"location":"loggingremoval.html#configurations","text":"The following sections provide sample configurations for various logging frameworks.","title":"Configurations"},{"location":"loggingremoval.html#android-logging","text":"# Remove Android logging calls (in this case, including errors). -assumenosideeffects class android.util.Log { public static boolean isLoggable ( java.lang.String , int ); public static int v ( ... ); public static int d ( ... ); public static int i ( ... ); public static int w ( ... ); public static int e ( ... ); public static int println ( int , java.lang.String , java.lang.String ); public static java.lang.String getStackTraceString ( java.lang.Throwable ); # Warning: removing terrible failure logging calls might change behavior # for devices < API Level 23. public static int wtf ( ... ); }","title":"Android Logging"},{"location":"loggingremoval.html#java-logging","text":"# Remove Java logging calls. -assumenosideeffects class java.util.logging.Logger { public static java.util.logging.Logger getLogger ( ... ); public boolean isLoggable ( java.util.logging.Level ); public void entering ( ... ); public void exiting ( ... ); public void finest ( ... ); public void finer ( ... ); public void fine ( ... ); public void config ( ... ); public void info ( ... ); public void warning ( ... ); public void severe ( ... ); }","title":"Java Logging"},{"location":"loggingremoval.html#apache-commons-logging","text":"# Remove Apache Commons logging calls. -assumenosideeffects class org.apache.commons.logging.Log { public boolean is*Enabled (); public void trace ( ... ); public void debug ( ... ); public void info ( ... ); public void warn ( ... ); public void error ( ... ); public void fatal ( ... ); }","title":"Apache Commons Logging"},{"location":"loggingremoval.html#slf4j","text":"# Remove SLF4J logging calls. -assumenosideeffects class org.slf4j.Logger { public boolean is*Enabled (); public void trace ( ... ); public void debug ( ... ); public void info ( ... ); public void warn ( ... ); public void error ( ... ); }","title":"SLF4J"},{"location":"loggingremoval.html#apache-cordova","text":"# Remove Cordova logging calls. -assumenosideeffects class org.apache.cordova.LOG { public static boolean isLoggable ( int ); public static void v ( ... ); public static void d ( ... ); public static void i ( ... ); public static void w ( ... ); public static void e ( ... ); }","title":"Apache Cordova"},{"location":"loggingremoval.html#fabricio","text":"# Remove IOFabric logging calls. -assumenosideeffects class io.fabric.sdk.android.Logger { public void v ( ... ); public void d ( ... ); public void i ( ... ); public void w ( ... ); public void e ( ... ); public void log ( ... ); }","title":"Fabric.io"},{"location":"ndk.html","text":"DexGuard\u2019s optional Android Native Development Kit (NDK) addon offers a full suite of capabilities to effectively harden your native libraries written in C or C++. It protects against reverse engineering and can additionally inject runtime application self protection (RASP) detections also in the native code parts. Please refer to the separate Android NDK manual which is included in the separate NDK zip-package for more details on how to set up and configure DexGuard's NDK addon.","title":"NDK"},{"location":"optimizations.html","text":"The optimization step of DexGuard can be switched off with the -dontoptimize option. For more fine-grained control over individual optimizations, experts can use the -optimizations option, with a filter based on the optimization names listed below. The filter works like any filter in DexGuard. The following wildcards are supported: Wildcard Meaning ? matches any single character in an optimization name. * matches any part of an optimization name. An optimization that is preceded by an exclamation mark ' ! ' is excluded from further attempts to match with subsequent optimization names in the filter. Make sure to specify filters correctly, since they are not checked for potential typos. For example, \" code/simplification/variable,code/simplification/arithmetic \" only performs the two specified peephole optimizations. For example, \" !method/propagation/* \" performs all optimizations, except the ones that propagate values between methods. For example, \" !code/simplification/advanced,code/simplification/* \" only performs all peephole optimizations. Some optimizations necessarily imply other optimizations. These are then indicated. Note that the list is likely to change for newer versions, as optimizations are added and reorganized. resource/inlining/resource Inlines resource constants into XML files, whenever possible. resource/inlining/code Inlines resource constants into code, whenever possible. resource/inlining/metadata Inlines metadata from the Android manifest into code, whenever possible. resource/deduplication Removes duplicate resource constants, whenever possible. resource/compaction Removes empty resource constants, whenever possible. Incompatible with app bundles resource/compaction will be automatically disabled when processing app bundles. library/gson Optimizes usages of the Gson library, whenever possible. See Gson optimization for more details. class/marking/final Marks classes as final, whenever possible. class/unboxing/enum Simplifies enum types to integer constants, whenever possible. class/merging/vertical Merges classes vertically in the class hierarchy, whenever possible. class/merging/horizontal Merges classes horizontally in the class hierarchy, whenever possible. class/merging/wrapper Merges wrapper classes with their wrapped classes, whenever possible. field/removal/writeonly (\u21d2 code/removal/advanced ) Removes write-only fields. field/marking/private Marks fields as private, whenever possible. field/generalization/class Generalizes the classes of field accesses, whenever possible. field/specialization/type Specializes the types of fields, whenever possible. field/propagation/value (\u21d2 code/simplification/advanced ) Propagates the values of fields across methods. method/marking/private Marks methods as private, whenever possible ( devirtualization ). method/marking/static (\u21d2 code/removal/advanced ) Marks methods as static, whenever possible ( devirtualization ). method/marking/final Marks methods as final, whenever possible. method/marking/synchronized Unmarks methods as synchronized, whenever possible. method/removal/parameter (\u21d2 code/removal/advanced ) Removes unused method parameters. method/generalization/class Generalizes the classes of method invocations, whenever possible. method/specialization/parametertype Specializes the types of method parameters, whenever possible. method/specialization/returntype Specializes the types of method return values, whenever possible. method/propagation/parameter (\u21d2 code/simplification/advanced ) Propagates the values of method parameters from method invocations to the invoked methods. method/propagation/returnvalue (\u21d2 code/simplification/advanced ) Propagates the values of method return values from methods to their invocations. method/inlining/short Inlines short methods. method/inlining/unique Inlines methods that are only called once. method/inlining/tailrecursion Simplifies tail recursion calls, whenever possible. code/merging Merges identical blocks of code by modifying branch targets. code/simplification/variable Performs peephole optimizations for variable loading and storing. code/simplification/arithmetic Performs peephole optimizations for arithmetic instructions. code/simplification/cast Performs peephole optimizations for casting operations. code/simplification/field Performs peephole optimizations for field loading and storing. code/simplification/branch (\u21d2 code/removal/simple ) Performs peephole optimizations for branch instructions. code/simplification/object Performs peephole optimizations for object instantiation. code/simplification/string Performs peephole optimizations for constant strings. code/simplification/math Performs peephole optimizations for Math method calls. code/simplification/advanced ( best used with code/removal/advanced ) Simplifies code based on control flow analysis and data flow analysis. code/removal/advanced (\u21d2 code/removal/exception ) Removes dead code based on control flow analysis and data flow analysis. code/removal/simple (\u21d2 code/removal/exception ) Removes dead code based on a simple control flow analysis. code/removal/variable Removes unused variables from the local variable frame. code/removal/exception Removes exceptions with empty try blocks. code/allocation/variable Optimizes variable allocation on the local variable frame. DexGuard also provides some unofficial settings to control optimizations, that may disappear in future versions. These are Java system properties, which can be set as JVM arguments (with -D... ): maximum.inlined.code.length (default = 8 bytes) Specifies the maximum code length (expressed in bytes) of short methods that are eligible to be inlined. Inlining methods that are too long may unnecessarily inflate the code size. maximum.resulting.code.length (default = 8000 bytes for JSE, 2000 bytes for JME) Specifies the maximum resulting code length (expressed in bytes) allowed when inlining methods. Many Java virtual machines do not apply just-in-time compilation to methods that are too long, so it's important not to let them grow too large. optimize.conservatively (default = unset) Allows input code with ordinary instructions intentionally throwing NullPointerException , ArrayIndexOutOfBoundsException , or ClassCastException , without any other useful purposes. By default, DexGuard may just discard such seemingly useless instructions, resulting in better optimization of most common code. Gson optimization \u00b6 DexGuard optimizes Gson code by detecting which domain classes are serialized using the Gson library. It replaces the reflection-based implementation of GSON for reading and writing fields with injected and optimized code that accesses the fields of the domain classes directly when reading and writing JSON. The benefits of this optimization are the following: Domain classes used in conjunction with GSON can be freely obfuscated. The field names that occur in the serialized JSON are hidden behind a layer of encryption to prevent reverse engineering of these domain classes. The injected serialization code gives better performance compared to the GSON implementation, which relies on reflection. Less configuration is needed as the optimization automatically keeps classes and fields that are required for serialization. Configuration \u00b6 The Gson optimization is enabled by default and doesn't require any additional configuration, as long as the application code doesn't use unsupported Gson features(see Known limitations ). Disabling Gson optimizations If you are using Gson but disable Gson optimizations then you should use the default configuration dexguard-gson.pro in addition to a standard default configuration. Known limitations \u00b6 DexGuard can not optimize the following use cases of Gson: Serializing classes containing one of the following Gson annotations: @JsonAdapter @Since @Until Serializing classes that have generic type variables in their signature. Serializing classes using a Gson instance that was built with one of the following settings on the GsonBuilder: excludeFieldsWithModifier setFieldNamingPolicy When one of the above Gson features is used, DexGuard automatically preserves the original Gson implementation for all affected domain classes. This means that the serialized fields of these domain classes need to be explicitly kept again in the DexGuard configuration so that they can be safely accessed through reflection.","title":"Optimizations"},{"location":"optimizations.html#gson","text":"DexGuard optimizes Gson code by detecting which domain classes are serialized using the Gson library. It replaces the reflection-based implementation of GSON for reading and writing fields with injected and optimized code that accesses the fields of the domain classes directly when reading and writing JSON. The benefits of this optimization are the following: Domain classes used in conjunction with GSON can be freely obfuscated. The field names that occur in the serialized JSON are hidden behind a layer of encryption to prevent reverse engineering of these domain classes. The injected serialization code gives better performance compared to the GSON implementation, which relies on reflection. Less configuration is needed as the optimization automatically keeps classes and fields that are required for serialization.","title":"Gson optimization"},{"location":"optimizations.html#configuration","text":"The Gson optimization is enabled by default and doesn't require any additional configuration, as long as the application code doesn't use unsupported Gson features(see Known limitations ). Disabling Gson optimizations If you are using Gson but disable Gson optimizations then you should use the default configuration dexguard-gson.pro in addition to a standard default configuration.","title":"Configuration"},{"location":"optimizations.html#gsonlimitations","text":"DexGuard can not optimize the following use cases of Gson: Serializing classes containing one of the following Gson annotations: @JsonAdapter @Since @Until Serializing classes that have generic type variables in their signature. Serializing classes using a Gson instance that was built with one of the following settings on the GsonBuilder: excludeFieldsWithModifier setFieldNamingPolicy When one of the above Gson features is used, DexGuard automatically preserves the original Gson implementation for all affected domain classes. This means that the serialized fields of these domain classes need to be explicitly kept again in the DexGuard configuration so that they can be safely accessed through reflection.","title":"Known limitations"},{"location":"plugins.html","text":"DexGuard can encrypt sensitive resources in your application with polymorphic code. With DexGuard's plugin framework, you can replace the standard encryption and decryption algorithms with your own. With custom encryption algorithms, you can raise the bar for attackers who try to reverse engineer and modify your applications. The greater the variation in the obfuscation of your applications, the harder it becomes for attackers and reverse engineering tools to recognize patterns and decipher the encryption in obfuscated code. You can write your own encryption algorithms for DexGuard's plugin framework in Java, without the need to know Java bytecode or Dalvik bytecode. There are three simple steps: Implement your own encryption plugin class , based on the DexGuard API . Compile your plugin code and package it in a jar file. Apply the plugin in your DexGuard build . Dependencies for custom encryption plugins \u00b6 DexGuard comes with a Java-based API for the development of custom DexGuard encryption algorithms. The DexGuard API classes require at least a Java 1.6 compiler. You can find the DexGuard plugin API in the DexGuard distribution at lib/dexguard-api.jar It is self-contained, and does not depend on any libraries, other than the Java Standard Library. Notably, it does not depend on lib/dexguard.jar . You may use other libraries, such as cryptographic frameworks, in your algorithm implementation. Note however that all classes used by your decryption code will also end up in your obfuscated application, which might run in another runtime environment (e.g., Android). If you should use third-party libraries, also verify that their license allows redistribution and modification of their code. Implementing a custom encryption plugin \u00b6 DexGuard's plugin API provides an abstract encryption class for each type of resource that can be encrypted: Resource type Plugin API abstract class String com.guardsquare.dexguard.encryption.string.StringEncryptionPlugin Native library com.guardsquare.dexguard.encryption.nativelibrary.NativeLibraryEncryptionPlugin Asset com.guardsquare.dexguard.encryption.asset.AssetEncryptionPlugin Android resource com.guardsquare.dexguard.encryption.resource.ResourceEncryptionPlugin Each encryption class has an encryption and decryption method, taking either an InputStream , OutputStream , a byte array or String as input. You can implement a cryptographic algorithm for use with DexGuard by extending the appropriate encryption class and implementing the corresponding encrypt/decrypt methods. The DexGuard API Javadoc provides a detailed description of each of the encryption classes. The following is a simple example of an asset encryption plugin, encrypting assets by applying an exclusive or operation on all bytes, with a given constant: public class SimpleConstantXorAssetEncryptionPlugin extends AssetEncryptionPlugin < Void , Void > { private static final byte OBFUSCATION_CONSTANT = 76 ; public OutputStream encryptAsset ( OutputStream outputStream , Void sharedEncryptionKey , Void encryptionKey ) throws IOException { return new XorOutputStream ( outputStream , OBFUSCATION_CONSTANT ); } public InputStream decryptAsset ( InputStream inputStream , Void sharedEncryptionKey , Void encryptionKey ) throws IOException { return new XorInputStream ( inputStream , OBFUSCATION_CONSTANT ); } } During the build process of your application, DexGuard will call the encrypt method of your plugin to encrypt your application's resources, before packing them into the output jar or apk. The decrypt method of your plugin will be obfuscated and copied into the application code, in the places where encrypted resources are loaded. Therefore, the decryption code needs to be compatible with the target environment of the application (e.g. Android). Applying the custom encryption plugin to your application \u00b6 Once your encryption implementation is finished, you can compile it and bundle it in a jar file. You can then instruct DexGuard to use it, by adding the following line to your DexGuard configuration: -pluginjars myCrypthographicPlugin.jar Then apply encryption to the various resource types as usual: -encryptstrings [ string_filter ] -encryptnativelibraries [file_filter] -encryptassetfiles [file_filter] -encryptresourcefiles [file_filter] DexGuard automatically picks up the plugin implementations in your plugin jar. If it finds multiple implementations, it will randomly choose an algorithm for each resource. The more implementations you can provide, the harder it will generally become to reverse engineer obfuscated applications. For Android resources (files in res/XXX), only one algorithm is supported per application. If, for some resource type, DexGuard doesn't find a plugin implementation in your jar, it will fall back to the default built-in algorithms. Parameterizing the encryption \u00b6 To increase the strength of your encryption, you can add variation to the encryption, by parameterizing the algorithm with encryption keys. The approach is slightly different depending on the resource to be encrypted. Android Resources \u00b6 For Android resources, the encryptResource() and decryptResource() methods take resource-specific parameters (resource ID, file name, file size) that can be used to parameterize the algorithm. As a very simple example, you could use the resource ID as a cryptographic key for our XOR-based encryption algorithm: public byte [] encryptResource ( byte [] bytes , int resourceId , String fileName ) { return XorUtil . xor ( bytes , resourceId ); } public byte [] decryptResource ( byte [] encryptedBytes , int resourceId , String fileName ) { return XorUtil . xor ( encryptedBytes , resourceId ); } Assets and native libraries \u00b6 Encryption keys are modeled using Java classes. The contents of an encryption key class are specific to the algorithm it is used with; it can range from a simple byte to a complex combination of primitives, arrays and other data. Note that there are some restrictions on its contents; please refer to the Javadoc of the encryption plugin classes for more details. For assets and native libraries, there are two types of encryption keys: Shared encryption keys: a key that is shared by a group of resources. DexGuard automatically groups resources for key sharing, based on internal heuristics. Resource-specific encryption keys: a key that is specific to one individual asset or native library. Encryption key classes are linked to an encryption plugin via two generic type parameters of the plugin class. Key instances are created and initialized for a given (set of) resource(s) in the create*EncryptionKey methods of the plugin. These methods receive additional contextual information about the encrypted resource(s), that can be used to derive a value for the encryption key. In the following example, the encryption keys for a simple asset plugin are defined by a simple byte; their value is derived from the group seed and the asset file size: public class SimpleXorAssetEncryptionPlugin implements AssetEncryptionPlugin < SharedEncryptionKey , EncryptionKey > { public SharedEncryptionKey createAssetSharedEncryptionKey ( long groupSeed , Set assetFileNames ) { SharedEncryptionKey key = new SharedEncryptionKey (); key . parameter = ( byte ) groupSeed ; return key ; } public EncryptionKey createAssetEncryptionKey ( SharedEncryptionKey sharedEncryptionKey , long seed , String assetFileName , long approximateFileSize ) { EncryptionKey key = new EncryptionKey (); key . parameter = ( byte ) assetFileSize ; return key ; } public static class SharedEncryptionKey { public byte parameter ; } public static class EncryptionKey { public byte parameter ; } } The encryption keys are passed as parameters to the encrypt* and decrypt* methods, that can use them to properly configure the encryption/decryption algorithm. Although not required, you should preferably use both encryption keys to initialize the cryptographic algorithm, for maximal security. Continuing with the previous example, we can now combine both bytes of the shared and individual asset encryption key in the encrypt and decrypt method, and use the resulting value in a XOR operation: public OutputStream encryptAsset ( OutputStream outputStream , SharedEncryptionKey sharedEncryptionKey , EncryptionKey encryptionKey ) throws IOException { byte combinedXorValue = ( byte )( sharedEncryptionKey . parameter ^ encryptionKey . parameter ); return new XorOutputStream ( outputStream , combinedXorValue ); } public InputStream decryptAsset ( InputStream inputStream , SharedEncryptionKey sharedEncryptionKey , EncryptionKey encryptionKey ) throws IOException { byte combinedXorValue = ( byte ) ( sharedEncryptionKey . parameter ^ encryptionKey . parameter ); return new XorInputStream ( inputStream , combinedXorValue ); } During the build process, DexGuard will generate the encryption keys by calling the key creation methods for each resource, and pass these keys to the encrypt method, together with the data to be encrypted. At the same time, it will store all encryption keys in the obfuscated application, and make sure the decrypt method, within the application, gets called with the correct encryption keys for each encrypted resource. Strings \u00b6 For Strings, there is no distinction between the individual encryption key and the encrypted data. For a given String and shared encryption key, the encryption algorithm generates a single output, the encrypted string data. The contents of the encrypted data can be chosen freely, within the limits of the framework \u2014 see Limitations. The decryption method receives the shared encryption key, together with the encrypted string data, and decrypts it back to the original String. The following snippet shows a simple example of a string encryption that XORs the character data of the String: public class SimpleStringEncryptionPlugin extends StringEncryptionPlugin < Void , SimpleStringEncryptionPlugin . EncryptedString > { private static final char OBFUSCATION_CONSTANT = 76 ; public EncryptedString encryptString ( Void sharedEncryptionKey , long stringSeed , String string ) { EncryptedString encryptedString = new EncryptedString (); encryptedString . data = XorUtil . xor ( string . toCharArray (), OBFUSCATION_CONSTANT ); return encryptedString ; } public String decryptString ( Void sharedEncryptionKey , EncryptedString encryptedString ) { return new String ( XorUtil . xor ( encryptedString . data , OBFUSCATION_CONSTANT )); } public static class EncryptedString { char [] data ; } } Limitations \u00b6 Some restrictions apply on the implementations of encryption plugin and encryption key classes. Please refer to the DexGuard API Javadoc for further details.","title":"Encryption Plugins"},{"location":"plugins.html#dependencies","text":"DexGuard comes with a Java-based API for the development of custom DexGuard encryption algorithms. The DexGuard API classes require at least a Java 1.6 compiler. You can find the DexGuard plugin API in the DexGuard distribution at lib/dexguard-api.jar It is self-contained, and does not depend on any libraries, other than the Java Standard Library. Notably, it does not depend on lib/dexguard.jar . You may use other libraries, such as cryptographic frameworks, in your algorithm implementation. Note however that all classes used by your decryption code will also end up in your obfuscated application, which might run in another runtime environment (e.g., Android). If you should use third-party libraries, also verify that their license allows redistribution and modification of their code.","title":"Dependencies for custom encryption plugins"},{"location":"plugins.html#implementation","text":"DexGuard's plugin API provides an abstract encryption class for each type of resource that can be encrypted: Resource type Plugin API abstract class String com.guardsquare.dexguard.encryption.string.StringEncryptionPlugin Native library com.guardsquare.dexguard.encryption.nativelibrary.NativeLibraryEncryptionPlugin Asset com.guardsquare.dexguard.encryption.asset.AssetEncryptionPlugin Android resource com.guardsquare.dexguard.encryption.resource.ResourceEncryptionPlugin Each encryption class has an encryption and decryption method, taking either an InputStream , OutputStream , a byte array or String as input. You can implement a cryptographic algorithm for use with DexGuard by extending the appropriate encryption class and implementing the corresponding encrypt/decrypt methods. The DexGuard API Javadoc provides a detailed description of each of the encryption classes. The following is a simple example of an asset encryption plugin, encrypting assets by applying an exclusive or operation on all bytes, with a given constant: public class SimpleConstantXorAssetEncryptionPlugin extends AssetEncryptionPlugin < Void , Void > { private static final byte OBFUSCATION_CONSTANT = 76 ; public OutputStream encryptAsset ( OutputStream outputStream , Void sharedEncryptionKey , Void encryptionKey ) throws IOException { return new XorOutputStream ( outputStream , OBFUSCATION_CONSTANT ); } public InputStream decryptAsset ( InputStream inputStream , Void sharedEncryptionKey , Void encryptionKey ) throws IOException { return new XorInputStream ( inputStream , OBFUSCATION_CONSTANT ); } } During the build process of your application, DexGuard will call the encrypt method of your plugin to encrypt your application's resources, before packing them into the output jar or apk. The decrypt method of your plugin will be obfuscated and copied into the application code, in the places where encrypted resources are loaded. Therefore, the decryption code needs to be compatible with the target environment of the application (e.g. Android).","title":"Implementing a custom encryption plugin"},{"location":"plugins.html#configuration","text":"Once your encryption implementation is finished, you can compile it and bundle it in a jar file. You can then instruct DexGuard to use it, by adding the following line to your DexGuard configuration: -pluginjars myCrypthographicPlugin.jar Then apply encryption to the various resource types as usual: -encryptstrings [ string_filter ] -encryptnativelibraries [file_filter] -encryptassetfiles [file_filter] -encryptresourcefiles [file_filter] DexGuard automatically picks up the plugin implementations in your plugin jar. If it finds multiple implementations, it will randomly choose an algorithm for each resource. The more implementations you can provide, the harder it will generally become to reverse engineer obfuscated applications. For Android resources (files in res/XXX), only one algorithm is supported per application. If, for some resource type, DexGuard doesn't find a plugin implementation in your jar, it will fall back to the default built-in algorithms.","title":"Applying the custom encryption plugin to your application"},{"location":"plugins.html#parameterizing-the-encryption","text":"To increase the strength of your encryption, you can add variation to the encryption, by parameterizing the algorithm with encryption keys. The approach is slightly different depending on the resource to be encrypted.","title":"Parameterizing the encryption"},{"location":"plugins.html#android-resources","text":"For Android resources, the encryptResource() and decryptResource() methods take resource-specific parameters (resource ID, file name, file size) that can be used to parameterize the algorithm. As a very simple example, you could use the resource ID as a cryptographic key for our XOR-based encryption algorithm: public byte [] encryptResource ( byte [] bytes , int resourceId , String fileName ) { return XorUtil . xor ( bytes , resourceId ); } public byte [] decryptResource ( byte [] encryptedBytes , int resourceId , String fileName ) { return XorUtil . xor ( encryptedBytes , resourceId ); }","title":"Android Resources"},{"location":"plugins.html#assets-and-native-libraries","text":"Encryption keys are modeled using Java classes. The contents of an encryption key class are specific to the algorithm it is used with; it can range from a simple byte to a complex combination of primitives, arrays and other data. Note that there are some restrictions on its contents; please refer to the Javadoc of the encryption plugin classes for more details. For assets and native libraries, there are two types of encryption keys: Shared encryption keys: a key that is shared by a group of resources. DexGuard automatically groups resources for key sharing, based on internal heuristics. Resource-specific encryption keys: a key that is specific to one individual asset or native library. Encryption key classes are linked to an encryption plugin via two generic type parameters of the plugin class. Key instances are created and initialized for a given (set of) resource(s) in the create*EncryptionKey methods of the plugin. These methods receive additional contextual information about the encrypted resource(s), that can be used to derive a value for the encryption key. In the following example, the encryption keys for a simple asset plugin are defined by a simple byte; their value is derived from the group seed and the asset file size: public class SimpleXorAssetEncryptionPlugin implements AssetEncryptionPlugin < SharedEncryptionKey , EncryptionKey > { public SharedEncryptionKey createAssetSharedEncryptionKey ( long groupSeed , Set assetFileNames ) { SharedEncryptionKey key = new SharedEncryptionKey (); key . parameter = ( byte ) groupSeed ; return key ; } public EncryptionKey createAssetEncryptionKey ( SharedEncryptionKey sharedEncryptionKey , long seed , String assetFileName , long approximateFileSize ) { EncryptionKey key = new EncryptionKey (); key . parameter = ( byte ) assetFileSize ; return key ; } public static class SharedEncryptionKey { public byte parameter ; } public static class EncryptionKey { public byte parameter ; } } The encryption keys are passed as parameters to the encrypt* and decrypt* methods, that can use them to properly configure the encryption/decryption algorithm. Although not required, you should preferably use both encryption keys to initialize the cryptographic algorithm, for maximal security. Continuing with the previous example, we can now combine both bytes of the shared and individual asset encryption key in the encrypt and decrypt method, and use the resulting value in a XOR operation: public OutputStream encryptAsset ( OutputStream outputStream , SharedEncryptionKey sharedEncryptionKey , EncryptionKey encryptionKey ) throws IOException { byte combinedXorValue = ( byte )( sharedEncryptionKey . parameter ^ encryptionKey . parameter ); return new XorOutputStream ( outputStream , combinedXorValue ); } public InputStream decryptAsset ( InputStream inputStream , SharedEncryptionKey sharedEncryptionKey , EncryptionKey encryptionKey ) throws IOException { byte combinedXorValue = ( byte ) ( sharedEncryptionKey . parameter ^ encryptionKey . parameter ); return new XorInputStream ( inputStream , combinedXorValue ); } During the build process, DexGuard will generate the encryption keys by calling the key creation methods for each resource, and pass these keys to the encrypt method, together with the data to be encrypted. At the same time, it will store all encryption keys in the obfuscated application, and make sure the decrypt method, within the application, gets called with the correct encryption keys for each encrypted resource.","title":"Assets and native libraries"},{"location":"plugins.html#strings","text":"For Strings, there is no distinction between the individual encryption key and the encrypted data. For a given String and shared encryption key, the encryption algorithm generates a single output, the encrypted string data. The contents of the encrypted data can be chosen freely, within the limits of the framework \u2014 see Limitations. The decryption method receives the shared encryption key, together with the encrypted string data, and decrypts it back to the original String. The following snippet shows a simple example of a string encryption that XORs the character data of the String: public class SimpleStringEncryptionPlugin extends StringEncryptionPlugin < Void , SimpleStringEncryptionPlugin . EncryptedString > { private static final char OBFUSCATION_CONSTANT = 76 ; public EncryptedString encryptString ( Void sharedEncryptionKey , long stringSeed , String string ) { EncryptedString encryptedString = new EncryptedString (); encryptedString . data = XorUtil . xor ( string . toCharArray (), OBFUSCATION_CONSTANT ); return encryptedString ; } public String decryptString ( Void sharedEncryptionKey , EncryptedString encryptedString ) { return new String ( XorUtil . xor ( encryptedString . data , OBFUSCATION_CONSTANT )); } public static class EncryptedString { char [] data ; } }","title":"Strings"},{"location":"plugins.html#limitations","text":"Some restrictions apply on the implementations of encryption plugin and encryption key classes. Please refer to the DexGuard API Javadoc for further details.","title":"Limitations"},{"location":"protection.html","text":"In this section, we describe recommended steps to harden code against reverse engineering. The idea is to apply different techniques to create multiple layers of obfuscation. Although no single technique is unbreakable, each layer further raises the bar for attackers. The different techniques protect the application code, but they also protect one another. We go over each of the techniques, explaining why they are useful, how you can apply them, and how you can verify their effects. Core design \u00b6 Discussion \u00b6 The essential basis for a hardened application is a sound design and a robust implementation. Even if you will obfuscate your code, you should look at it as if it is open source and consider the worst-case scenarios. The details are application-specific and lie outside the scope of this guide, but you can find a lot of basic principles in books, blogs, and online presentations. More information \u00b6 Android Security Cookbook , by Keith Makan and Scott Alexander-Bown. Android Security Internals , by Nikolay Elenkov. Android Hacker's Handbook , by Joshua J. Drake, Zach Lanier, Collin Mulliner, Pau Oliva Fora, Stephen A. Ridley, and Georg Wicherski. Secure communication \u00b6 Discussion \u00b6 If your application communicates with a server, you should encrypt the communication with SSL (Secure Sockets Layer) or the more recent TLS (Transport Layer Security). These protocols have been developed for secure communication between a web browser and a server. In a web browser, a user can see the padlock icon when the communication is secure. In an Android application, the user doesn't see a padlock icon, so the developer shouldn't forget to use SSL when appropriate. The server contains a chain of certificates with public keys and certified names. You can obtain a certificate from a Certificate Authority (CA). With the standard Android API, the Android runtime checks such a chain with its database of root certificates. Alternatively, you can create a self-signed certificate. You then need to check the certificate yourself in your application. Occasionally, a Certificate Authority is compromised (as happened with Comodo and DigiNotar). New releases of Android then typically update the database of root certificates. However, if your application always communicates with the same server, it should pin the certificate or its public key, i.e. only accept a minimal, fixed list of trusted certificates or keys. This technique ensures that the application is always talking to the right server and blocks man-in-the-middle attacks. You should be aware that some large websites update their certificates and keys regularly. Configuration \u00b6 You can find the code to create connections with certificate pinning or public key pinning for different Android APIs in the sample samples/basic/SSLPinning . Verification \u00b6 Certificate pinning: remove your trust store from the assets. The server requests should no longer work. Public key pinning: change your list of trusted hashes. The server requests should no longer work. More information \u00b6 Working sample project: samples/basic/SSLPinning Name obfuscation \u00b6 Discussion \u00b6 DexGuard obfuscates the names of identifiers in the applications that it processes. This means that it renames resource files, resources, classes, fields, and methods using meaningless names, where possible. This obfuscation step makes the code base smaller and harder to reverse-engineer. Configuration \u00b6 In release builds, DexGuard automatically applies name obfuscation. DexGuard's default configuration already takes care of common entry points like the Android manifest, with all depending activities, intentions, resources, etc. Any code or third-party frameworks that rely on reflection may be confused by changing the names of classes, fields, methods, and even resources. If the code requires that they keep their original names, you should specify the proper -keep options and -keepresourcefiles options. DexGuard's default configuration helps by already providing tuned configuration for a number of common libraries and frameworks . Verification \u00b6 DexGuard will write the mapping of original names to obfuscated names to a file with the option -printmapping . Such a mapping file may look like this: com.example.HelloWorldActivity -> com.example.HelloWorldActivity: 39:42:void onCreate(android.os.Bundle) -> onCreate com.example.Util -> o.\uff65: byte[] values -> \uff65 int doSomething(android.content.Context) -> \uff65 java.lang.String compute(android.content.Context) -> \u02ca Note that names from the Android runtime are not obfuscated, since obfuscating them would break the application. You can also see the obfuscated names if you disassemble the code with a tool like dexdump ( build-tools/20.0.0/dexdump in the Android SDK), or baksmali (free and open-source: code.google.com/p/smali/ ). In the debug version of the application, the names are still readable: Class descriptor : 'Lcom/example/Util; ... #0 : (in Lcom/example/Util;) name : 'values' ... In the hardened release version of the application, the names are obfuscated: Class descriptor : 'Lo/\uff65;' ... #0 : (in Lo/\uff65;) name : '\uff65' ... More information \u00b6 Keep Options for Code Keep Options for Resources Overview of Keep Options Verification String encryption \u00b6 Discussion \u00b6 String constants in the source code are still readable in the compiled application, with a disassembler like dexdump or baksmali, or a decompiler for Dalvik bytecode. You should let DexGuard encrypt sensitive string constants, so they become invisible to static analysis. Keys, tokens, communication-related strings, and log messages are all good candidates for encryption. Note that string encryption is actually a form of obfuscation, since the strings necessarily have to be decrypted at runtime. Configuration \u00b6 You can apply string encryption with the option -encryptstrings . It offers a number of ways to specify the strings to be encrypted. The most common ones: Obfuscate the specified string constant \u00b6 -encryptstrings class com.example.MyConstants { public static final java.lang.String SECRET_KEY ; } Be aware that the Java compiler already inlines final string constants wherever they are used in the code, which may be in other classes. They may have spread throughout the code before DexGuard processes it. With the above configuration, DexGuard encrypts these constants throughout the code, to provide the expected results. Obfuscate all string constants actually used in the specified class \u00b6 -encryptstrings class com.example.MySecretClass This configuration is convenient if you can identify one or more sensitive classes. All options accept wildcards. Technically, it is possible to encrypt all strings in all classes in the code, but this is generally not advisable for performance reasons. Note : When using companion objects in Kotlin, be aware that the Kotlin compiler stores any defined final string constants on the enclosing class and not on the generated MySecretClass$Companion class. class MySecretClass { companion object { val SECRET_KEY : String = \"...\" ; } } DexGuard can still encrypt these Strings just fine: -encryptstrings class com.example.MySecretClass { private final java.lang.String SECRET_KEY ; } Verification \u00b6 With the -verbose option, DexGuard prints out how many strings it has encrypted. In the debug version of the application, you'll easily find the original strings with a disassembler. For instance: ... const-string v0, \"Hello world!\" In the release version of the application, encrypted strings should no longer be visible. DexGuard will write the list of strings it encrypted, grouped per class, to a file with the -printstringencryption option. More information \u00b6 -encryptstrings Examples: Encrypting strings Working sample project: samples/basic/StringEncryption Verification Implement an encryption plugin to use your own encryption algorithm. Reflection \u00b6 Discussion \u00b6 Name obfuscation can't change invocations of runtime classes, methods, and fields, since that would break the application's code. These invocations therefore remain conveniently readable in the disassembled or decompiled code. This provides attackers a lot of information about the structure and execution flow of the application. Especially for sensitive APIs, such as encryption and secure communication, you may want to make the code less readable by replacing the direct invocations by reflection. You can let DexGuard replace invocations by reflection and then encrypt the resulting strings. They then become difficult to find with static analysis. Configuration \u00b6 For example, encrypt some invocations of the SecureRandom with the option -accessthroughreflection : -accessthroughreflection class java.security.SecureRandom { <init> (); int nextInt (); } You should combine reflection with string encryption. By adding the encryptstrings modifier: -accessthroughreflection , encryptstrings class java.security.SecureRandom { <init> (); int nextInt (); } you can additionally encrypt the strings that are created for the reflection. Alternatively, you can explicitly list the strings you want to encrypt: -encryptstrings \" java.security.SecureRandom \" , \" nextInt \" or encrypt all strings in a particular class: -encryptstrings class com.example.MySecretClass Verification \u00b6 With the -verbose option, DexGuard prints out how much reflection it has added. In the debug version of the application, you'll easily find the original method invocation with a disassembler. For instance: ... new-instance v0, Ljava/security/SecureRandom; ... invoke-direct {v0}, Ljava/security/SecureRandom;.<init>:()V ... ... invoke-virtual {v0}, Ljava/security/SecureRandom;.nextInt:()I In the hardened release version of the application, you can check that any invocations that you have specified are no longer visible. More information \u00b6 -accessthroughreflection Examples: Adding reflection for sensitive APIs Working sample project: samples/basic/Reflection Verification Code obfuscation \u00b6 Discussion \u00b6 The previously outlined obfuscation techniques do not change the execution flow of the application. This allows an attacker to quite easily reconstruct java source code using a decompiler to further analyze or modify the application. You can let DexGuard obfuscate the application's code, which then becomes more difficult to reverse-engineer using decompilers or disassemblers. Configuration \u00b6 You can apply code obfuscation with the option -obfuscatecode . It allows to specify a strength modifier which controls how aggressive the methods will be obfuscated. For example, obfuscate all methods of MyActivity with 'low' strength: -obfuscatecode , low class com.example.MyActivity The option accepts wildcards as well. For example, obfuscate all methods of all classes inside package com.example.secure with 'high' strength: -obfuscatecode , high class com.example.secure.** Verification \u00b6 With the -verbose option, DexGuard prints out for how many methods it has obfuscated the code. Applying a decompiler to the debug version of your application will show java code that closely matches the original source code of the method. In the hardened release version of the application, decompilers will either completely fail to show corresponding source code, or display a highly obfuscated version which doesn't match the original execution flow anymore. More information \u00b6 -obfuscatecode Strength modifiers Working sample project: samples/basic/CodeObfuscation Verification Code virtualization \u00b6 Discussion \u00b6 There are cases where Class Encryption cannot be used due to technical constraints (e.g. Activities referenced by the AndroidManifest) or when it is too heavy to efficiently use as a final protection layer, code obfuscation goes a long way to protect sensitive code from being decompiled. However some chunks of code are still readable and therefore vulnerable to both static and dynamic analysis. As a powerful final layer around method bodies, DexGuard can perform code virtualization. This technique injects an inlined virtual machine with a randomized instruction set into your application code and re-implements your methods with those instructions. Even though virtualized code can sometimes be decompiled successfully, the resulting method body bares no resemblance to your source code anymore. Note that Exceptions work fine with code virtualization, but line numbers in exception messages are not supported. When interpreting stacktraces passing through methods that have code virtualization applied, there are two possibilities. Either no numbers are displayed, or the device chooses to instead display the byte offset of the instruction that failed. In the latter case, the number will not correspond to any source code line number. Configuration \u00b6 You can apply code virtualization with the option -virtualizecode . The code is first obfuscated with the low setting and then completely virtualized. For example, virtualize a proprietary algorithm in a method of class com.example.MyRecommender : -virtualizecode class com.example.MyRecommender { public java.lang.String [] recommendPopular (); } Due to technical constraints it is currently not possible to virtualize initializers (constructors, static initializers) or methods that use explicit synchronization blocks (however methods marked synchronized are supported). Verification \u00b6 With the -verbose option, DexGuard prints out for how many methods it has applied code virtualization. Applying a decompiler to the debug version of your application will show java code that closely matches the original source code of the method. In the hardened release version of the application, decompilers will either completely fail to show the method's code, or display a code array followed by a partial interpreter in the form of a loop over a switch. More information \u00b6 -virtualizecode Working sample project: samples/basic/CodeVirtualization Verification Removing logging code and stack traces \u00b6 Discussion \u00b6 Logging code provides attackers information about the structure and execution flow of the application. From the perspective of thwarting reverse engineering, you should not leave logging code in released applications. If your logging code (or the logging code in your external libraries) does not depend on compile-time flags like Build.DEBUG , you can let DexGuard remove logging calls for you. Configuration \u00b6 Remove all standard Android logging invocations: -assumenosideeffects class android.util.Log { public static boolean isLoggable ( java.lang.String , int ); public static int v ( ... ); public static int i ( ... ); public static int w ( ... ); public static int d ( ... ); public static int e ( ... ); public static java.lang.String getStackTraceString ( java.lang.Throwable ); } Remove all printing of stack traces: -assumenosideeffects class java.lang.Exception { public void printStackTrace (); } Verification \u00b6 In the debug version of the application, you may find many logging invocations with a disassembler. For instance: ... invoke-static {v0, v1}, Landroid/util/Log;.d:(Ljava/lang/String;Ljava/lang/String;)I In the release version of the application, all of these invocation should be gone. More information \u00b6 -assumenosideeffects Examples: Removing logging code Working sample project: samples/basic/LoggingRemoval Verification Tamper detection \u00b6 Discussion \u00b6 Attackers can extract information like encryption and decryption keys by injecting logging code into an application. They disassemble the application, insert logging code, and run the application again. Their logging code can print out decrypted strings, which include the keys. You can fight this type of dynamic analysis by adding tamper detection to your application. Tamper detection actively checks the integrity of the application at runtime and acts suitably if the application has been modified. Configuration \u00b6 DexGuard offers tamper detection with simple methods that you can call from your application. You first need to add the library lib/dexguard-runtime.jar to your application. You can then invoke the tamper detection methods in the application and act based on their return values. Check the integrity of the entire apk file: int check = TamperDetector . checkApk ( context ); if ( check != 0 ) { // Tampering detected. // ... } Check whether the application is still signed with the original certificate: int check = CertificateChecker . checkCertificate ( context ); if ( check != 0 ) { // Different certificate detected. // ... } Check whether one or more specific files of the apk file have been modified: FileChecker fileChecker = new FileChecker ( context ); int check = 0 check ^= fileChecker . checkFile ( file1 ); check ^= fileChecker . checkFile ( file2 ); // ... if ( check != 0 ) { // Different files detected. // ... } All methods accept an optional additional integer parameter, which they return instead of 0 if the checks are ok. You can pick such a parameter to make the code less predictable. You should weave the tamper detection code into your regular code, making it more difficult to simply disable it. For instance, you could use the return value to affect the computation of a key, so the computed key is wrong if the application has been tampered with. A simplistic example: int checkedKey = TamperDetector . checkApk ( context , key ); If the code detects tampering, the application should fail quietly, possibly with a delay, without giving away any further information. Once you have added your tamper detection code, you should further harden it by encrypting its class, together with the tamper detection library ( com.guardsquare.dexguard.runtime.** ). Verification \u00b6 You can check if the tamper detection works by unpacking the application and repackaging it, for instance with unzip and zip. You can also tamper with the application simply by applying the standard tool zipalign: zipalign -f 4 myapplication.apk The tool repackages the application without fundamentally changing it. This will trigger the tamper detection at runtime. You can check the certificate verification by re-signing the application with a different certificate: zip -d MyApp.apk META-INF/* jarsigner -keystore debug.keystore -storepass android -keypass android -signedjar \\ MyApp_signed.apk MyApp.apk AndroidDebugKey This will trigger the certificate check at runtime. More information \u00b6 Working sample project: samples/basic/TamperDetection Javadoc of the API: com.guardsquare.dexguard.runtime.detection . Environment checks \u00b6 Discussion \u00b6 Even if the application is unaltered, the underlying runtime may be subverted. The application calls into the Android runtime in good faith, but the runtime code may have been compromised. It may for instance intercept method calls that communicate or decrypt sensitive data, and pass the results to an attacker. You may therefore want to check the environment in which the application is running. This is tricky, since the subverted environment may be constructed to look as ordinary and inconspicuous as possible. Nevertheless, you can perform some basic sanity checks: Check whether the application is debuggable or is being debugged. Check whether the application is running in an emulator. Check whether the application is running on a rooted device. Check whether the application is being hooked with specialized tools like Xposed, Substrate or Frida. Like tamper detection, these techniques actively check the integrity of the application and its environment at runtime. You can then act suitably if the environment is not the standard intended environment. Configuration \u00b6 DexGuard offers environment checks as simple methods that you can call from your application. You first need to add the library samples/basic/EnvironmentCheck/libs/dexguard-runtime.jar to your application. You can then invoke the environment checking methods in the application and act based on their return values. Check whether the application is debuggable: int check = DebugDetector . isDebuggable ( context ); if ( check != 0 ) { // Application is debuggable. // ... } Check whether the application is being debugged: int check = DebugDetector . isDebuggerConnected (); if ( check != 0 ) { // Application is being debugged. ... } Check whether the application has been signed with a debug key: int check = DebugDetector . isSignedWithDebugKey ( context ); if ( check != 0 ) { // Application has been signed with a debug key. // ... } Check whether the application is running in an emulator: int check = EmulatorDetector . isRunningInEmulator ( context ); if ( check != 0 ) { // Application is running in an emulator. // ... } Check whether the application is running on a rooted device: int check = RootDetector . isDeviceRooted ( context ); if ( check != 0 ) { // Application is running on a rooted device. ... } Check whether the application is being hooked: int check = HookDetector . isApplicationHooked (); if ( check != 0 ) { // Application is being hooked. ... } All methods accept an optional additional integer parameter. which they return instead of 0 if the checks are ok. You can pick such a parameter to make the code less predictable. You should again weave the tamper detection code into your regular code and further harden it by encrypting the class together with the library ( com.guardsquare.dexguard.runtime.** ). Verification \u00b6 If you have implemented these checks, you can try setting the debug flag, running the application in an emulator, or running the application on a rooted device. More information \u00b6 Working sample project: samples/basic/EnvironmentCheck Runtime Library Javadoc of the API: com.guardsquare.dexguard.runtime.detection . Asset encryption \u00b6 Discussion \u00b6 By default, DexGuard leaves asset files untouched. You can explicitly specify to encrypt sensitive asset files. DexGuard then encrypts them and your application will decrypt them on the fly. Configuration \u00b6 You can specify the asset files that you want to encrypt with the option -encryptassetfiles . For example: -encryptassetfiles assets/secret.txt DexGuard only encrypts asset files that are read with an AssetManager and open(\"secret.txt\") , with a literal string as argument.. Verification \u00b6 With the -verbose option, DexGuard prints out how many asset files it has encrypted. If you unpack encrypted asset files from the hardened release version of the application, you'll see that they have the same lengths as the original files, but encrypted contents. More information \u00b6 -encryptassetfiles Working sample project: samples/basic/AssetEncryption Verification Implement an encryption plugin to use your own encryption algorithm. Resource file encryption \u00b6 Discussion \u00b6 By default, DexGuard leaves resource files untouched. You can explicitly specify to encrypt sensitive resource files. DexGuard then encrypts them and your application will decrypt them on the fly. Only applicable when processing Android applications. Only applicable to APKs, this feature is not supported for app bundles. Configuration \u00b6 You can specify the resource files that you want to encrypt with the option -encryptresourcefiles . For example: -encryptresourcefiles res/layout*/secret.xml DexGuard can encrypt resources in res/layout , res/menu and res/xml . Verification \u00b6 With the -verbose option, DexGuard prints out how many resource files it has encrypted. If you unpack encrypted resource files from the hardened release version of the application, you'll see that they can no longer be viewed with an Android binary XML viewer like aapt. DexGuard will write the list of resources it encrypted to a file with the option -printresourceencryption . More information \u00b6 -encryptresourcefiles Working sample project: samples/basic/ResourceEncryption Verification Implement an encryption plugin to use your own encryption algorithm. Javascript obfuscation \u00b6 Discussion \u00b6 By default, DexGuard leaves JavaScript files largely untouched, and optionally adapts its contents with information about the obfuscated Java elements. You can explicitly specify to obfuscate JavaScript files using DexGuard's built-in JavaScript obfuscator. Configuration \u00b6 You can specify the Javascript files that you want to obfuscate with the option -obfuscatejavascript . For example: -obfuscatejavascript assets/www/secret/**.js You can specify a Javascript configuration with the option -javascriptconfiguration configuration.yml Please refer to the separate Javascript obfuscator manual for more details on obfuscation options. Verification \u00b6 If you unpack the hardened release version of the application, you'll see that the JavaScript file contents are obfuscated according to the specified obfuscation configuration. More information \u00b6 Javascript obfuscator manual Working sample project: samples/basic/JavaScript Verification Resource string encryption \u00b6 Discussion \u00b6 By default, DexGuard only inlines resource strings. You can explicitly specify to encrypt sensitive resource strings. DexGuard then encrypts them and your application will decrypt them on the fly. Only applicable when processing Android applications. Configuration \u00b6 You can specify the resource strings that you want to encrypt with the option -encryptresources . For example: -encryptresources string/message will encrypt the resource string with resource name message . Verification \u00b6 With the -verbose option, DexGuard prints out how many resource strings it has encrypted. If you read resource strings from the hardened release version of the application using a tool like aapt , you'll see that they will be encrypted. DexGuard will write the list of resources it encrypted to a file with the option -printresourceencryption . More information \u00b6 -encryptresources Working sample project: samples/basic/ResourceEncryption Verification Implement an encryption plugin to use your own encryption algorithm. Metadata encryption \u00b6 Discussion \u00b6 By default, DexGuard only inlines metadata in the Android Manifest. You can explicitly specify to encrypt sensitive metadata. DexGuard then both inlines and encrypts them, and your application will decrypt them on the fly. Note that only String metadata are currently supported. Configuration \u00b6 You can specify the metadata that you want to encrypt with the option -encryptmetadata . For example, if your Android Manifest contains a meta-data element: <meta-data android:name= \"myKey\" android:value= \"sensitiveDataToBeEncrypted\" /> you can encrypt this metadata using: -encryptmetadata myKey Verification \u00b6 If you inspect the Android Manifest in the hardened release version of the application, you'll see that the metadata is nog longer present. In the hardened application code, the metadata retrieval code will be replaced with an encrypted version of the metadata value. More information \u00b6 -encryptmetadata Working sample project: samples/basic/MetadataEncryption Verification Implement a string encryption plugin to use your own encryption algorithm. Native library encryption \u00b6 Discussion \u00b6 By default, DexGuard already obfuscates the names of JNI functions inside native libraries. You can explicitly specify to further encrypt sensitive native libraries. DexGuard then encrypts them and your application will decrypt them on the fly. The encryption prevents static analysis of the native code and tampering with the libraries. Configuration \u00b6 You can specify the native library files that you want to encrypt with the option -encryptnativelibraries . For example: -encryptnativelibraries lib/*/libsecret.so The encrypted native library must be loaded using either a call to System.loadLibrary(string) or as a dependency of another encrypted native library. You can also add the lib/dexguard-nativeloader.aar as a dependency to your project to use a more secure way of loading your encrypted native libraries. If you include this dependency in an sdk you force your users who also use DexGuard to use this approach for their encrypted native libraries as well. Verification \u00b6 With the -verbose option, DexGuard prints out how many native library files it has encrypted. If you unpack encrypted native library files from the hardened release version of the application, you'll see that they have the same lengths as the original files, but encrypted contents instead of the usual ELF format. DexGuard will write the list of native libraries it encrypted to a file with the option -printnativelibraryencryption . More information \u00b6 -encryptnativelibraries Working sample project: samples/basic/NativeLibraryEncryption Verification Implement an encryption plugin to use your own encryption algorithm. Class encryption \u00b6 Discussion \u00b6 Name obfuscation, string encryption, reflection, asset encryption, resource encryption and native library encryption harden the code and resources against static analysis. Tamper detection and environment checks harden against dynamic analysis. Class encryption can provide another powerful layer over these techniques. It can completely hide the decryption code and reflection code, hardening it against static analysis and against tampering. Encrypting all classes is not technically possible and would add an excessive overhead. You should identify a number of sensitive classes and encrypt those. Typically, these are the classes that you have already hardened with other techniques. For instance, you should include your tamper detection code and the associated library classes. Configuration \u00b6 You can specify the classes that you want to encrypt with the option -encryptclasses : -encryptclasses com.example.MySecretClass, com.example.MySecretClass$* The second name in the list matches all inner classes of MySecretClass , since inner classes often also contain sensitive code. Verification \u00b6 With the -verbose option, DexGuard prints out how many classes it has encrypted. Applying a disassembler to the hardened release version of your application, you may find traces of string encryption, reflection, tamper detection, environment checks, and original code. After having added class encryption for classes that contain such code, it will no longer be visible or modifiable. DexGuard will write the list of classes it encrypted to a file with the option -printclassencryption . More information \u00b6 -encryptclasses Examples: Encrypting classes Working sample projects: samples/basic/ClassEncryption , samples/basic/TamperDetection , samples/basic/EnvironmentCheck Verification Summary: tuning obfuscation \u00b6 In summary, when you're protecting an application or a library, you first need to make sure that the code still works (in the presence of any reflection) and then you should harden the sensitive parts of the code. To make sure that the code still works, you may need to reduce the obfuscation of some code or resources. This generally means preserving code and resources with their original names, so reflective code can still access them by these names. If the code no longer works after obfuscation, you can temporarily add the option -addconfigurationdebugging to your DexGuard configuration. This will add extra debugging code to the processed code. If an error occurs at runtime due to shrinking or obfuscation, the application may print out DexGuard configuration suggestions to solve the issue on the application log. Do not use this option in release versions, as it adds obfuscation information to the processed code. To harden the application or library beyond the default name obfuscation, you should identify the sensitive parts and apply the various encryption options. These options aren't part of the default settings, because they may have some impact on performance. The following diagram summarizes the relevant options: Default obfuscation Android manifest (binary .xml) Name obfuscation Java byte code (.class) Name obfuscation Native code (.so) Name obfuscation Resources (.arsc) Name obfuscation Resource files (binary .xml, .png,...) Name obfuscation Assets (.txt,...) Name obfuscation Reducing obfuscation Android manifest (binary .xml) -keepresourcexmlattributenames Java byte code (.class) -keep -keepattributes Native code (.so) -keep -keepresourcefiles Resources (.arsc) -keepresources Resource files (binary .xml, .png,...) -keepresourcefiles Assets (.txt,...) -keepresourcefiles Adding obfuscation Android manifest (binary .xml) Java byte code (.class) -accessthroughreflection -obfuscatecode -encryptclasses -encryptstrings Native code (.so) -encryptnativelibraries Resources (.arsc) Resource files (binary .xml, .png,...) -encryptresourcefiles Assets (.txt,...) -encryptassetfiles If you want to go a step further, you can also create your own encryption plugins for DexGuard. Such plugins increase the variation in obfuscated code, making it more difficult for attackers to detect patterns. More information \u00b6 -pluginjars Working sample project: samples/advanced/EncryptionPlugins Javadoc of the plugins API: com.guardsquare.dexguard.encrypt","title":"Overview"},{"location":"protection.html#core-design","text":"","title":"Core design"},{"location":"protection.html#discussion","text":"The essential basis for a hardened application is a sound design and a robust implementation. Even if you will obfuscate your code, you should look at it as if it is open source and consider the worst-case scenarios. The details are application-specific and lie outside the scope of this guide, but you can find a lot of basic principles in books, blogs, and online presentations.","title":"Discussion"},{"location":"protection.html#more-information","text":"Android Security Cookbook , by Keith Makan and Scott Alexander-Bown. Android Security Internals , by Nikolay Elenkov. Android Hacker's Handbook , by Joshua J. Drake, Zach Lanier, Collin Mulliner, Pau Oliva Fora, Stephen A. Ridley, and Georg Wicherski.","title":"More information"},{"location":"protection.html#secure-communication","text":"","title":"Secure communication"},{"location":"protection.html#discussion_1","text":"If your application communicates with a server, you should encrypt the communication with SSL (Secure Sockets Layer) or the more recent TLS (Transport Layer Security). These protocols have been developed for secure communication between a web browser and a server. In a web browser, a user can see the padlock icon when the communication is secure. In an Android application, the user doesn't see a padlock icon, so the developer shouldn't forget to use SSL when appropriate. The server contains a chain of certificates with public keys and certified names. You can obtain a certificate from a Certificate Authority (CA). With the standard Android API, the Android runtime checks such a chain with its database of root certificates. Alternatively, you can create a self-signed certificate. You then need to check the certificate yourself in your application. Occasionally, a Certificate Authority is compromised (as happened with Comodo and DigiNotar). New releases of Android then typically update the database of root certificates. However, if your application always communicates with the same server, it should pin the certificate or its public key, i.e. only accept a minimal, fixed list of trusted certificates or keys. This technique ensures that the application is always talking to the right server and blocks man-in-the-middle attacks. You should be aware that some large websites update their certificates and keys regularly.","title":"Discussion"},{"location":"protection.html#configuration","text":"You can find the code to create connections with certificate pinning or public key pinning for different Android APIs in the sample samples/basic/SSLPinning .","title":"Configuration"},{"location":"protection.html#verification","text":"Certificate pinning: remove your trust store from the assets. The server requests should no longer work. Public key pinning: change your list of trusted hashes. The server requests should no longer work.","title":"Verification"},{"location":"protection.html#more-information_1","text":"Working sample project: samples/basic/SSLPinning","title":"More information"},{"location":"protection.html#name-obfuscation","text":"","title":"Name obfuscation"},{"location":"protection.html#discussion_2","text":"DexGuard obfuscates the names of identifiers in the applications that it processes. This means that it renames resource files, resources, classes, fields, and methods using meaningless names, where possible. This obfuscation step makes the code base smaller and harder to reverse-engineer.","title":"Discussion"},{"location":"protection.html#configuration_1","text":"In release builds, DexGuard automatically applies name obfuscation. DexGuard's default configuration already takes care of common entry points like the Android manifest, with all depending activities, intentions, resources, etc. Any code or third-party frameworks that rely on reflection may be confused by changing the names of classes, fields, methods, and even resources. If the code requires that they keep their original names, you should specify the proper -keep options and -keepresourcefiles options. DexGuard's default configuration helps by already providing tuned configuration for a number of common libraries and frameworks .","title":"Configuration"},{"location":"protection.html#verification_1","text":"DexGuard will write the mapping of original names to obfuscated names to a file with the option -printmapping . Such a mapping file may look like this: com.example.HelloWorldActivity -> com.example.HelloWorldActivity: 39:42:void onCreate(android.os.Bundle) -> onCreate com.example.Util -> o.\uff65: byte[] values -> \uff65 int doSomething(android.content.Context) -> \uff65 java.lang.String compute(android.content.Context) -> \u02ca Note that names from the Android runtime are not obfuscated, since obfuscating them would break the application. You can also see the obfuscated names if you disassemble the code with a tool like dexdump ( build-tools/20.0.0/dexdump in the Android SDK), or baksmali (free and open-source: code.google.com/p/smali/ ). In the debug version of the application, the names are still readable: Class descriptor : 'Lcom/example/Util; ... #0 : (in Lcom/example/Util;) name : 'values' ... In the hardened release version of the application, the names are obfuscated: Class descriptor : 'Lo/\uff65;' ... #0 : (in Lo/\uff65;) name : '\uff65' ...","title":"Verification"},{"location":"protection.html#more-information_2","text":"Keep Options for Code Keep Options for Resources Overview of Keep Options Verification","title":"More information"},{"location":"protection.html#string-encryption","text":"","title":"String encryption"},{"location":"protection.html#discussion_3","text":"String constants in the source code are still readable in the compiled application, with a disassembler like dexdump or baksmali, or a decompiler for Dalvik bytecode. You should let DexGuard encrypt sensitive string constants, so they become invisible to static analysis. Keys, tokens, communication-related strings, and log messages are all good candidates for encryption. Note that string encryption is actually a form of obfuscation, since the strings necessarily have to be decrypted at runtime.","title":"Discussion"},{"location":"protection.html#configuration_2","text":"You can apply string encryption with the option -encryptstrings . It offers a number of ways to specify the strings to be encrypted. The most common ones:","title":"Configuration"},{"location":"protection.html#obfuscate-the-specified-string-constant","text":"-encryptstrings class com.example.MyConstants { public static final java.lang.String SECRET_KEY ; } Be aware that the Java compiler already inlines final string constants wherever they are used in the code, which may be in other classes. They may have spread throughout the code before DexGuard processes it. With the above configuration, DexGuard encrypts these constants throughout the code, to provide the expected results.","title":"Obfuscate the specified string constant"},{"location":"protection.html#obfuscate-all-string-constants-actually-used-in-the-specified-class","text":"-encryptstrings class com.example.MySecretClass This configuration is convenient if you can identify one or more sensitive classes. All options accept wildcards. Technically, it is possible to encrypt all strings in all classes in the code, but this is generally not advisable for performance reasons. Note : When using companion objects in Kotlin, be aware that the Kotlin compiler stores any defined final string constants on the enclosing class and not on the generated MySecretClass$Companion class. class MySecretClass { companion object { val SECRET_KEY : String = \"...\" ; } } DexGuard can still encrypt these Strings just fine: -encryptstrings class com.example.MySecretClass { private final java.lang.String SECRET_KEY ; }","title":"Obfuscate all string constants actually used in the specified class"},{"location":"protection.html#verification_2","text":"With the -verbose option, DexGuard prints out how many strings it has encrypted. In the debug version of the application, you'll easily find the original strings with a disassembler. For instance: ... const-string v0, \"Hello world!\" In the release version of the application, encrypted strings should no longer be visible. DexGuard will write the list of strings it encrypted, grouped per class, to a file with the -printstringencryption option.","title":"Verification"},{"location":"protection.html#more-information_3","text":"-encryptstrings Examples: Encrypting strings Working sample project: samples/basic/StringEncryption Verification Implement an encryption plugin to use your own encryption algorithm.","title":"More information"},{"location":"protection.html#reflection","text":"","title":"Reflection"},{"location":"protection.html#discussion_4","text":"Name obfuscation can't change invocations of runtime classes, methods, and fields, since that would break the application's code. These invocations therefore remain conveniently readable in the disassembled or decompiled code. This provides attackers a lot of information about the structure and execution flow of the application. Especially for sensitive APIs, such as encryption and secure communication, you may want to make the code less readable by replacing the direct invocations by reflection. You can let DexGuard replace invocations by reflection and then encrypt the resulting strings. They then become difficult to find with static analysis.","title":"Discussion"},{"location":"protection.html#configuration_3","text":"For example, encrypt some invocations of the SecureRandom with the option -accessthroughreflection : -accessthroughreflection class java.security.SecureRandom { <init> (); int nextInt (); } You should combine reflection with string encryption. By adding the encryptstrings modifier: -accessthroughreflection , encryptstrings class java.security.SecureRandom { <init> (); int nextInt (); } you can additionally encrypt the strings that are created for the reflection. Alternatively, you can explicitly list the strings you want to encrypt: -encryptstrings \" java.security.SecureRandom \" , \" nextInt \" or encrypt all strings in a particular class: -encryptstrings class com.example.MySecretClass","title":"Configuration"},{"location":"protection.html#verification_3","text":"With the -verbose option, DexGuard prints out how much reflection it has added. In the debug version of the application, you'll easily find the original method invocation with a disassembler. For instance: ... new-instance v0, Ljava/security/SecureRandom; ... invoke-direct {v0}, Ljava/security/SecureRandom;.<init>:()V ... ... invoke-virtual {v0}, Ljava/security/SecureRandom;.nextInt:()I In the hardened release version of the application, you can check that any invocations that you have specified are no longer visible.","title":"Verification"},{"location":"protection.html#more-information_4","text":"-accessthroughreflection Examples: Adding reflection for sensitive APIs Working sample project: samples/basic/Reflection Verification","title":"More information"},{"location":"protection.html#codeobfuscation","text":"","title":"Code obfuscation"},{"location":"protection.html#discussion_5","text":"The previously outlined obfuscation techniques do not change the execution flow of the application. This allows an attacker to quite easily reconstruct java source code using a decompiler to further analyze or modify the application. You can let DexGuard obfuscate the application's code, which then becomes more difficult to reverse-engineer using decompilers or disassemblers.","title":"Discussion"},{"location":"protection.html#configuration_4","text":"You can apply code obfuscation with the option -obfuscatecode . It allows to specify a strength modifier which controls how aggressive the methods will be obfuscated. For example, obfuscate all methods of MyActivity with 'low' strength: -obfuscatecode , low class com.example.MyActivity The option accepts wildcards as well. For example, obfuscate all methods of all classes inside package com.example.secure with 'high' strength: -obfuscatecode , high class com.example.secure.**","title":"Configuration"},{"location":"protection.html#verification_4","text":"With the -verbose option, DexGuard prints out for how many methods it has obfuscated the code. Applying a decompiler to the debug version of your application will show java code that closely matches the original source code of the method. In the hardened release version of the application, decompilers will either completely fail to show corresponding source code, or display a highly obfuscated version which doesn't match the original execution flow anymore.","title":"Verification"},{"location":"protection.html#more-information_5","text":"-obfuscatecode Strength modifiers Working sample project: samples/basic/CodeObfuscation Verification","title":"More information"},{"location":"protection.html#codevirtualization","text":"","title":"Code virtualization"},{"location":"protection.html#discussion_6","text":"There are cases where Class Encryption cannot be used due to technical constraints (e.g. Activities referenced by the AndroidManifest) or when it is too heavy to efficiently use as a final protection layer, code obfuscation goes a long way to protect sensitive code from being decompiled. However some chunks of code are still readable and therefore vulnerable to both static and dynamic analysis. As a powerful final layer around method bodies, DexGuard can perform code virtualization. This technique injects an inlined virtual machine with a randomized instruction set into your application code and re-implements your methods with those instructions. Even though virtualized code can sometimes be decompiled successfully, the resulting method body bares no resemblance to your source code anymore. Note that Exceptions work fine with code virtualization, but line numbers in exception messages are not supported. When interpreting stacktraces passing through methods that have code virtualization applied, there are two possibilities. Either no numbers are displayed, or the device chooses to instead display the byte offset of the instruction that failed. In the latter case, the number will not correspond to any source code line number.","title":"Discussion"},{"location":"protection.html#configuration_5","text":"You can apply code virtualization with the option -virtualizecode . The code is first obfuscated with the low setting and then completely virtualized. For example, virtualize a proprietary algorithm in a method of class com.example.MyRecommender : -virtualizecode class com.example.MyRecommender { public java.lang.String [] recommendPopular (); } Due to technical constraints it is currently not possible to virtualize initializers (constructors, static initializers) or methods that use explicit synchronization blocks (however methods marked synchronized are supported).","title":"Configuration"},{"location":"protection.html#verification_5","text":"With the -verbose option, DexGuard prints out for how many methods it has applied code virtualization. Applying a decompiler to the debug version of your application will show java code that closely matches the original source code of the method. In the hardened release version of the application, decompilers will either completely fail to show the method's code, or display a code array followed by a partial interpreter in the form of a loop over a switch.","title":"Verification"},{"location":"protection.html#more-information_6","text":"-virtualizecode Working sample project: samples/basic/CodeVirtualization Verification","title":"More information"},{"location":"protection.html#removing-logging-code-and-stack-traces","text":"","title":"Removing logging code and stack traces"},{"location":"protection.html#discussion_7","text":"Logging code provides attackers information about the structure and execution flow of the application. From the perspective of thwarting reverse engineering, you should not leave logging code in released applications. If your logging code (or the logging code in your external libraries) does not depend on compile-time flags like Build.DEBUG , you can let DexGuard remove logging calls for you.","title":"Discussion"},{"location":"protection.html#configuration_6","text":"Remove all standard Android logging invocations: -assumenosideeffects class android.util.Log { public static boolean isLoggable ( java.lang.String , int ); public static int v ( ... ); public static int i ( ... ); public static int w ( ... ); public static int d ( ... ); public static int e ( ... ); public static java.lang.String getStackTraceString ( java.lang.Throwable ); } Remove all printing of stack traces: -assumenosideeffects class java.lang.Exception { public void printStackTrace (); }","title":"Configuration"},{"location":"protection.html#verification_6","text":"In the debug version of the application, you may find many logging invocations with a disassembler. For instance: ... invoke-static {v0, v1}, Landroid/util/Log;.d:(Ljava/lang/String;Ljava/lang/String;)I In the release version of the application, all of these invocation should be gone.","title":"Verification"},{"location":"protection.html#more-information_7","text":"-assumenosideeffects Examples: Removing logging code Working sample project: samples/basic/LoggingRemoval Verification","title":"More information"},{"location":"protection.html#tamper-detection","text":"","title":"Tamper detection"},{"location":"protection.html#discussion_8","text":"Attackers can extract information like encryption and decryption keys by injecting logging code into an application. They disassemble the application, insert logging code, and run the application again. Their logging code can print out decrypted strings, which include the keys. You can fight this type of dynamic analysis by adding tamper detection to your application. Tamper detection actively checks the integrity of the application at runtime and acts suitably if the application has been modified.","title":"Discussion"},{"location":"protection.html#configuration_7","text":"DexGuard offers tamper detection with simple methods that you can call from your application. You first need to add the library lib/dexguard-runtime.jar to your application. You can then invoke the tamper detection methods in the application and act based on their return values. Check the integrity of the entire apk file: int check = TamperDetector . checkApk ( context ); if ( check != 0 ) { // Tampering detected. // ... } Check whether the application is still signed with the original certificate: int check = CertificateChecker . checkCertificate ( context ); if ( check != 0 ) { // Different certificate detected. // ... } Check whether one or more specific files of the apk file have been modified: FileChecker fileChecker = new FileChecker ( context ); int check = 0 check ^= fileChecker . checkFile ( file1 ); check ^= fileChecker . checkFile ( file2 ); // ... if ( check != 0 ) { // Different files detected. // ... } All methods accept an optional additional integer parameter, which they return instead of 0 if the checks are ok. You can pick such a parameter to make the code less predictable. You should weave the tamper detection code into your regular code, making it more difficult to simply disable it. For instance, you could use the return value to affect the computation of a key, so the computed key is wrong if the application has been tampered with. A simplistic example: int checkedKey = TamperDetector . checkApk ( context , key ); If the code detects tampering, the application should fail quietly, possibly with a delay, without giving away any further information. Once you have added your tamper detection code, you should further harden it by encrypting its class, together with the tamper detection library ( com.guardsquare.dexguard.runtime.** ).","title":"Configuration"},{"location":"protection.html#verification_7","text":"You can check if the tamper detection works by unpacking the application and repackaging it, for instance with unzip and zip. You can also tamper with the application simply by applying the standard tool zipalign: zipalign -f 4 myapplication.apk The tool repackages the application without fundamentally changing it. This will trigger the tamper detection at runtime. You can check the certificate verification by re-signing the application with a different certificate: zip -d MyApp.apk META-INF/* jarsigner -keystore debug.keystore -storepass android -keypass android -signedjar \\ MyApp_signed.apk MyApp.apk AndroidDebugKey This will trigger the certificate check at runtime.","title":"Verification"},{"location":"protection.html#more-information_8","text":"Working sample project: samples/basic/TamperDetection Javadoc of the API: com.guardsquare.dexguard.runtime.detection .","title":"More information"},{"location":"protection.html#environment-checks","text":"","title":"Environment checks"},{"location":"protection.html#discussion_9","text":"Even if the application is unaltered, the underlying runtime may be subverted. The application calls into the Android runtime in good faith, but the runtime code may have been compromised. It may for instance intercept method calls that communicate or decrypt sensitive data, and pass the results to an attacker. You may therefore want to check the environment in which the application is running. This is tricky, since the subverted environment may be constructed to look as ordinary and inconspicuous as possible. Nevertheless, you can perform some basic sanity checks: Check whether the application is debuggable or is being debugged. Check whether the application is running in an emulator. Check whether the application is running on a rooted device. Check whether the application is being hooked with specialized tools like Xposed, Substrate or Frida. Like tamper detection, these techniques actively check the integrity of the application and its environment at runtime. You can then act suitably if the environment is not the standard intended environment.","title":"Discussion"},{"location":"protection.html#configuration_8","text":"DexGuard offers environment checks as simple methods that you can call from your application. You first need to add the library samples/basic/EnvironmentCheck/libs/dexguard-runtime.jar to your application. You can then invoke the environment checking methods in the application and act based on their return values. Check whether the application is debuggable: int check = DebugDetector . isDebuggable ( context ); if ( check != 0 ) { // Application is debuggable. // ... } Check whether the application is being debugged: int check = DebugDetector . isDebuggerConnected (); if ( check != 0 ) { // Application is being debugged. ... } Check whether the application has been signed with a debug key: int check = DebugDetector . isSignedWithDebugKey ( context ); if ( check != 0 ) { // Application has been signed with a debug key. // ... } Check whether the application is running in an emulator: int check = EmulatorDetector . isRunningInEmulator ( context ); if ( check != 0 ) { // Application is running in an emulator. // ... } Check whether the application is running on a rooted device: int check = RootDetector . isDeviceRooted ( context ); if ( check != 0 ) { // Application is running on a rooted device. ... } Check whether the application is being hooked: int check = HookDetector . isApplicationHooked (); if ( check != 0 ) { // Application is being hooked. ... } All methods accept an optional additional integer parameter. which they return instead of 0 if the checks are ok. You can pick such a parameter to make the code less predictable. You should again weave the tamper detection code into your regular code and further harden it by encrypting the class together with the library ( com.guardsquare.dexguard.runtime.** ).","title":"Configuration"},{"location":"protection.html#verification_8","text":"If you have implemented these checks, you can try setting the debug flag, running the application in an emulator, or running the application on a rooted device.","title":"Verification"},{"location":"protection.html#more-information_9","text":"Working sample project: samples/basic/EnvironmentCheck Runtime Library Javadoc of the API: com.guardsquare.dexguard.runtime.detection .","title":"More information"},{"location":"protection.html#asset-encryption","text":"","title":"Asset encryption"},{"location":"protection.html#discussion_10","text":"By default, DexGuard leaves asset files untouched. You can explicitly specify to encrypt sensitive asset files. DexGuard then encrypts them and your application will decrypt them on the fly.","title":"Discussion"},{"location":"protection.html#configuration_9","text":"You can specify the asset files that you want to encrypt with the option -encryptassetfiles . For example: -encryptassetfiles assets/secret.txt DexGuard only encrypts asset files that are read with an AssetManager and open(\"secret.txt\") , with a literal string as argument..","title":"Configuration"},{"location":"protection.html#verification_9","text":"With the -verbose option, DexGuard prints out how many asset files it has encrypted. If you unpack encrypted asset files from the hardened release version of the application, you'll see that they have the same lengths as the original files, but encrypted contents.","title":"Verification"},{"location":"protection.html#more-information_10","text":"-encryptassetfiles Working sample project: samples/basic/AssetEncryption Verification Implement an encryption plugin to use your own encryption algorithm.","title":"More information"},{"location":"protection.html#resource-file-encryption","text":"","title":"Resource file encryption"},{"location":"protection.html#discussion_11","text":"By default, DexGuard leaves resource files untouched. You can explicitly specify to encrypt sensitive resource files. DexGuard then encrypts them and your application will decrypt them on the fly. Only applicable when processing Android applications. Only applicable to APKs, this feature is not supported for app bundles.","title":"Discussion"},{"location":"protection.html#configuration_10","text":"You can specify the resource files that you want to encrypt with the option -encryptresourcefiles . For example: -encryptresourcefiles res/layout*/secret.xml DexGuard can encrypt resources in res/layout , res/menu and res/xml .","title":"Configuration"},{"location":"protection.html#verification_10","text":"With the -verbose option, DexGuard prints out how many resource files it has encrypted. If you unpack encrypted resource files from the hardened release version of the application, you'll see that they can no longer be viewed with an Android binary XML viewer like aapt. DexGuard will write the list of resources it encrypted to a file with the option -printresourceencryption .","title":"Verification"},{"location":"protection.html#more-information_11","text":"-encryptresourcefiles Working sample project: samples/basic/ResourceEncryption Verification Implement an encryption plugin to use your own encryption algorithm.","title":"More information"},{"location":"protection.html#javascriptobfuscation","text":"","title":"Javascript obfuscation"},{"location":"protection.html#discussion_12","text":"By default, DexGuard leaves JavaScript files largely untouched, and optionally adapts its contents with information about the obfuscated Java elements. You can explicitly specify to obfuscate JavaScript files using DexGuard's built-in JavaScript obfuscator.","title":"Discussion"},{"location":"protection.html#configuration_11","text":"You can specify the Javascript files that you want to obfuscate with the option -obfuscatejavascript . For example: -obfuscatejavascript assets/www/secret/**.js You can specify a Javascript configuration with the option -javascriptconfiguration configuration.yml Please refer to the separate Javascript obfuscator manual for more details on obfuscation options.","title":"Configuration"},{"location":"protection.html#verification_11","text":"If you unpack the hardened release version of the application, you'll see that the JavaScript file contents are obfuscated according to the specified obfuscation configuration.","title":"Verification"},{"location":"protection.html#more-information_12","text":"Javascript obfuscator manual Working sample project: samples/basic/JavaScript Verification","title":"More information"},{"location":"protection.html#resource-string-encryption","text":"","title":"Resource string encryption"},{"location":"protection.html#discussion_13","text":"By default, DexGuard only inlines resource strings. You can explicitly specify to encrypt sensitive resource strings. DexGuard then encrypts them and your application will decrypt them on the fly. Only applicable when processing Android applications.","title":"Discussion"},{"location":"protection.html#configuration_12","text":"You can specify the resource strings that you want to encrypt with the option -encryptresources . For example: -encryptresources string/message will encrypt the resource string with resource name message .","title":"Configuration"},{"location":"protection.html#verification_12","text":"With the -verbose option, DexGuard prints out how many resource strings it has encrypted. If you read resource strings from the hardened release version of the application using a tool like aapt , you'll see that they will be encrypted. DexGuard will write the list of resources it encrypted to a file with the option -printresourceencryption .","title":"Verification"},{"location":"protection.html#more-information_13","text":"-encryptresources Working sample project: samples/basic/ResourceEncryption Verification Implement an encryption plugin to use your own encryption algorithm.","title":"More information"},{"location":"protection.html#metadata-encryption","text":"","title":"Metadata encryption"},{"location":"protection.html#discussion_14","text":"By default, DexGuard only inlines metadata in the Android Manifest. You can explicitly specify to encrypt sensitive metadata. DexGuard then both inlines and encrypts them, and your application will decrypt them on the fly. Note that only String metadata are currently supported.","title":"Discussion"},{"location":"protection.html#configuration_13","text":"You can specify the metadata that you want to encrypt with the option -encryptmetadata . For example, if your Android Manifest contains a meta-data element: <meta-data android:name= \"myKey\" android:value= \"sensitiveDataToBeEncrypted\" /> you can encrypt this metadata using: -encryptmetadata myKey","title":"Configuration"},{"location":"protection.html#verification_13","text":"If you inspect the Android Manifest in the hardened release version of the application, you'll see that the metadata is nog longer present. In the hardened application code, the metadata retrieval code will be replaced with an encrypted version of the metadata value.","title":"Verification"},{"location":"protection.html#more-information_14","text":"-encryptmetadata Working sample project: samples/basic/MetadataEncryption Verification Implement a string encryption plugin to use your own encryption algorithm.","title":"More information"},{"location":"protection.html#native-library-encryption","text":"","title":"Native library encryption"},{"location":"protection.html#discussion_15","text":"By default, DexGuard already obfuscates the names of JNI functions inside native libraries. You can explicitly specify to further encrypt sensitive native libraries. DexGuard then encrypts them and your application will decrypt them on the fly. The encryption prevents static analysis of the native code and tampering with the libraries.","title":"Discussion"},{"location":"protection.html#configuration_14","text":"You can specify the native library files that you want to encrypt with the option -encryptnativelibraries . For example: -encryptnativelibraries lib/*/libsecret.so The encrypted native library must be loaded using either a call to System.loadLibrary(string) or as a dependency of another encrypted native library. You can also add the lib/dexguard-nativeloader.aar as a dependency to your project to use a more secure way of loading your encrypted native libraries. If you include this dependency in an sdk you force your users who also use DexGuard to use this approach for their encrypted native libraries as well.","title":"Configuration"},{"location":"protection.html#verification_14","text":"With the -verbose option, DexGuard prints out how many native library files it has encrypted. If you unpack encrypted native library files from the hardened release version of the application, you'll see that they have the same lengths as the original files, but encrypted contents instead of the usual ELF format. DexGuard will write the list of native libraries it encrypted to a file with the option -printnativelibraryencryption .","title":"Verification"},{"location":"protection.html#more-information_15","text":"-encryptnativelibraries Working sample project: samples/basic/NativeLibraryEncryption Verification Implement an encryption plugin to use your own encryption algorithm.","title":"More information"},{"location":"protection.html#classencryption","text":"","title":"Class encryption"},{"location":"protection.html#discussion_16","text":"Name obfuscation, string encryption, reflection, asset encryption, resource encryption and native library encryption harden the code and resources against static analysis. Tamper detection and environment checks harden against dynamic analysis. Class encryption can provide another powerful layer over these techniques. It can completely hide the decryption code and reflection code, hardening it against static analysis and against tampering. Encrypting all classes is not technically possible and would add an excessive overhead. You should identify a number of sensitive classes and encrypt those. Typically, these are the classes that you have already hardened with other techniques. For instance, you should include your tamper detection code and the associated library classes.","title":"Discussion"},{"location":"protection.html#configuration_15","text":"You can specify the classes that you want to encrypt with the option -encryptclasses : -encryptclasses com.example.MySecretClass, com.example.MySecretClass$* The second name in the list matches all inner classes of MySecretClass , since inner classes often also contain sensitive code.","title":"Configuration"},{"location":"protection.html#verification_15","text":"With the -verbose option, DexGuard prints out how many classes it has encrypted. Applying a disassembler to the hardened release version of your application, you may find traces of string encryption, reflection, tamper detection, environment checks, and original code. After having added class encryption for classes that contain such code, it will no longer be visible or modifiable. DexGuard will write the list of classes it encrypted to a file with the option -printclassencryption .","title":"Verification"},{"location":"protection.html#more-information_16","text":"-encryptclasses Examples: Encrypting classes Working sample projects: samples/basic/ClassEncryption , samples/basic/TamperDetection , samples/basic/EnvironmentCheck Verification","title":"More information"},{"location":"protection.html#summary-tuning-obfuscation","text":"In summary, when you're protecting an application or a library, you first need to make sure that the code still works (in the presence of any reflection) and then you should harden the sensitive parts of the code. To make sure that the code still works, you may need to reduce the obfuscation of some code or resources. This generally means preserving code and resources with their original names, so reflective code can still access them by these names. If the code no longer works after obfuscation, you can temporarily add the option -addconfigurationdebugging to your DexGuard configuration. This will add extra debugging code to the processed code. If an error occurs at runtime due to shrinking or obfuscation, the application may print out DexGuard configuration suggestions to solve the issue on the application log. Do not use this option in release versions, as it adds obfuscation information to the processed code. To harden the application or library beyond the default name obfuscation, you should identify the sensitive parts and apply the various encryption options. These options aren't part of the default settings, because they may have some impact on performance. The following diagram summarizes the relevant options: Default obfuscation Android manifest (binary .xml) Name obfuscation Java byte code (.class) Name obfuscation Native code (.so) Name obfuscation Resources (.arsc) Name obfuscation Resource files (binary .xml, .png,...) Name obfuscation Assets (.txt,...) Name obfuscation Reducing obfuscation Android manifest (binary .xml) -keepresourcexmlattributenames Java byte code (.class) -keep -keepattributes Native code (.so) -keep -keepresourcefiles Resources (.arsc) -keepresources Resource files (binary .xml, .png,...) -keepresourcefiles Assets (.txt,...) -keepresourcefiles Adding obfuscation Android manifest (binary .xml) Java byte code (.class) -accessthroughreflection -obfuscatecode -encryptclasses -encryptstrings Native code (.so) -encryptnativelibraries Resources (.arsc) Resource files (binary .xml, .png,...) -encryptresourcefiles Assets (.txt,...) -encryptassetfiles If you want to go a step further, you can also create your own encryption plugins for DexGuard. Such plugins increase the variation in obfuscated code, making it more difficult for attackers to detect patterns.","title":"Summary: tuning obfuscation"},{"location":"protection.html#more-information_17","text":"-pluginjars Working sample project: samples/advanced/EncryptionPlugins Javadoc of the plugins API: com.guardsquare.dexguard.encrypt","title":"More information"},{"location":"protectionreport.html","text":"With every build, DexGuard automatically produces a very interactive html report that will enable you to continuously assess and improve protection of your app or SDK. The file's name is protectionreport.html and it is located in your standard build output folder, as described here . The Protection Report has three main components: Key technical risk assessment metrics. Protection status and impact overview. Custom-tailored configuration advice . Risk Assessment \u00b6 The risk assessment scores are important indicators of the robustness of the applied code hardening and RASP and can be used to verify and validate the applied protection before releasing the mobile application or SDK. The protection KPIs can be expanded to have a more detailed overview. This detailed overview helps you to quickly assess whether you're applying the right protection measures against major risks. The assessment assigns a score to the current protection configuration indicating its effectiveness against these five risk categories: Capabilities and monetization : the level of protection against app limitation exploits, like unlocking of premium features. Cloning / repackaging protection : avoiding repackaged app clones. Data leak and data forgery safety : the level of protection against theft of app secrets and personally identifiable information (PII). Environment safety : protection against a compromised environment, often a precondition to start tampering your app. IP safety : the level of protection against reverse engineering of your app. After expanding the KPI details, the Protection Report indicates for each category which actions you can take to improve the effectiveness of the applied app protection. The feature breakdown indicates which of DexGuard's product features contribute to the KPI: the green ones are correctly applied, the red ones are either not yet applied or scoring for it is very low, and for the orange ones there is some configuration advice. Just click on them to learn more. It is recommended to focus on the specific categories that are most relevant for your use-case or industry. Protection Status \u00b6 The protection status section will help you understand which features are used and how they have been applied. It will help you get insight in to effectiveness of your configuration and assist you in spotting pitfalls. Additionally, it lets you uncover the features that are currently not in use with a link to the relevant manual page. This includes new features added in later releases that you might not have considered yet. It will help you leverage all of DexGuard's protection capabilities to effectively protect your mobile assets. Configuration Advice \u00b6 The configuration advice makes the information provided in the previous sections actionable and guides you towards a more optimal configuration. The advice and best practices are custom-tailored based on analysis of your app ass well as on expert knowledge and hands-on experience by our teams. Filters \u00b6 The configuration advice section will help you understand how your filters affect the obfuscated result. It points out some common mistakes, like: Ineffective Filters \u00b6 These are filters that didn't match anything. Note the typo in Util below. Catchall Filters \u00b6 These are filters that match everything and might require more fine-tuning. Suppress Advice \u00b6 If certain advice is not applicable to you, you can suppress it in future reports. When clicking the Suppress advice? icon, an entry with a -dontnote option is copied to you clipboard, which you can then paste in your DexGuard configuration file.","title":"Protection Report"},{"location":"protectionreport.html#risk-assessment","text":"The risk assessment scores are important indicators of the robustness of the applied code hardening and RASP and can be used to verify and validate the applied protection before releasing the mobile application or SDK. The protection KPIs can be expanded to have a more detailed overview. This detailed overview helps you to quickly assess whether you're applying the right protection measures against major risks. The assessment assigns a score to the current protection configuration indicating its effectiveness against these five risk categories: Capabilities and monetization : the level of protection against app limitation exploits, like unlocking of premium features. Cloning / repackaging protection : avoiding repackaged app clones. Data leak and data forgery safety : the level of protection against theft of app secrets and personally identifiable information (PII). Environment safety : protection against a compromised environment, often a precondition to start tampering your app. IP safety : the level of protection against reverse engineering of your app. After expanding the KPI details, the Protection Report indicates for each category which actions you can take to improve the effectiveness of the applied app protection. The feature breakdown indicates which of DexGuard's product features contribute to the KPI: the green ones are correctly applied, the red ones are either not yet applied or scoring for it is very low, and for the orange ones there is some configuration advice. Just click on them to learn more. It is recommended to focus on the specific categories that are most relevant for your use-case or industry.","title":"Risk Assessment"},{"location":"protectionreport.html#protection-status","text":"The protection status section will help you understand which features are used and how they have been applied. It will help you get insight in to effectiveness of your configuration and assist you in spotting pitfalls. Additionally, it lets you uncover the features that are currently not in use with a link to the relevant manual page. This includes new features added in later releases that you might not have considered yet. It will help you leverage all of DexGuard's protection capabilities to effectively protect your mobile assets.","title":"Protection Status"},{"location":"protectionreport.html#configuration-advice","text":"The configuration advice makes the information provided in the previous sections actionable and guides you towards a more optimal configuration. The advice and best practices are custom-tailored based on analysis of your app ass well as on expert knowledge and hands-on experience by our teams.","title":"Configuration Advice"},{"location":"protectionreport.html#filters","text":"The configuration advice section will help you understand how your filters affect the obfuscated result. It points out some common mistakes, like:","title":"Filters"},{"location":"protectionreport.html#ineffective-filters","text":"These are filters that didn't match anything. Note the typo in Util below.","title":"Ineffective Filters"},{"location":"protectionreport.html#catchall-filters","text":"These are filters that match everything and might require more fine-tuning.","title":"Catchall Filters"},{"location":"protectionreport.html#suppress-advice","text":"If certain advice is not applicable to you, you can suppress it in future reports. When clicking the Suppress advice? icon, an entry with a -dontnote option is copied to you clipboard, which you can then paste in your DexGuard configuration file.","title":"Suppress Advice"},{"location":"quickstart.html","text":"This page will guide you through the basic steps of processing your application or library with DexGuard. For details on advanced settings or more background information please refer to the relevant parts of the manual. The following actions are involved in order to achieve a basic setup: Set up your license file . Set up the Gradle plugin or run DexGuard from the command line . Install the obfuscated build on a test device and thoroughly test all features . Improve the protection of your application or library by using the guidelines from our Protection Report. If you are upgrading from DexGuard 8.x or ProGuard, please consult the upgrading guide . Setting up your license file \u00b6 With your provided credentials, you can log in to the Guardsquare website , where you can download your DexGuard software as well as the license file dexguard-license.txt . DexGuard will look for it in one of the following locations: in the Gradle plugin block with the license option (either a directory path or a file path). in the path that you can specify with the Java system property dexguard.license (either a directory path or a file path). in the path that you can specify with the OS environment variable DEXGUARD_LICENSE (either a directory path or a file path) in your home directory If a license file dexguard-license.txt in any of the above directories is somehow not valid for your project, DexGuard will try falling back on dexguard-license2.txt , dexguard-license3.txt , etc. Running DexGuard \u00b6 Executing DexGuard can be done in 2 modes of operation: integrated in the Gradle build process from the command line in standalone mode Gradle build \u00b6 DexGuard can be integrated into the Android Gradle build process by using the DexGuard Gradle plugin : Groovy build.gradle buildscript { repositories { google () mavenCentral () maven { url '/path/to/DexGuard/lib' } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' classpath 'com.guardsquare:dexguard-gradle-plugin:+' } } app/build.gradle apply plugin: 'com.android.application' apply plugin: 'dexguard' android { ... } dexguard { path = '/path/to/DexGuard' license = '/path/to/dexguard_license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } } Kotlin build.gradle.kts buildscript { repositories { google () mavenCentral () maven { url = uri ( \"/path/to/DexGuard/lib\" ) } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) classpath ( \"com.guardsquare:dexguard-gradle-plugin:+\" ) } } app/build.gradle.kts plugins { id ( \"com.android.application\" ) id ( \"dexguard\" ) } android { ... } dexguard { path = \"/path/to/DexGuard\" license = \"/path/to/dexguard_license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } } When you execute the assemble or bundle tasks DexGuard will be automatically executed, for the configured variants. You can find the protected applications, bundles or libraries alongside the unprotected artefacts in the build/outputs directory, where they have a -protected suffix in the name. install task The usual Android Gradle Plugin install task will install the unprotected application, instead you can use adb e.g. adb install build/outputs/apk/release/MyApp-release-protected.apk . Standalone mode \u00b6 DexGuard can be executed directly from the command line by calling a script that can be found in the bin directory: Linux/macOS bin/dexguard.sh -injars path/to/my-application.apk \\ -outjars path/to/obfuscated-application.apk \\ -libraryjars path/to/android/sdk/platforms/android-XX/android.jar \\ -include /lib/dexguard-release.pro Windows bin\\dexguard -injars path\\to\\my-application.apk ^ -outjars path\\to\\obfuscated-application.apk ^ -libraryjars path\\to\\android\\sdk\\platforms\\android-XX\\android.jar ^ -include /lib/dexguard-release.pro Your application or library will likely require some more configuration to run successfully. For a more complete overview on this topic, refer to the DexGuard standalone page. Test and Verify \u00b6 We recommend to thoroughly test your obfuscated application's functionality on an emulator or device and verify the obfuscation results. For the latter please consult the relevant Feature section for the specifics on how to verify the results of each technique. While testing the protected application you might potentially run into some issues. This manual contains a section dedicated to runtime troubleshooting with details and debugging techniques. Enhance protection \u00b6 Once you have a fully operational and basic protected build of your application, we recommend to further enhance the security of your application or library by following the recommendations on which features to additionally enable, as made in the generated Protection Report .","title":"Quick Start"},{"location":"quickstart.html#setting-up-your-license-file","text":"With your provided credentials, you can log in to the Guardsquare website , where you can download your DexGuard software as well as the license file dexguard-license.txt . DexGuard will look for it in one of the following locations: in the Gradle plugin block with the license option (either a directory path or a file path). in the path that you can specify with the Java system property dexguard.license (either a directory path or a file path). in the path that you can specify with the OS environment variable DEXGUARD_LICENSE (either a directory path or a file path) in your home directory If a license file dexguard-license.txt in any of the above directories is somehow not valid for your project, DexGuard will try falling back on dexguard-license2.txt , dexguard-license3.txt , etc.","title":"Setting up your license file"},{"location":"quickstart.html#running-dexguard","text":"Executing DexGuard can be done in 2 modes of operation: integrated in the Gradle build process from the command line in standalone mode","title":"Running DexGuard"},{"location":"quickstart.html#gradle-build","text":"DexGuard can be integrated into the Android Gradle build process by using the DexGuard Gradle plugin : Groovy build.gradle buildscript { repositories { google () mavenCentral () maven { url '/path/to/DexGuard/lib' } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' classpath 'com.guardsquare:dexguard-gradle-plugin:+' } } app/build.gradle apply plugin: 'com.android.application' apply plugin: 'dexguard' android { ... } dexguard { path = '/path/to/DexGuard' license = '/path/to/dexguard_license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } } Kotlin build.gradle.kts buildscript { repositories { google () mavenCentral () maven { url = uri ( \"/path/to/DexGuard/lib\" ) } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) classpath ( \"com.guardsquare:dexguard-gradle-plugin:+\" ) } } app/build.gradle.kts plugins { id ( \"com.android.application\" ) id ( \"dexguard\" ) } android { ... } dexguard { path = \"/path/to/DexGuard\" license = \"/path/to/dexguard_license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } } When you execute the assemble or bundle tasks DexGuard will be automatically executed, for the configured variants. You can find the protected applications, bundles or libraries alongside the unprotected artefacts in the build/outputs directory, where they have a -protected suffix in the name. install task The usual Android Gradle Plugin install task will install the unprotected application, instead you can use adb e.g. adb install build/outputs/apk/release/MyApp-release-protected.apk .","title":"Gradle build"},{"location":"quickstart.html#standalone-mode","text":"DexGuard can be executed directly from the command line by calling a script that can be found in the bin directory: Linux/macOS bin/dexguard.sh -injars path/to/my-application.apk \\ -outjars path/to/obfuscated-application.apk \\ -libraryjars path/to/android/sdk/platforms/android-XX/android.jar \\ -include /lib/dexguard-release.pro Windows bin\\dexguard -injars path\\to\\my-application.apk ^ -outjars path\\to\\obfuscated-application.apk ^ -libraryjars path\\to\\android\\sdk\\platforms\\android-XX\\android.jar ^ -include /lib/dexguard-release.pro Your application or library will likely require some more configuration to run successfully. For a more complete overview on this topic, refer to the DexGuard standalone page.","title":"Standalone mode"},{"location":"quickstart.html#test-and-verify","text":"We recommend to thoroughly test your obfuscated application's functionality on an emulator or device and verify the obfuscation results. For the latter please consult the relevant Feature section for the specifics on how to verify the results of each technique. While testing the protected application you might potentially run into some issues. This manual contains a section dedicated to runtime troubleshooting with details and debugging techniques.","title":"Test and Verify"},{"location":"quickstart.html#enhance-protection","text":"Once you have a fully operational and basic protected build of your application, we recommend to further enhance the security of your application or library by following the recommendations on which features to additionally enable, as made in the generated Protection Report .","title":"Enhance protection"},{"location":"rasp.html","text":"Runtime Application Self-Protection (RASP) \u00b6 Runtime application self-protection or RASP enables applications and libraries to defend themselves against analysis and attacks at runtime. The various RASP checks monitor, at runtime, the integrity of the application or library and its execution environment. There are two ways to add RASP to a project using DexGuard: Automatically injecting the checks: this option is the easiest way to add RASP to your project and due to the randomness upon every build, this option is inherently more resilient against reverse engineering. Manually adding checks using the DexGuard Runtime Library : this gives you complete control over the location of RASP checks but requires you to manually add code throughout your project; this option is best if you need more control. If you're already a user of the DexGuard Runtime Library you can enable automatic RASP checks but these checks are independent of your original checks. However, using both options together might result in a performance hit because more RASP checks will be added to your project compared to using just one option. If your project performed some action when you detected a threat you should now configure a callback to perform the same action for the automatic checks. Quick start for automatic RASP \u00b6 Enabling automatic RASP support for a project requires: Adding the necessary configuration file to your Gradle build configuration. Enabling the desired checks in your DexGuard configuration. Specifying a reaction, either a callback or enabling ThreatCast reporting. By default, a detected threat will cause the application or library to crash for some categories of threats . The sample project named RASP in the samples/basic folder of the DexGuard release zip demonstrates the automatic injection of RASP checks in an application. The use of automatic RASP in libraries is demonstrated in the sample project RASPInLibraryProject . Add configuration file \u00b6 Add the dexguard-rasp.pro configuration file in addition to one of the usual default configuration files: Gradle plugin (Groovy) dexguard { path = 'path/to/dexguard/distribution' configurations { release { // Standard release configuration and the additional RASP configuration. defaultConfiguration 'dexguard-release.pro' // RASP default configuration defaultConfiguration 'dexguard-rasp.pro' // Your own configuration configuration 'dexguard-project.txt' } } } Gradle plugin (Kotlin) dexguard { path = \"path/to/dexguard/distribution\" configurations { register ( \"release\" ) { // Standard release configuration and the additional RASP configuration. defaultConfiguration ( \"dexguard-release.pro\" ) // RASP default configuration defaultConfiguration ( \"dexguard-rasp.pro\" ) // Your own configuration configuration ( \"dexguard-project.txt\" ) } } } Standalone # Standard release configuration and the additional RASP configuration. -include /lib/dexguard-release.pro # RASP default configuration -include /lib/dexguard-rasp.pro # Your own configuration -injars your-app.apk -outjars your-app-protected.apk -libraryjars .. . -keep class com.example.MyClass Enable checks \u00b6 By default, all RASP checks are disabled. To enable them, you can use the -raspchecks option in your configuration. The option takes a list of one or more RASP detectors. For example, to enable APK tamper and emulator detectors, add the following to your DexGuard configuration: -raspchecks emulator,apktamper Warning It is not possible to enable apktamper in an Android Library. You can prefix a detector name with ! to disable that detector but enable others. For example, the following enables all detectors except the APK tamper detector: - raspchecks ! apktamper You can also use a * wildcard to enable all detectors or none to disable all detectors: # Enable all - raspchecks * # Disable all - raspchecks none # Disable all except emulator - raspchecks emulator By default, for some threat categories, the project will crash when a threat is detected. You can override this behaviour with the -raspcontinueon option in your configuration. For example, if you just wish to report an APK tampering threat without crashing, you can allow the execution to continue normally by adding the following to your DexGuard configuration: - raspcontinueon apktamper The full list of tamper detectors is shown in the table below and detailed information on each of these can be found here . You can also find example configurations in the samples RASP and RASPInLibraryProject in the samples/basic folder. Some detectors will be triggered if the app or library is re-signed (for example, if you enable Google Play store signing) - the table indicates which detectors are safe to use in this case. Detector Name Config Name Default Threat Behaviour Safe from Re-Signing Tamper Detector apktamper Crash No Certificate Checker certificatetamper Crash Yes, as long as a certificate hash is provided with the option -raspcertificatehash File Checker filetamper Crash Yes, as long as a list of files are provided with the option -raspfiletamperlist debug Detector debug Crash Yes emulator Detector emulator Crash Yes hook Detector hook Continue Yes root Detector root Continue Yes Virtual Environment Detector virtualenvironment Continue Yes You can use the negation and * wildcard with -raspcontinueon too: # Don't crash on any threat categories - raspcontinueon * # Crash on all threat categories - raspcontinueon none Warning The Android platform is extremely diverse in both hardware and software with some devices even being sold rooted by default. Although DexGuard's checks are carefully selected and tested based on all the input we see it might, on very rare occasions, happen to result in false positives. For this reason, root detection, virtual environment and hook detection checks are more likely than others to return false positives, wrongly indicating that a threat is present. Therefore, the dexguard-rasp.pro configuration contains -raspcontinueon hook,root,virtualenvironment as the default. See the Runtime Library documentation for more information. Configure callback \u00b6 Tip Guardsquare provides a free threat reporting tool, ThreatCast , that works seamlessly with automatic RASP support. A custom callback can be configured that will be executed when a threat is detected. The callback is executed in addition to the default crashing behaviour and will be executed before crashing. In order to add a callback, you must add a dependency to your project: Manual Download (Groovy) repositories { flatDir { dirs 'libs' } // For the DexGuard libraries. google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... compileOnly ( name: 'dexguard-rasp' , ext: 'jar' ) } You can find the dependency at the following locations: Dependency Location DexGuard RASP support library ${DexGuardInstallPath}/lib/dexguard-rasp.jar Manual Download (Kotlin) repositories { flatDir { dirs ( \"libs\" ) } // For the DexGuard libraries. google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... compileOnly ( mapOf ( \"name\" to \"dexguard-rasp\" , \"ext\" to \"jar\" ) } You can find the dependency at the following locations: Dependency Location DexGuard RASP support library ${DexGuardInstallPath}/lib/dexguard-rasp.jar Maven repositories { maven { // For the DexGuard libraries. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" authentication { basic ( BasicAuthentication ) } } google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... compileOnly 'com.guardsquare:dexguard-rasp:9.2.7' } A method such as the following myCallback method can be added: Java public class HelloWorldActivity extends Activity { // ... /** * This is an optional DexGuard RASP callback method. This signature must match. * * Any strings used in the callback will be automatically encrypted. * * @param detectionReport A detection report containing threat information. */ public static void myCallback ( DetectionReport detectionReport ) { // The type of threat detected can be checked. if ( detectionReport . isRunningInEmulator ()) { Log . i ( \"MyApp\" , \"Emulator detected\" ); } } } Kotlin class HelloWorldActivity : Activity () { // ... companion object { /** * This is an optional DexGuard RASP callback method. This signature must match. * * Any strings used in the callback will be automatically encrypted. * * @param detectionReport A detection report containing threat information. */ @JvmStatic fun myCallback ( detectionReport : DetectionReport ) { Log . i ( \"HelloWorldActivity\" , \"Threat detected\" ) // The type of threat detected can be checked. if ( detectionReport . isRunningInEmulator ) { Log . i ( \"HelloWorldActivity\" , \"Emulator Detected\" ) } } } } along with the following DexGuard configuration to set myCallback as the RASP callback method: - raspcallback class com.example.HelloWorldActivity { public static void myCallback ( com.guardsquare.dexguard.rasp.callback.DetectionReport ); } Note The method must be static and have the same parameter as in the example. You don't need a -keep rule for the method. The DetectionReport contains several methods that allow you to determine the type of threat. You can find the complete list in the DetectionReport JavaDoc . Tip The method getDebugInfo() contains encoded debugging information. If you're not using ThreatCast, we highly recommend that you log this value as it will be helpful for providing to Guardsquare support when diagnosing any problems. Checking Specific Files \u00b6 If the File Checker is enabled then by default all files will be checked for tampering. Instead, specific files can be checked by listing them in the DexGuard configuration. For example, the following snippet will cause the File Checker to check only assets/main.js and assets/secret.js . - raspfiletamperlist assets / main.js , assets / secret.js Warning The File Checker will be triggered if the application is modified by other tools after DexGuard. In these cases the files to check should be explicitly listed and there are some exceptions. This can occur, for example, with app bundles or Android libraries. In app bundles it is not possible to check the files resources.arsc , AndroidManifest.xml , or other xml files, since the Android bundletool still manipulates them when creating the final APK. In libraries, you can only enable file checking for asset files. Other files will be merged in when the Library is used in an APK. See the Runtime Library documentation for more details and additional limitations. Checking Specific Certificate Hash \u00b6 When using app signing by Google Play, Google manages and protects your app's signing key for you and signs your APKs on your behalf. In this case DexGuard does not know which signing key will be used and thus does not know which certificate hash should be used to detect resigning of your app. To circumvent this issue, you can provide the certificate hash of the signing key used by Google using the following option. The certificate hash can be provided with or without the colons. We only support the SHA-256 hash. - raspcertificatehash \" EB : B0 : FE : DF : 19 : 42 : A0 : 99 : B2 : 87 : C3 : DB : 00 : FF : 73 : 21 : 62 : 15 : 24 : 81 : AB : B2 : B6 : C7 : CB : CD : B2 : BA : 58 : 94 : A7 : 68 \" - raspcertificatehash \" EBB0FEDF1942A099B287C3DB00FF732162152481ABB2B6C7CBCDB2BA5894A768 \" You can find the certificate hash of the signing key used by Google on your Google Play console under the \"App Signing\" section. Performance \u00b6 Automatically injecting the checks could incur a performance cost as the checks themselves take time to process and enabling more checks might result in a higher performance cost. Adjusting the injection location \u00b6 To minimize the performance cost of the injected checks, override the class filters to exclude performance sensitive classes from injection. The -raspclassfilter configuration option determine into which classes the RASP checks will be injected. For example, if your app startup time is slowed down significantly, you can add the following to your configuration to exclude your startup activity from injection: - raspclassfilter class !com.example.StartupActivity Adjusting the amount of checks \u00b6 DexGuard randomly insert checks in all of the project's code. This will make it harder to remove all the RASP checks at the cost of performance and size. This trade-off can be influenced through the appropriate aggressiveness setting. The option is used with the detector name and an aggressiveness level: - raspaggressiveness detector level The available values for aggressiveness are: min , low , medium , high , max . For example, if you want to increase the amount of hook detection checks which are injected into your project's code, you can put the following in your DexGuard configuration: - raspaggressiveness hook high The default aggressiveness levels are listed in the table below: Detector Name Config Name Default Aggressiveness Tamper Detector apktamper medium Certificate Checker certificatetamper medium File Checker filetamper medium debug Detector debug medium emulator Detector emulator high hook Detector hook medium root Detector root medium Virtual Environment Detector virtualenvironment medium Verification \u00b6 You can get some basic feedback about which detectors were enabled and how many checks were injected with configuration option -verbose (and Gradle option --info to see the output). For more detailed information, in a Gradle build you can find the inject mapping in build/outputs/mapping/<variant_dir>/injectmapping.txt or you can add the following to your DexGuard configuration to print a list of RASP injections to a file: - printinjectmapping inject.txt The file will contain a mapping of which RASP checking code was injected into which method in your project. Warning The file format is not finalised and is subject to change.","title":"RASP"},{"location":"rasp.html#runtime-application-self-protection-rasp","text":"Runtime application self-protection or RASP enables applications and libraries to defend themselves against analysis and attacks at runtime. The various RASP checks monitor, at runtime, the integrity of the application or library and its execution environment. There are two ways to add RASP to a project using DexGuard: Automatically injecting the checks: this option is the easiest way to add RASP to your project and due to the randomness upon every build, this option is inherently more resilient against reverse engineering. Manually adding checks using the DexGuard Runtime Library : this gives you complete control over the location of RASP checks but requires you to manually add code throughout your project; this option is best if you need more control. If you're already a user of the DexGuard Runtime Library you can enable automatic RASP checks but these checks are independent of your original checks. However, using both options together might result in a performance hit because more RASP checks will be added to your project compared to using just one option. If your project performed some action when you detected a threat you should now configure a callback to perform the same action for the automatic checks.","title":"Runtime Application Self-Protection (RASP)"},{"location":"rasp.html#quick-start-for-automatic-rasp","text":"Enabling automatic RASP support for a project requires: Adding the necessary configuration file to your Gradle build configuration. Enabling the desired checks in your DexGuard configuration. Specifying a reaction, either a callback or enabling ThreatCast reporting. By default, a detected threat will cause the application or library to crash for some categories of threats . The sample project named RASP in the samples/basic folder of the DexGuard release zip demonstrates the automatic injection of RASP checks in an application. The use of automatic RASP in libraries is demonstrated in the sample project RASPInLibraryProject .","title":"Quick start for automatic RASP"},{"location":"rasp.html#add-configuration-file","text":"Add the dexguard-rasp.pro configuration file in addition to one of the usual default configuration files: Gradle plugin (Groovy) dexguard { path = 'path/to/dexguard/distribution' configurations { release { // Standard release configuration and the additional RASP configuration. defaultConfiguration 'dexguard-release.pro' // RASP default configuration defaultConfiguration 'dexguard-rasp.pro' // Your own configuration configuration 'dexguard-project.txt' } } } Gradle plugin (Kotlin) dexguard { path = \"path/to/dexguard/distribution\" configurations { register ( \"release\" ) { // Standard release configuration and the additional RASP configuration. defaultConfiguration ( \"dexguard-release.pro\" ) // RASP default configuration defaultConfiguration ( \"dexguard-rasp.pro\" ) // Your own configuration configuration ( \"dexguard-project.txt\" ) } } } Standalone # Standard release configuration and the additional RASP configuration. -include /lib/dexguard-release.pro # RASP default configuration -include /lib/dexguard-rasp.pro # Your own configuration -injars your-app.apk -outjars your-app-protected.apk -libraryjars .. . -keep class com.example.MyClass","title":"Add configuration file"},{"location":"rasp.html#enable-checks","text":"By default, all RASP checks are disabled. To enable them, you can use the -raspchecks option in your configuration. The option takes a list of one or more RASP detectors. For example, to enable APK tamper and emulator detectors, add the following to your DexGuard configuration: -raspchecks emulator,apktamper Warning It is not possible to enable apktamper in an Android Library. You can prefix a detector name with ! to disable that detector but enable others. For example, the following enables all detectors except the APK tamper detector: - raspchecks ! apktamper You can also use a * wildcard to enable all detectors or none to disable all detectors: # Enable all - raspchecks * # Disable all - raspchecks none # Disable all except emulator - raspchecks emulator By default, for some threat categories, the project will crash when a threat is detected. You can override this behaviour with the -raspcontinueon option in your configuration. For example, if you just wish to report an APK tampering threat without crashing, you can allow the execution to continue normally by adding the following to your DexGuard configuration: - raspcontinueon apktamper The full list of tamper detectors is shown in the table below and detailed information on each of these can be found here . You can also find example configurations in the samples RASP and RASPInLibraryProject in the samples/basic folder. Some detectors will be triggered if the app or library is re-signed (for example, if you enable Google Play store signing) - the table indicates which detectors are safe to use in this case. Detector Name Config Name Default Threat Behaviour Safe from Re-Signing Tamper Detector apktamper Crash No Certificate Checker certificatetamper Crash Yes, as long as a certificate hash is provided with the option -raspcertificatehash File Checker filetamper Crash Yes, as long as a list of files are provided with the option -raspfiletamperlist debug Detector debug Crash Yes emulator Detector emulator Crash Yes hook Detector hook Continue Yes root Detector root Continue Yes Virtual Environment Detector virtualenvironment Continue Yes You can use the negation and * wildcard with -raspcontinueon too: # Don't crash on any threat categories - raspcontinueon * # Crash on all threat categories - raspcontinueon none Warning The Android platform is extremely diverse in both hardware and software with some devices even being sold rooted by default. Although DexGuard's checks are carefully selected and tested based on all the input we see it might, on very rare occasions, happen to result in false positives. For this reason, root detection, virtual environment and hook detection checks are more likely than others to return false positives, wrongly indicating that a threat is present. Therefore, the dexguard-rasp.pro configuration contains -raspcontinueon hook,root,virtualenvironment as the default. See the Runtime Library documentation for more information.","title":"Enable checks"},{"location":"rasp.html#configure-callback","text":"Tip Guardsquare provides a free threat reporting tool, ThreatCast , that works seamlessly with automatic RASP support. A custom callback can be configured that will be executed when a threat is detected. The callback is executed in addition to the default crashing behaviour and will be executed before crashing. In order to add a callback, you must add a dependency to your project: Manual Download (Groovy) repositories { flatDir { dirs 'libs' } // For the DexGuard libraries. google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... compileOnly ( name: 'dexguard-rasp' , ext: 'jar' ) } You can find the dependency at the following locations: Dependency Location DexGuard RASP support library ${DexGuardInstallPath}/lib/dexguard-rasp.jar Manual Download (Kotlin) repositories { flatDir { dirs ( \"libs\" ) } // For the DexGuard libraries. google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... compileOnly ( mapOf ( \"name\" to \"dexguard-rasp\" , \"ext\" to \"jar\" ) } You can find the dependency at the following locations: Dependency Location DexGuard RASP support library ${DexGuardInstallPath}/lib/dexguard-rasp.jar Maven repositories { maven { // For the DexGuard libraries. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" authentication { basic ( BasicAuthentication ) } } google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... compileOnly 'com.guardsquare:dexguard-rasp:9.2.7' } A method such as the following myCallback method can be added: Java public class HelloWorldActivity extends Activity { // ... /** * This is an optional DexGuard RASP callback method. This signature must match. * * Any strings used in the callback will be automatically encrypted. * * @param detectionReport A detection report containing threat information. */ public static void myCallback ( DetectionReport detectionReport ) { // The type of threat detected can be checked. if ( detectionReport . isRunningInEmulator ()) { Log . i ( \"MyApp\" , \"Emulator detected\" ); } } } Kotlin class HelloWorldActivity : Activity () { // ... companion object { /** * This is an optional DexGuard RASP callback method. This signature must match. * * Any strings used in the callback will be automatically encrypted. * * @param detectionReport A detection report containing threat information. */ @JvmStatic fun myCallback ( detectionReport : DetectionReport ) { Log . i ( \"HelloWorldActivity\" , \"Threat detected\" ) // The type of threat detected can be checked. if ( detectionReport . isRunningInEmulator ) { Log . i ( \"HelloWorldActivity\" , \"Emulator Detected\" ) } } } } along with the following DexGuard configuration to set myCallback as the RASP callback method: - raspcallback class com.example.HelloWorldActivity { public static void myCallback ( com.guardsquare.dexguard.rasp.callback.DetectionReport ); } Note The method must be static and have the same parameter as in the example. You don't need a -keep rule for the method. The DetectionReport contains several methods that allow you to determine the type of threat. You can find the complete list in the DetectionReport JavaDoc . Tip The method getDebugInfo() contains encoded debugging information. If you're not using ThreatCast, we highly recommend that you log this value as it will be helpful for providing to Guardsquare support when diagnosing any problems.","title":"Configure callback"},{"location":"rasp.html#checking-specific-files","text":"If the File Checker is enabled then by default all files will be checked for tampering. Instead, specific files can be checked by listing them in the DexGuard configuration. For example, the following snippet will cause the File Checker to check only assets/main.js and assets/secret.js . - raspfiletamperlist assets / main.js , assets / secret.js Warning The File Checker will be triggered if the application is modified by other tools after DexGuard. In these cases the files to check should be explicitly listed and there are some exceptions. This can occur, for example, with app bundles or Android libraries. In app bundles it is not possible to check the files resources.arsc , AndroidManifest.xml , or other xml files, since the Android bundletool still manipulates them when creating the final APK. In libraries, you can only enable file checking for asset files. Other files will be merged in when the Library is used in an APK. See the Runtime Library documentation for more details and additional limitations.","title":"Checking Specific Files"},{"location":"rasp.html#checking-specific-certificate-hash","text":"When using app signing by Google Play, Google manages and protects your app's signing key for you and signs your APKs on your behalf. In this case DexGuard does not know which signing key will be used and thus does not know which certificate hash should be used to detect resigning of your app. To circumvent this issue, you can provide the certificate hash of the signing key used by Google using the following option. The certificate hash can be provided with or without the colons. We only support the SHA-256 hash. - raspcertificatehash \" EB : B0 : FE : DF : 19 : 42 : A0 : 99 : B2 : 87 : C3 : DB : 00 : FF : 73 : 21 : 62 : 15 : 24 : 81 : AB : B2 : B6 : C7 : CB : CD : B2 : BA : 58 : 94 : A7 : 68 \" - raspcertificatehash \" EBB0FEDF1942A099B287C3DB00FF732162152481ABB2B6C7CBCDB2BA5894A768 \" You can find the certificate hash of the signing key used by Google on your Google Play console under the \"App Signing\" section.","title":"Checking Specific Certificate Hash"},{"location":"rasp.html#performance","text":"Automatically injecting the checks could incur a performance cost as the checks themselves take time to process and enabling more checks might result in a higher performance cost.","title":"Performance"},{"location":"rasp.html#adjusting-the-injection-location","text":"To minimize the performance cost of the injected checks, override the class filters to exclude performance sensitive classes from injection. The -raspclassfilter configuration option determine into which classes the RASP checks will be injected. For example, if your app startup time is slowed down significantly, you can add the following to your configuration to exclude your startup activity from injection: - raspclassfilter class !com.example.StartupActivity","title":"Adjusting the injection location"},{"location":"rasp.html#adjusting-the-amount-of-checks","text":"DexGuard randomly insert checks in all of the project's code. This will make it harder to remove all the RASP checks at the cost of performance and size. This trade-off can be influenced through the appropriate aggressiveness setting. The option is used with the detector name and an aggressiveness level: - raspaggressiveness detector level The available values for aggressiveness are: min , low , medium , high , max . For example, if you want to increase the amount of hook detection checks which are injected into your project's code, you can put the following in your DexGuard configuration: - raspaggressiveness hook high The default aggressiveness levels are listed in the table below: Detector Name Config Name Default Aggressiveness Tamper Detector apktamper medium Certificate Checker certificatetamper medium File Checker filetamper medium debug Detector debug medium emulator Detector emulator high hook Detector hook medium root Detector root medium Virtual Environment Detector virtualenvironment medium","title":"Adjusting the amount of checks"},{"location":"rasp.html#verification","text":"You can get some basic feedback about which detectors were enabled and how many checks were injected with configuration option -verbose (and Gradle option --info to see the output). For more detailed information, in a Gradle build you can find the inject mapping in build/outputs/mapping/<variant_dir>/injectmapping.txt or you can add the following to your DexGuard configuration to print a list of RASP injections to a file: - printinjectmapping inject.txt The file will contain a mapping of which RASP checking code was injected into which method in your project. Warning The file format is not finalised and is subject to change.","title":"Verification"},{"location":"refcard.html","text":"Usage \u00b6 OS Command Windows: dexguard options ... Linux/macOS: dexguard.sh options ... Typically: OS Command Windows: dexguard @myconfig.pro Linux/macOS: dexguard.sh @myconfig.pro Options \u00b6 Option Explanation @ filename Short for ' -include filename '. -include filename Read configuration options from the given file. -basedirectory directoryname Specifies the base directory for subsequent relative file names. -injars class_path Specifies the program jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -outjars class_path Specifies the names of the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -libraryjars class_path Specifies the library jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -pluginjars class_path Specifies the plugin jars. -skipnonpubliclibraryclasses Ignore non-public library classes. -dontskipnonpubliclibraryclasses Don't ignore non-public library classes (the default). -dontskipnonpubliclibraryclassmembers Don't ignore package visible library class members. -keepdirectories [ directory_filter ] Keep the specified directories in the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -multidex deprecated Split the Dalvik code across multiple dex files, if necessary. -printmaindexlist [ filename ] Print to the standard output or to the given file the list of classes that are placed into the main dex and why they need to be stored there. -splitdexfile [ class_filter ] Put the specified classes in a separate dex file. -instantappfeature name activity URL Create an Instant App feature. -performanceprofile filename Optimizes the startup performance, given a .hprof file that is extracted right after starting the app. -splitdimensions deprecated [ dimension_filter ] Split the specified dimensions of resources in app bundles. No longer required, as DexGuard will now read this information from the app bundle directly. -dontcompress [ file_filter ] Don't compress the specified files in output archives. -zipalign n Align uncompressed files in output archives to multiples of the given number of bytes. -target version Set the given version number in the processed classes. -forceprocessing Process the input, even if the output seems up to date. -keep [ , modifier ,...] class_specification Preserve the specified classes and class members. -keepclassmembers [ , modifier ,...] class_specification Preserve the specified class members, if their classes are preserved as well. -keepclasseswithmembers [ , modifier ,...] class_specification Preserve the specified classes and class members, if all of the specified class members are present. -keepnames class_specification Preserve the names of the specified classes and class members (if they aren't removed in the shrinking step). -keepclassmembernames class_specification Preserve the names of the specified class members (if they aren't removed in the shrinking step). -keepclasseswithmembernames class_specification Preserve the names of the specified classes and class members, if all of the specified class members are present (after the shrinking step). -keepcode [ , modifier ,...] class_specification Preserve the specified code attributes, if their methods are preserved as well. -if class_specification Specifies classes and class members that must be present to activate the subsequent -keep option. -printseeds [ filename ] List classes and class members matched by the various -keep options, to the standard output or to the given file. -keepresourcefiles [ file_filter ] Preserve the specified Android resource files. -keepresources [ , keepresources_modifier ,...] [ name_filter ] Preserve the specified Android resources. -keepresourcexmlelements [ name_filter ] Preserve the specified XML elements in Android resource XML files. -dontshrink Don't shrink the input class files. -printusage [ filename ] List dead code of the input class files, to the standard output or to the given file. -printresourceusage [ filename ] List unused resources in the input APK, to the standard output or to the given file. -whyareyoukeeping class_specification Print details on why the given classes and class members are being kept in the shrinking step. -dontoptimize Don't optimize the input class files. -optimizations optimization_filter The optimizations to be enabled and disabled. -optimizationpasses n The number of optimization passes to be performed. -assumenosideeffects class_specification Assume that the specified methods don't have any side effects, while optimizing. -assumenoexternalsideeffects class_specification Assume that the specified methods don't have any external side effects, while optimizing. -assumenoescapingparameters class_specification Assume that the specified methods don't let any reference parameters escape to the heap, while optimizing. -assumenoexternalreturnvalues class_specification Assume that the specified methods don't return any external reference values, while optimizing. -assumevalues class_specification Assume fixed values or ranges of values for primitive fields and methods, while optimizing. -allowaccessmodification Allow the access modifiers of classes and class members to be modified, while optimizing. -mergeinterfacesaggressively Allow any interfaces to be merged, while optimizing. -dontobfuscate Don't obfuscate the input class files. -printmapping [ filename ] Print the mapping from old names to new names for classes and class members that have been renamed, to the standard output or to the given file. -applymapping filename Reuse the given mapping, for incremental obfuscation. -printresourcefilenamemapping [ filename ] Print the mapping from old names to new names for resource files, to the standard output or to the given file. -printresourcemapping [ filename ] Print the mapping from old names to new names for resources, to the standard output or to the given file. -applyresourcemapping [ filename ] Reuse the given mapping for obfuscating resource names. -obfuscationdictionary filename or naming scheme Use either the words in the given dictionary file or the provided naming scheme to obfuscate field names and method names. -classobfuscationdictionary filename or naming scheme Use either the words in the given dictionary file or the provided naming scheme to obfuscate class names. -packageobfuscationdictionary filename Use the words in the given text file as obfuscated package names. -overloadaggressively Apply aggressive overloading while obfuscating. -useuniqueclassmembernames Ensure uniform obfuscated class member names for subsequent incremental obfuscation. -distinctclassmembernames class_specification Ensure all member names within a particular class are unique. -dontusemixedcaseclassnames Don't generate mixed-case class names while obfuscating. -keeppackagenames [ package_filter ] Keep the specified package names from being obfuscated. -flattenpackagehierarchy [ package_name ] Repackage all packages that are renamed into the single given parent package. -repackageclasses [ package_name ] Repackage all class files that are renamed into the single given package. -keepattributes [ attribute_filter ] Preserve the given optional attributes; typically Exceptions , InnerClasses , Signature , Deprecated , SourceFile , SourceDir , LineNumberTable , LocalVariableTable , LocalVariableTypeTable , Synthetic , EnclosingMethod , and *Annotation* . -keepparameternames Keep the parameter names and types of methods that are kept. -renamesourcefileattribute [ string ] Put the given constant string in the SourceFile attributes. -accessthroughreflection [, encryptstrings ] class_specification Replace direct access to the specified classes and class members by reflection. -obfuscatecode [ , strength ] class_specification Obfuscate the code of the specified methods. <!-- Disable natification > -dontnatify Don't apply natification. -printnatificationmapping [ filename ] Print the mapping from Java bytecode to native code generated when applying code obfuscation, to the standard output or to the given file. -natificationdebugdir [ filename ] Specifies a directory in which to place generated native libraries that contain debug symbols. --> -virtualizecode class_specification Virtualize the code of the specified methods. -obfuscatejavascript [ file_filter ] Obfuscate the specified Javascript files, using the plugin defined with -javascriptplugin . -javascriptconfiguration filename [[ string ]] Use the specified plugin jar and optional string to obfuscate Javascript files. -javascriptplugin filename [[ string ]] Use the specified plugin jar and optional string to obfuscate Javascript files. -encryptclasses [ class_filter ] Encrypt classes whose names match the given filter. -encryptclasses class_specification Encrypt classes that match the class specification. -encryptstrings [ string_filter ] Encrypt string constants that match the given filter. -encryptstrings class_specification Encrypt string constants in the specified classes or class members. -adaptclassstrings [ class_filter ] Adapt string constants in the specified classes, based on the obfuscated names of any corresponding classes. -keepkotlinmetadata -adaptresourcefilenames [ file_filter ] Rename the specified resource files, based on the obfuscated names of the corresponding class files. -adaptresourcefilecontents [ file_filter ] Update the contents of the specified resource files, based on the obfuscated names of the processed classes. -stripnativelibrarysections [ file_filter ] Apply additional obfuscation on native libraries, such as shrinking sections which are unused at runtime. -resourcefilenameobfuscationdictionary filename Use the lines in the given text file as obfuscated Android resource file names. -keepresourcexmlattributenames [ name_filter ] Preserve the specified attribute names in binary Android resource XML files. -encryptmetadata [ string_filter ] Encrypt the specified Android manifest metadata. -encryptassetfiles [ file_filter ] Encrypt the specified Android asset files. -encryptresources [ name_filter ] Encrypt the specified Android resources (strings). -encryptresourcefiles [ file_filter ] Encrypt the specified Android resource files (layout, menu, and xml files). -encryptnativelibraries [ file_filter ] Encrypt the specified Android native libraries. -randomizationseed Provide an additional value to take into account when generating a seed value to randomize the obfuscation. -printclassencryption [ filename ] Print the class encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printstringencryption [ filename ] Print the string encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printassetencryption [ filename ] Print the asset encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printresourceencryption [ filename ] Print the resource encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printnativelibraryencryption [ filename ] Print the native library encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -dontpreverify Don't preverify the processed class files. -microedition Target the processed class files at Java Micro Edition. -android Target the processed class files at Android. -dalvik Target and convert the processed class files for Android's Dalvik VM. -protobuffer deprecated Write the processed resource files in protobuffer format, for Android app bundles. No longer required, as app bundles will now be detected automatically by DexGuard. -keystore filename Sign processed jars with a private key from the given key store. -keystorepassword password The password of the key store. -keyalias alias The alias of the key that you want to select from the key store. -keypassword password The password of the key. -pkcs11configuration [ filename ] The configuration file of the PKCS11 module. -certificatelineage filename Include the certificate lineage from the given file in the signature. -apksignatureschemes [ signature_scheme_filter ] Sign with the given signature schemes when creating an apk. -verbose Write out some more information during processing. -dontnote [ class_filter ] Don't print notes about potential mistakes or omissions in the configuration. -dontwarn [ class_filter ] Don't warn about unresolved references at all. -ignorewarnings Print warnings about unresolved references, but continue processing anyhow. -printconfiguration [ filename ] Write out the entire configuration, in traditional DexGuard style, to the standard output or to the given file. -printlibraryconfiguration [ filename ] Write out the configuration required for the processed library, in traditional DexGuard style, to the standard output or to the given file. -printstatistics [ filename ] Write out statistics about the processed code, to the standard output or to the given file. -printinjectmapping [ filename ] Write out a mapping file that lists which RASP checking code was injected into which method. -printthreatcastmapping [ filename ] Write out a mapping file that lists the human readable method names for each check location identifier. -threatcastappuseridgetter class_specification Custom AUID getter method that will be executed to collect the app user ID and send it to ThreatCast when a RASP threat is detected. -addconfigurationdebugging Instrument the processed code with debugging statements that print out suggestions for missing DexGuard configuration. -raspchecks RASP detector list Enable one or more of the RASP detectors. -raspcontinueon RASP detector list By default, an app will crash on a RASP threat, unless listed. -raspcallback class_specification Custom callback that will be executed when a RASP threat is detected. -raspclassfilter class_filter Class filter used to refine the RASP injection locations. -raspaggressiveness Detector name aggressiveness level Change the level of aggressiveness of RASP injection for a certain RASP detector. -raspfiletamperlist file list List of files checked by the RASP File Tamper detector. -raspcertificatehash certificate hash The expected certificate hash of the signing key. -disableprotectionreport Disables the generation of protection reports. -disabletelemetry Disables the sending of usage reports to Guardsquare's servers. -protectionreportdirectory directoryname Specifies the location where protection reports shall be created. -intermediatedirectory directoryname Specifies the location of DexGuard's intermediate directory. allowoverwrite Specifies that files and directories in the given intermediate directory may be overwritten. -disableversioncheck Disables performing the version check. Notes: class_path is a list of jars, apks, aabs, aars, wars, ears, jmods, zips, and directories, with optional filters, separated by path separators. filename can contain Java system properties delimited by ' < ' and ' > '. If filename contains special characters, the entire name should be quoted with single or double quotes. Overview of Keep Options \u00b6 Keep From being removed or renamed From being renamed Classes and class members -keep -keepnames Class members only -keepclassmembers -keepclassmembernames Classes and class members, if class members present -keepclasseswithmembers -keepclasseswithmembernames Keep Option Modifiers \u00b6 Option Explanation includedescriptorclasses Also keep any classes in the descriptors of specified fields and methods. includecode Also keep the code of the specified methods unchanged. allowshrinking Allow the specified entry points to be removed in the shrinking step. allowoptimization Allow the specified entry points to be modified in the optimization step. allowobfuscation Allow the specified entry points to be renamed in the obfuscation step. inmaindex Force the specified entry points to be placed in the primary dex file. Class Specifications \u00b6 [@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname] [{ [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] <fields> | (fieldtype fieldname [= values]); [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] <methods> | <init>(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...)); [@annotationtype] [[!]public|private|protected|static ... ] *; ... }] Notes: Class names must always be fully qualified, i.e. including their package names. Types in classname , annotationtype , returntype , and argumenttype can contain wildcards: ' ? ' for a single character, ' * ' for any number of characters (but not the package separator), ' ** ' for any number of (any) characters, ' % ' for any primitive type, ' *** ' for any type, ' ... ' for any number of arguments, and ' <n> ' for the n 'th matched wildcard in the same option. fieldname and methodname can contain wildcards as well: ' ? ' for a single character and ' * ' for any number of characters.","title":"Reference Card"},{"location":"refcard.html#usage","text":"OS Command Windows: dexguard options ... Linux/macOS: dexguard.sh options ... Typically: OS Command Windows: dexguard @myconfig.pro Linux/macOS: dexguard.sh @myconfig.pro","title":"Usage"},{"location":"refcard.html#options","text":"Option Explanation @ filename Short for ' -include filename '. -include filename Read configuration options from the given file. -basedirectory directoryname Specifies the base directory for subsequent relative file names. -injars class_path Specifies the program jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -outjars class_path Specifies the names of the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -libraryjars class_path Specifies the library jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -pluginjars class_path Specifies the plugin jars. -skipnonpubliclibraryclasses Ignore non-public library classes. -dontskipnonpubliclibraryclasses Don't ignore non-public library classes (the default). -dontskipnonpubliclibraryclassmembers Don't ignore package visible library class members. -keepdirectories [ directory_filter ] Keep the specified directories in the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). -multidex deprecated Split the Dalvik code across multiple dex files, if necessary. -printmaindexlist [ filename ] Print to the standard output or to the given file the list of classes that are placed into the main dex and why they need to be stored there. -splitdexfile [ class_filter ] Put the specified classes in a separate dex file. -instantappfeature name activity URL Create an Instant App feature. -performanceprofile filename Optimizes the startup performance, given a .hprof file that is extracted right after starting the app. -splitdimensions deprecated [ dimension_filter ] Split the specified dimensions of resources in app bundles. No longer required, as DexGuard will now read this information from the app bundle directly. -dontcompress [ file_filter ] Don't compress the specified files in output archives. -zipalign n Align uncompressed files in output archives to multiples of the given number of bytes. -target version Set the given version number in the processed classes. -forceprocessing Process the input, even if the output seems up to date. -keep [ , modifier ,...] class_specification Preserve the specified classes and class members. -keepclassmembers [ , modifier ,...] class_specification Preserve the specified class members, if their classes are preserved as well. -keepclasseswithmembers [ , modifier ,...] class_specification Preserve the specified classes and class members, if all of the specified class members are present. -keepnames class_specification Preserve the names of the specified classes and class members (if they aren't removed in the shrinking step). -keepclassmembernames class_specification Preserve the names of the specified class members (if they aren't removed in the shrinking step). -keepclasseswithmembernames class_specification Preserve the names of the specified classes and class members, if all of the specified class members are present (after the shrinking step). -keepcode [ , modifier ,...] class_specification Preserve the specified code attributes, if their methods are preserved as well. -if class_specification Specifies classes and class members that must be present to activate the subsequent -keep option. -printseeds [ filename ] List classes and class members matched by the various -keep options, to the standard output or to the given file. -keepresourcefiles [ file_filter ] Preserve the specified Android resource files. -keepresources [ , keepresources_modifier ,...] [ name_filter ] Preserve the specified Android resources. -keepresourcexmlelements [ name_filter ] Preserve the specified XML elements in Android resource XML files. -dontshrink Don't shrink the input class files. -printusage [ filename ] List dead code of the input class files, to the standard output or to the given file. -printresourceusage [ filename ] List unused resources in the input APK, to the standard output or to the given file. -whyareyoukeeping class_specification Print details on why the given classes and class members are being kept in the shrinking step. -dontoptimize Don't optimize the input class files. -optimizations optimization_filter The optimizations to be enabled and disabled. -optimizationpasses n The number of optimization passes to be performed. -assumenosideeffects class_specification Assume that the specified methods don't have any side effects, while optimizing. -assumenoexternalsideeffects class_specification Assume that the specified methods don't have any external side effects, while optimizing. -assumenoescapingparameters class_specification Assume that the specified methods don't let any reference parameters escape to the heap, while optimizing. -assumenoexternalreturnvalues class_specification Assume that the specified methods don't return any external reference values, while optimizing. -assumevalues class_specification Assume fixed values or ranges of values for primitive fields and methods, while optimizing. -allowaccessmodification Allow the access modifiers of classes and class members to be modified, while optimizing. -mergeinterfacesaggressively Allow any interfaces to be merged, while optimizing. -dontobfuscate Don't obfuscate the input class files. -printmapping [ filename ] Print the mapping from old names to new names for classes and class members that have been renamed, to the standard output or to the given file. -applymapping filename Reuse the given mapping, for incremental obfuscation. -printresourcefilenamemapping [ filename ] Print the mapping from old names to new names for resource files, to the standard output or to the given file. -printresourcemapping [ filename ] Print the mapping from old names to new names for resources, to the standard output or to the given file. -applyresourcemapping [ filename ] Reuse the given mapping for obfuscating resource names. -obfuscationdictionary filename or naming scheme Use either the words in the given dictionary file or the provided naming scheme to obfuscate field names and method names. -classobfuscationdictionary filename or naming scheme Use either the words in the given dictionary file or the provided naming scheme to obfuscate class names. -packageobfuscationdictionary filename Use the words in the given text file as obfuscated package names. -overloadaggressively Apply aggressive overloading while obfuscating. -useuniqueclassmembernames Ensure uniform obfuscated class member names for subsequent incremental obfuscation. -distinctclassmembernames class_specification Ensure all member names within a particular class are unique. -dontusemixedcaseclassnames Don't generate mixed-case class names while obfuscating. -keeppackagenames [ package_filter ] Keep the specified package names from being obfuscated. -flattenpackagehierarchy [ package_name ] Repackage all packages that are renamed into the single given parent package. -repackageclasses [ package_name ] Repackage all class files that are renamed into the single given package. -keepattributes [ attribute_filter ] Preserve the given optional attributes; typically Exceptions , InnerClasses , Signature , Deprecated , SourceFile , SourceDir , LineNumberTable , LocalVariableTable , LocalVariableTypeTable , Synthetic , EnclosingMethod , and *Annotation* . -keepparameternames Keep the parameter names and types of methods that are kept. -renamesourcefileattribute [ string ] Put the given constant string in the SourceFile attributes. -accessthroughreflection [, encryptstrings ] class_specification Replace direct access to the specified classes and class members by reflection. -obfuscatecode [ , strength ] class_specification Obfuscate the code of the specified methods. <!-- Disable natification > -dontnatify Don't apply natification. -printnatificationmapping [ filename ] Print the mapping from Java bytecode to native code generated when applying code obfuscation, to the standard output or to the given file. -natificationdebugdir [ filename ] Specifies a directory in which to place generated native libraries that contain debug symbols. --> -virtualizecode class_specification Virtualize the code of the specified methods. -obfuscatejavascript [ file_filter ] Obfuscate the specified Javascript files, using the plugin defined with -javascriptplugin . -javascriptconfiguration filename [[ string ]] Use the specified plugin jar and optional string to obfuscate Javascript files. -javascriptplugin filename [[ string ]] Use the specified plugin jar and optional string to obfuscate Javascript files. -encryptclasses [ class_filter ] Encrypt classes whose names match the given filter. -encryptclasses class_specification Encrypt classes that match the class specification. -encryptstrings [ string_filter ] Encrypt string constants that match the given filter. -encryptstrings class_specification Encrypt string constants in the specified classes or class members. -adaptclassstrings [ class_filter ] Adapt string constants in the specified classes, based on the obfuscated names of any corresponding classes. -keepkotlinmetadata -adaptresourcefilenames [ file_filter ] Rename the specified resource files, based on the obfuscated names of the corresponding class files. -adaptresourcefilecontents [ file_filter ] Update the contents of the specified resource files, based on the obfuscated names of the processed classes. -stripnativelibrarysections [ file_filter ] Apply additional obfuscation on native libraries, such as shrinking sections which are unused at runtime. -resourcefilenameobfuscationdictionary filename Use the lines in the given text file as obfuscated Android resource file names. -keepresourcexmlattributenames [ name_filter ] Preserve the specified attribute names in binary Android resource XML files. -encryptmetadata [ string_filter ] Encrypt the specified Android manifest metadata. -encryptassetfiles [ file_filter ] Encrypt the specified Android asset files. -encryptresources [ name_filter ] Encrypt the specified Android resources (strings). -encryptresourcefiles [ file_filter ] Encrypt the specified Android resource files (layout, menu, and xml files). -encryptnativelibraries [ file_filter ] Encrypt the specified Android native libraries. -randomizationseed Provide an additional value to take into account when generating a seed value to randomize the obfuscation. -printclassencryption [ filename ] Print the class encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printstringencryption [ filename ] Print the string encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printassetencryption [ filename ] Print the asset encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printresourceencryption [ filename ] Print the resource encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -printnativelibraryencryption [ filename ] Print the native library encryption groups and the plugins which were used to encrypt them, to the standard output or to the given file. -dontpreverify Don't preverify the processed class files. -microedition Target the processed class files at Java Micro Edition. -android Target the processed class files at Android. -dalvik Target and convert the processed class files for Android's Dalvik VM. -protobuffer deprecated Write the processed resource files in protobuffer format, for Android app bundles. No longer required, as app bundles will now be detected automatically by DexGuard. -keystore filename Sign processed jars with a private key from the given key store. -keystorepassword password The password of the key store. -keyalias alias The alias of the key that you want to select from the key store. -keypassword password The password of the key. -pkcs11configuration [ filename ] The configuration file of the PKCS11 module. -certificatelineage filename Include the certificate lineage from the given file in the signature. -apksignatureschemes [ signature_scheme_filter ] Sign with the given signature schemes when creating an apk. -verbose Write out some more information during processing. -dontnote [ class_filter ] Don't print notes about potential mistakes or omissions in the configuration. -dontwarn [ class_filter ] Don't warn about unresolved references at all. -ignorewarnings Print warnings about unresolved references, but continue processing anyhow. -printconfiguration [ filename ] Write out the entire configuration, in traditional DexGuard style, to the standard output or to the given file. -printlibraryconfiguration [ filename ] Write out the configuration required for the processed library, in traditional DexGuard style, to the standard output or to the given file. -printstatistics [ filename ] Write out statistics about the processed code, to the standard output or to the given file. -printinjectmapping [ filename ] Write out a mapping file that lists which RASP checking code was injected into which method. -printthreatcastmapping [ filename ] Write out a mapping file that lists the human readable method names for each check location identifier. -threatcastappuseridgetter class_specification Custom AUID getter method that will be executed to collect the app user ID and send it to ThreatCast when a RASP threat is detected. -addconfigurationdebugging Instrument the processed code with debugging statements that print out suggestions for missing DexGuard configuration. -raspchecks RASP detector list Enable one or more of the RASP detectors. -raspcontinueon RASP detector list By default, an app will crash on a RASP threat, unless listed. -raspcallback class_specification Custom callback that will be executed when a RASP threat is detected. -raspclassfilter class_filter Class filter used to refine the RASP injection locations. -raspaggressiveness Detector name aggressiveness level Change the level of aggressiveness of RASP injection for a certain RASP detector. -raspfiletamperlist file list List of files checked by the RASP File Tamper detector. -raspcertificatehash certificate hash The expected certificate hash of the signing key. -disableprotectionreport Disables the generation of protection reports. -disabletelemetry Disables the sending of usage reports to Guardsquare's servers. -protectionreportdirectory directoryname Specifies the location where protection reports shall be created. -intermediatedirectory directoryname Specifies the location of DexGuard's intermediate directory. allowoverwrite Specifies that files and directories in the given intermediate directory may be overwritten. -disableversioncheck Disables performing the version check. Notes: class_path is a list of jars, apks, aabs, aars, wars, ears, jmods, zips, and directories, with optional filters, separated by path separators. filename can contain Java system properties delimited by ' < ' and ' > '. If filename contains special characters, the entire name should be quoted with single or double quotes.","title":"Options"},{"location":"refcard.html#keepoverview","text":"Keep From being removed or renamed From being renamed Classes and class members -keep -keepnames Class members only -keepclassmembers -keepclassmembernames Classes and class members, if class members present -keepclasseswithmembers -keepclasseswithmembernames","title":"Overview of Keep Options"},{"location":"refcard.html#keepoptionmodifiers","text":"Option Explanation includedescriptorclasses Also keep any classes in the descriptors of specified fields and methods. includecode Also keep the code of the specified methods unchanged. allowshrinking Allow the specified entry points to be removed in the shrinking step. allowoptimization Allow the specified entry points to be modified in the optimization step. allowobfuscation Allow the specified entry points to be renamed in the obfuscation step. inmaindex Force the specified entry points to be placed in the primary dex file.","title":"Keep Option Modifiers"},{"location":"refcard.html#classspecification","text":"[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname] [{ [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] <fields> | (fieldtype fieldname [= values]); [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] <methods> | <init>(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...)); [@annotationtype] [[!]public|private|protected|static ... ] *; ... }] Notes: Class names must always be fully qualified, i.e. including their package names. Types in classname , annotationtype , returntype , and argumenttype can contain wildcards: ' ? ' for a single character, ' * ' for any number of characters (but not the package separator), ' ** ' for any number of (any) characters, ' % ' for any primitive type, ' *** ' for any type, ' ... ' for any number of arguments, and ' <n> ' for the n 'th matched wildcard in the same option. fieldname and methodname can contain wildcards as well: ' ? ' for a single character and ' * ' for any number of characters.","title":"Class Specifications"},{"location":"releasenotes.html","text":"Changelog \u00b6 Version 9.2.7 (14-12-2021) \u00b6 Improved \u00b6 Upgrade log4j2 dependency in response to CVE-2021-44228. ( T7315 ) Bugfixes \u00b6 Enhance root detection to avoid false negatives in certain cases when CF-Auto-Root is used. ( T7175 ) Prevent possible LinkageError when making package-private final methods that are shadowed protected. ( T7056 ) Prevent possible buffer overflow during hook detection. ( T6888 ) Version 9.2.6 (07-12-2021) \u00b6 Improved \u00b6 Ensure that inlining always respects the code obfuscation configuration. ( T4720 ) Inject the automatic RASP checks more consistently at the start of the application ( T6877 ) Further hardening of the runtime library. ( T3730 ) Bugfixes \u00b6 Ensure that the overwriteUnprotected option works for all tasks. ( T7022 ) Fix a NullPointerException originating from isolated processes when enabling ThreatCast. ( T6865 ) Prevent potential non-deterministic DEX files when encrypting assets and/or native libraries. ( T6867 ) Enable configuration updates when performing resource file encryption. ( T7101 ) Prevent wrong appearance of resources with empty attribute values. ( T7053 ) Version 9.2.5 (19-11-2021) \u00b6 Improved \u00b6 Add default configuration for Android manifest metadata elements in apps using the Google Play Billing library and Android TV apps using content providers. ( T6638 , T6516 ) Implement additional detection methods for Magisk's Zygisk feature. Improve automatically generated configuration by the DexGuard Gradle plugin. ( T6778 ) Add a seatbelt to detect invalid ThreatCast API keys. ( T6912 ) Bugfixes \u00b6 Prevent references to non-existent methods from being injected during JavaScript processing. ( T7012 ) Prevent possible StringIndexOutOfBoundsException when signing the application. ( T7004 ) Prevent possible StackOverflowException in hashCode method when using RASP injection. ( T6826 ) Prevent possible OutOfMemoryError when parsing BundleConfig.pb during input reading. ( T7019 ) Prevent possible UnsatisfiedLinkError when using RASP injection combined with a generic -keepresourcefiles rule. ( T6208 ) Version 9.2.4 (05-11-2021) \u00b6 Improved \u00b6 Improve obfuscation of the runtime-library by allowing -encryptclasses to cover sensible injected classes. ( T6617 ) Add new ways to detect emulator x86 image. ( T6589 ) Bugfixes \u00b6 Fix Javascript syntax error after processing in for loops containing a binary in-operator. ( T6875 ) Version 9.2.3 (25-10-2021) \u00b6 Bugfixes \u00b6 Fix potential false negatives caused by a SIGBUS error in the RootDetector. ( T6824 ) Version 9.2.2 (22-10-2021) \u00b6 Added \u00b6 Additional checks to detect BlueStacks 5 emulators. ( T5521 ) Bugfixes \u00b6 Prevent possible SecurityException in Android 11 devices due to enabling ThreatCast. ( T6667 ) Fix UnsatisfiedLinkError when generating the protection report on Windows. ( T6683 ) Version 9.2.1 (13-10-2021) \u00b6 Added \u00b6 Add support for encrypting styled resource strings. ( T6618 ) Bugfixes \u00b6 Prevent possible R8 compilation error when using enum default values in an interface definition. ( T6097 ) Fix negative rules failing to exclude optimized resource names. ( T5984 ) Fix potential fatal error during memory allocation on M1-based Macs when generating the protection report. ( T6084 ) Fix potential breaking of 'Hide KPI details' link after clicking on feature impact breakdown in the protection report. ( T327 ) Prevent the introduction of illegal method names during resource file encryption. ( T4478 ) Prevent app from potentially crashing before detected threats are reported to ThreatCast when automatic crashing is on. ( T6133 ) Version 9.2.0 (01-10-2021) \u00b6 CodePush Support \u00b6 We already had support for React Native and Cordova applications, we're adding compatibility with the CodePush service for those apps. CodePush is an App Center cloud service that enables Apache Cordova and React Native developers to deploy mobile app updates directly to their users\u2019 devices. Using DexGuard, it is now possible to secure a CodePush update separately from your app. Read more about the new workflow on our in-depth page . Supporting both platforms: iOS & Android. Zero changes required for existing users of our Javascript obfuscation. Gradle support for processing CodePush update packages. Automatic RASP Improvements \u00b6 Our automatic RASP facilities have made another step forward: we can now automatically apply RASP protection in libraries. This means that if you are a library developer, you are not required anymore to rely on manual RASP checks and can use DexGuard to insert all the RASP checks during processing time. We also improved the resilience of our checks, making them harder to identify and remove using static analysis. Enable the use of RASP injection in combination with libraries. Improve the spread of RASP checks in applications. Better hiding of the check within the surrounding code. Bugfixes \u00b6 Improve dex file processing to avoid ArrayStoreException when processing large char arrays. ( T6399 ) Upgrade considerations for version 9.2.0 : The armeabi and mips ABI's have been deprecated since August 2017. They are no longer supported for our RASP features. Version 9.1.15 (22-09-2021) \u00b6 Improved \u00b6 Update manual about the authentication mechanism for the secure Maven repository when using the Kotlin Gradle DSL. ( T6401 ) Bugfixes \u00b6 Fix potential unsupported field error when reading app bundles. ( T6306 ) Fix variant resolution error in application projects including a Kotlin multiplatform library project which includes another Kotlin multiplatform library project as a dependency. ( T6388 ) Version 9.1.14 (15-09-2021) \u00b6 Added \u00b6 Improved support for the Android Studio plugin up to stable version 2020.3.1 and development version 2021.1.1. ( T5409 ) Bugfixes \u00b6 Fix variant resolution error in Kotlin multiplatform library projects when including another Kotlin multiplatform library as a dependency. ( T6167 ) Remove invalid syntax error raised on * symbol in the Android Studio plugin. ( T3976 ) Prevent potential IllegalStateException due to retrieving configuration properties too early in the DexGuard Gradle Plugin. ( T6205 ) Version 9.1.13 (09-09-2021) \u00b6 Bugfixes \u00b6 Prevent InvalidUserCodeException during project evaluation of Dynamic Projects with Gradle 7. Prevent possible emulator detector false positives due to wrongly detected hooking attempts. ( T2637 ) Prevent the printing of a -multidex deprecation warning in the build log when processing Espresso tests. ( T5766 ) Avoid printing invalid Asn1DecodingException message when v4 signing is enabled ( T5637 ) Prevent false positives in virtual environment detector. ( T5989 ) Prevent false positive in hook detector when using Realm in a React Native app ( T6136 ) Prevent app bundle build failures due to the introduction of non-existent language codes. ( T6223 ) Prevent unencryptable resource strings that are referenced from XMLs inside res/values from being encrypted. ( T6200 ) Version 9.1.12 (19-08-2021) \u00b6 Bugfixes \u00b6 Add Crashlytics support for AGP 7. Fix potential runtime crashes due to invalid string decryption parameters. ( T6071 ) Version 9.1.11 (16-08-2021) \u00b6 Added \u00b6 Add support for resource file encryption on Android 12. ( T5833 ) The DexGuard Gradle Plugin now supports AGP 7. ( T5888 ) Add RASP checks to detect Android 12 emulators. ( T6008 ) Add support for detecting BlueStacks 4. ( T5521 ) Improved \u00b6 Remove restriction where APKs can't be signed with signature scheme v2 when min SDK version is set to 28 or higher and max SDK version is set to 30 or higher. ( T5813 ) Using the fat AAR support for local project dependencies will now match variants. This means that e.g. the debug build type of the library will embed the debug build type of the dependency. Update IOCipher dependency of the IOCipher sample to support running it on Android 12. ( T5898 ) Add additional MagiskHide detection. Update basic/AppBundle sample to work with the latest version of bundletool . ( T5824 ) Bugfixes \u00b6 Fix incorrect -raspclassfilter configuration snippet in the RASP manual page. ( T5968 ) Fix duplicate libraryjar when having the same useLibrary library in a dynamic feature and the main module. ( T5967 ) Fix possible Resources$NotFoundException on encrypted resources inside the res/xml folder. Version 9.1.10 (06-08-2021) \u00b6 Improved \u00b6 Improve root detection checks to detect MagiskHide. Avoid potential false positive while checking for emulator when connected to ethernet via USB ethernet adapter. ( T5541 ) Bugfixes \u00b6 Fix potential NullPointerException during Kotlin metadata initialization when using -keepkotlinmetadata . ( T5899 ) Fix input reading of APKs when passed as -libraryjars during Espresso testing. ( T5788 ) Fix potential runtime ArrayIndexOutOfBoundsException in app bundle projects with multiple targetSdkVersions. ( T5535 ) Version 9.1.9 (30-07-2021) \u00b6 Added \u00b6 Add support for Kotlin 1.5. ( DGD-3467 ) Improved \u00b6 Improve reliability of the root detector w.r.t. various SELinux configurations. ( T5264 ) Improve root detection checks to detect MagiskHide. Improved RASP manual about custom application protection. ( T5816 ) Bugfixes \u00b6 Fix threat detection potentially occurring before ThreatCast is initialized. ( T5769 ) Version 9.1.8 (23-07-2021) \u00b6 Bugfixes \u00b6 Fix initialization and obfuscation of Kotlin callable references when using Kotlin 1.4. ( T5631 ) Fix potential hanging of DexGuard process during optimization or obfuscation. Avoid potential false positive in the VirtualEnvironmentDetector when running inside system apps. ( T4626 ) Version 9.1.7 (16-07-2021) \u00b6 Improved \u00b6 Throw an error when a certificate tamper check injection is enabled for a library or app bundle without specifying a certificate hash. ( T4870 ) Bugfixes \u00b6 Fix build failure when using the Android Studio \"Generate Signed Bundle or APK\" window to generate protected bundles on AGP 4.2+. ( T5642 ) Fix incorrect count of encrypted resource files in the protection report. ( T5663 ) Disallow merging of nest hosts or members during class merging optimization. ( T4935 ) Always enable v1 and v2 signing via the Gradle plugin, to prevent problems related to signing when using bundles or in combination with the FileChecker. Version 9.1.6 (09-07-2021) \u00b6 Added \u00b6 Add support for the resource optimizations introduced in AGP 4.2. ( T4229 ) Add support for APK signature scheme v4. ( T4377 ) Automatically pass the v3 and v4 signature scheme settings of the Android Gradle Plugin to DexGuard. ( T5104 ) Improved \u00b6 Make it possible to configure the used signature schemes on an individual basis. ( DGD-2784 ) Bugfixes \u00b6 Ensure correct processing of negative integer values in resource XML files with App Bundles, preventing possible runtime exceptions. ( DGD-3142 ) Fix potential InflateException due to non-matching rules because of the resource optimizations introduced in AGP 4.2. ( T4859 ) Fix a possible NullPointerException when processing large constant arrays. ( T5051 ) Don't ignore native libraries without the lib prefix when applying the -keepresourcefiles rules. ( T5424 ) Fail Gradle build when IncompleteClassHierarchyException is encountered, ( T5007 ) Fix possible native crashes in Xamarin apps due to interference of signal handlers present in the DexGuard runtime library with other signal handlers present in the application. ( T5461 ) Fix variant resolution error in app bundle projects using matchingFallbacks in combination with dynamic features. ( T5518 ) Upgrade considerations \u00b6 Resource keep rules \u00b6 Version 9.1.6 introduces support for the resource optimizations that were introduced in AGP 4.2, which are only applicable to APKs. These optimizations change and shorten the names of resource files inside the APK in order to reduce application size. To keep your current rules targeting resource files applicable, DexGuard reconstructs the file names based on the information in the resource table. In rare cases, this reconstruction could be different from the names the resource folders would have in an application that was not optimized. You can look at the resource file name mapping to know how the optimized file names have been reconstructed. This is only applicable if you are targeting resources for specific configuration types, e.g. res/color/* or res/color-vX/* . Signing \u00b6 The DexGuard Gradle plugin now takes the signing settings specified in the Android Gradle plugin configuration into consideration. The new default behaviour (v1, v2, v3 and v4 if applicable) is different from the original behavior (v1 and v2 enabled, v3 and v4 disabled) . If you want to preserve the previous behavior you can enable v3 signing in AGP using enableV3Signing true . Version 9.1.5 (24-06-2021) \u00b6 Bugfixes \u00b6 Fix a possible RuntimeException during input reading. ( T5347 ) Add Internal annotation to all DexGuardTask properties, as required by Gradle 7 ( T5322 ) Prevent potential IllegalArgumentException during optimisation on single-threaded machines. ( T3796 ) Version 9.1.4 (18-06-2021) \u00b6 Added \u00b6 Add clearer error messages for incompatibility with resource optimizations introduced in AGP 4.2. Add new sample ( samples/basic/Flavors ) demonstrating DexGuard applied to a project using product flavors. ( T4556 ) Improved \u00b6 Split off Unity bindings from the DexGuard runtime library to avoid class collisions with these bindings. ( T3164 ) Add support for passing HTTPs proxy system properties to the Crashlytics mapping file upload. ( T5253 ) Separate the stripping of native library sections functionality of -adaptresourcefilecontents into a new -stripnativelibrarysections rule. ( DGD-2628 ) Bugfixes \u00b6 Reinstate compatibility with Gradle versions older than 5.6, preventing a No main class specified error. ( T4988 ) Generate missing consumer keep rules for native libraries in library projects. ( DGD-3411 ) Fix additional case of constant strings potentially becoming null during string encryption. ( DGD-3288 ) Fix unexpected error while writing dex file using D8 when processing AARs with class encryption enabled and min-sdk 26+ ( T3774 ) Fix potential run-time StackOverflow error when using wildcards in -accessthroughreflection . ( T2360 , T4185 ) Version 9.1.3 (10-06-2021) \u00b6 Improved \u00b6 Add a rule in the default configurations to prevent a potential IllegalStateException after a LifecycleOwner object has been garbage collected. ( T4202 ) Bugfixes \u00b6 Remove the dexguard-rasp version check due to possible variant resolution errors for projects containing dynamic features. ( T5171 ) Version 9.1.2 (09-06-2021) \u00b6 Added \u00b6 Add sample for WearOS applications. ( T4365 ) Add warning to the protection report when no certificate hash is passed when certificate tampering RASP checks are enabled. ( T4400 ) Add a version check that checks that the version of the included dexguard-rasp.jar in your build is the same as the version of DexGuard used. ( T4169 ) Improved \u00b6 Prevent 'raspclassfilter' rules from overriding previous declarations. Bugfixes \u00b6 Fix FileNotFoundException when processing test APK with the dexguard-debug configuration. ( T4722 ) Fix ClassCastException when processing APKs with min-sdk 26+ containing invoke-polymorphic instructions. ( T3710 ) Fix RuntimeException when using whitebox encryption inside large classes. ( T4568 ) Fix potential output writing or runtime errors after incorrect backporting of interface method references. ( DGD-3164 ) Version 9.1.1 (31-05-2021) \u00b6 Improved \u00b6 DexGuard can now automatically inject protection code needed to prevent DexGuard root detection isolated process from crashing. This protection code is injected into all derived methods (including the constructor) of custom Application classes when -raspchecks root is enabled ( T4456 ). Improved upgrading manual page with regard to removed version check plugin. Bugfixes \u00b6 Fix constant strings potentially becoming null during string encryption. ( DGD-3288 ) Fix InvalidUserCodeException in Gradle 7.0 when calling Project.afterEvaluate after the project has already been evaluated. ( T4630 ) Fix potentially incorrect class merging optimizations that could cause a run-time NullPointerException . ( DGD-3377 ) Fix incorrect processing of obfuscated JS files in bundles. ( DGD-3430 ) Fix conversion of primitive class constant instructions that could cause a run-time ClassNotFoundException . ( T4942 ) Fix potential UnsatisfiedLinkerError caused by injecting native libraries for ABIs which aren't already present in the input. ( T4616 ) Adapt obfuscated resources referenced in the R classes during fat AAR creation. Prevent duplicate R.txt zip entries during fat AAR creation. ( T4647 ) Fix potential NullPointerException during shrinking after incorrect backporting of static interface methods. ( DGD-3509 ) Fix potential output writing or runtime errors after incorrect backporting of interface method references. ( DGD-3164 ) Version 9.1.0 (21-05-2021) \u00b6 Improved Protection Report \u00b6 The protection report gives you insight into how well your app or SDK is protected by DexGuard and now provides you with even more detailed information. Compared to DexGuard 9.0, the report will now give you additional insights in the amount of entities that are matched by your rules. The report will now also warn about rules which seem out-of-place, such as when a rule matches no entities. To ensure that new warnings always stand out we now also provide the ability to suppress specific warnings when you are sure that they are not applicable to your case. Improved App Bundle Support \u00b6 App bundles have been supported by DexGuard for a while, this release enhances that capability. This enhanced support includes enabling RASP certificate checking in conjunction with Google Play Signing. This way you can trust that nobody can tamper with your app, even when you don't upload the final apk to the Play Store. You only have to include the certificate hash from your Google Play console in your configuration using -raspcertificatehash Detailed forensics for ThreatCast users \u00b6 ThreatCast is a free to use product that allows real-time monitoring of protected applications. With a new DexGuard release comes new capabilities. You can now track which part of your application generated a particular threat event. This enables you to gain even more insight when the detection occurs. DexGuard will output a threatcast_mapping.yml file when ThreatCast is configured. This file should be uploaded to your ThreatCast portal. DexGuard can now also retrieve extra information at runtime which will be sent along with every threat that is detected. This information can be used to identify which users are trying to reverse engineer your app. You can configure DexGuard using its new option -threatcastappuseridgetter . Minor Changes \u00b6 New \u00b6 DexGuard will now print a message when a new version is available. Improved \u00b6 Add check to prevent multiple -raspcallback rules being specified ( T4643 ) Make Gradle plugin compatibile with Crashlytics mapping file uploads when using Gradle 7.0 . ( T4846 ) DexGuard can now automatically inject protection code needed to prevent DexGuard root detection isolated process from crashing. This protection code is injected into all derived methods of custom Application classes when -raspchecks root is enabled. Bugfixes \u00b6 Fix variant resolution problem when running the assemble task, or building through Android Studio, in a project with dynamic features. ( DGD-3337 ) Fix variant resolution problem when running the test or check task in a project with dynamic features. ( DGD-3378 ) Fix potential ConcurrentModificationException when executing multiple RASP checks in parallel. ( T4748 ) Version 9.0 August 2020 \u00b6 DexGuard 9.0 integration in Android projects requires configuration changes that are detailed in the upgrading guide . New Gradle plugin with AGP 4.0 support \u00b6 DexGuard 9.0 comes with a brand new companion Gradle plugin that is less sensitive to changes in the Android Gradle Plugin. The main difference is that DexGuard now post-processes your application or library, rather than integrating itself into the build process. This means that the DexGuard input is now the unobfuscated application, app bundle or library produced by the standard Android build process. More details can be found here . Protection report \u00b6 DexGuard now automatically produces a visual HTML report to help you improve the overall security of your DexGuard hardened builds. This Protection Report allows you to continuously assess and improve the protection of your application or library. More details can be found here . Android 11 support \u00b6 DexGuard 9.0 fully supports Android 11. Auto-injection of RASP libraries \u00b6 DexGuard can now inject some of the RASP dependencies that previously had to be added as project dependencies. More details on RASP configuration can be found here . Version Issue Module Explanation 9.0.22 T4065 CORE Fix potential NPE while using native library encryption with classes that extend android.app.Service or android.app.Activity . 9.0.22 DGD-3224 CORE Update the Reflection sample to correctly showcase the access through reflection feature. 9.0.22 DGD-3238 CORE Add default -keep rules for compatibility with Android App Actions. 9.0.21 T4589 GRADLE Fix variant resolution error when an APK dependency is provided. 9.0.21 DGD-3520 CORE Add ability to escape quotes in keystore passwords with backslashes. 9.0.21 DGD-3075 CORE Add check to prevent wildcards being used in RASP callback and ThreatCast App User ID configurations. 9.0.21 DGD-3523 CORE Add a runtime API to determine if the current process corresponds to the DexGuard isolated process. 9.0.20 DGD-3421 CORE Fix missing parentheses in await expressions during JavaScript processing. 9.0.20 DGD-3470 CORE Add -threatcastappuseridgetter configuration option. 9.0.20 DGD-2856 GRADLE Fix Gradle plugin compatibility with Gradle 7.0. 9.0.20 DGD-3543 CORE Fix potentially incorrect transformation during conversion of dex files. 9.0.20 DGD-3397 CORE Deprecated the -pack option. See upgrade considerations . 9.0.20 DGD-2978 GRADLE Use the JVM set via JAVA_HOME when executing DexGuard through the Gradle plugin. 9.0.20 DGD-3323 RUNTIME Fix Frida library check to detect deleted entries of the library. 9.0.19 DGD-3517 CORE Fix NullPointerException which could potentially be raised while decrypting strings. 9.0.19 DGD-3338 CORE Generate the right proguard.map when using app bundles in conjunction with R8 for preserving runtime invisible annotations. 9.0.19 DGD-0013 CORE Improve error message when missing classes result in an incomplete class hierarchy. 9.0.19 DGD-3297 GRADLE Add support for apk splits in combination with the overwriteUnprotected option. 9.0.18 DGD-3397 CORE Fix NullPointerException which could potentially be raised while decrypting strings. 9.0.18 DGD-3429 CORE Additionally harden string encryption. 9.0.17 DGD-3274 RUNTIME Improve root detection checks to detect Magisk and MagiskHide versions 21.3 and higher. 9.0.17 DGD-3274 RUNTIME Provide asynchronous root detection interface . 9.0.17 DGD-3274 RUNTIME Deprecate synchronous RootDetector.isDeviceRooted() interface. 9.0.17 DGD-3276 CORE Adapt obfuscated classes referenced in the AndroidManifest.xml during fat AAR creation. 9.0.17 DGD-3399 CORE Fix Cordova plugin inserting incorrect relative paths to DexGuard. 9.0.16 DGD-3398 RUNTIME Fix potential crashes when calling multiple obfuscated versions of the hook detector in parallel. 9.0.15 DGD-3388 CORE Fix potentially encrypting too many string resources. 9.0.15 DGD-3139 CORE Prevent possible SecurityException when applying string encryption. 9.0.15 DGD-3262 GRADLE Prevent the addition of AGP 4.0 in the classpath when using the DexGuard Gradle Plugin. 9.0.14 DGD-3343 RUNTIME Fix a crash in DexGuard runtime checks when used on devices running Android API 25 or lower. 9.0.14 DGD-3344 GRADLE Automatically disable fat AAR generation in our gradle plugin, if another fat AAR plugin is already enabled. 9.0.14 DGD-3321 CORE Fixed encryption of constant field strings when -encryptstrings is specified with only the class name. 9.0.13 DGD-3313 CORE Fix missing parentheses in await subexpressions during JavaScript processing. 9.0.13 DGD-3333 CORE Fix potential ClassCastException while processing app bundles that contain kotlin modules. 9.0.13 DGD-3334 CORE Fix incorrect timestamps for Threatcast threats sent between 12 pm and 1 am UTC. 9.0.13 DGD-3137 RUNTIME Fixed potential ANR issue when calling DexGuard runtime checks. 9.0.13 DGD-3232 CORE Allow to encrypt string resources, but keep their name. 9.0.13 DGD-3036 CORE Fixed potential incorrect removal of exception handlers during optimization. 9.0.13 DGD-3317 CORE Fixed potential NullPointerException when processing Kotlin nested classes. 9.0.13 DGD-3070 GRADLE Allow the use of spaces in the path of build folders on Windows. 9.0.13 DGD-3009 CORE Fix potential ArrayIndexOutOfBoundsException at runtime when using -virtualizecode. 9.0.12 DGD-3002 CORE Fix potential ClassCastException while processing app bundles that contain Android Wear APKs. 9.0.12 DGD-3290 CORE Fix ArrayIndexOutOfBoundsException when -pack is used in combination with a pre-existing Application class. 9.0.12 DGD-3068 CORE Prevent verifier error on Android 4.4 when using encryption features. 9.0.12 DGD-3068 RUNTIME Prevent verifier errors on Android 4.4 in runtime checks. 9.0.11 DGD-2850 GRADLE Fix app bundle inputs not being found when using Android Gradle Plugin 3.5.x 9.0.11 DGD-2720 GRADLE Add support for variant-specific embeddings for fat AARs. 9.0.11 DGD-2834 CORE Add a version check for the runtime library. 9.0.11 DGD-2541 CORE Fix class name obfuscation with long names causing potential overflow of the string section in native libraries. 9.0.11 DGD-2512 CORE Print which configuration files were used to DexGuard's build log. 9.0.11 DGD-1582 CORE Add clear exception message when processing an application with a library config or the other way around. 9.0.11 DGD-2746 GRADLE Clarify exception message when the 'path' property of the DexGuard block does not point to the root of a DexGuard installation. 9.0.11 DGD-1933 CORE Automatically apply the -multidex option. 9.0.10 PGC-0006 CORE Filter out signatures that do not conform with the java specification. 9.0.10 DGD-3231 CORE Fix -accessthroughreflection,encryptstrings potentially introducing a call to a non-existent method. 9.0.10 JSG-74 CORE Don't activate javascript protection for non-javascript script tags in html files. 9.0.10 DGD-2808 CORE Fix invalid app bundle structure when performing automatic RASP injection. 9.0.10 DGD-2924 CORE Print protection report location to DexGuard's build log. 9.0.9 DGD-3235 CORE Create additional locations for RASP injection early in the application lifecycle. 9.0.9 DGD-3153 CORE Improved performance by deduplicating configuration rules. 9.0.9 DGD-3165 CORE Fixed code obfuscation potentially introducing infinite recursion in extensions of Context.getResources() . 9.0.9 DGD-3034 CORE Allow -keepresources flag without explicitly listing resources. 9.0.9 DGD-3109 CORE Added support for M1-based macs to the Protection Report. 9.0.8 DGD-2363 CORE Updated package structure of Dagger sample. 9.0.8 DGD-2363 CORE Updated SSLPinning and SSLPinningWebView samples. 9.0.8 DGD-2861 CORE Fix Error Code 10 when using the DebugBlocker . 9.0.8 DGD-2892 CORE Fixed possible runtime VerifierError caused by -accessbyreflection . 9.0.8 DGD-2235 CORE Added support for encrypting resource files in APKs using SDK 28+. 9.0.8 DGD-3080 GRADLE Fixed issue in the Gradle plugin where libraryjars in dynamic feature modules weren't deduplicated before passing them to DexGuard. 9.0.8 DGD-3023 CORE Fixed issue where RASP checks wouldn't crash the application when logging code was removed using '-assumenosideeffects'. 9.0.8 DGD-3060 CORE Fixed an issue in RASP file checks which could potentially lead to missing checked file. 9.0.7 DGD-2659 CORE Fixed an issue where resource files and encrypted native libraries may receive the same name after obfuscation. 9.0.7 DGD-2887 GRADLE Fixed issue in the Gradle plugin where variant resolution would fail for app bundles with dynamic features when using an Android Gradle plugin version below 4.0 and a Gradle version below 6.0. 9.0.7 DGD-2886 GRADLE Fixed issue in the Gradle plugin where variant resolution failed when a dynamic feature has a dependency on another dynamic feature. 9.0.7 PGC-0015 CORE Added support for Java 16. 9.0.7 PGD-0064 CORE Added support for Java 14 and 15. 9.0.7 PGD-0064 CORE Added support for sealed classes (permitted subclasses attributes). 9.0.7 PGD-0064 CORE Added support for record attributes. 9.0.7 DGD-2877 STUDIO Added support for Android Studio 4.1 and 4.2 to the Android Studio plugin. 9.0.7 DGD-2898 CORE Added rule to configuration to shrink annotations.zip in an Android library by default. 9.0.7 DGD-2884 CORE Fixed parsing of table config in resource table files, causing NullPointerException at processing time 9.0.6 DGD-2828 GRADLE Fixed issue in the Gradle plugin where consumer rules weren't picked up for file dependencies. 9.0.6 DGD-2987 GRADLE Fixed issue in the Gradle plugin where the mapping files are overwritten when APK splits are used. 9.0.6 DGD-2983 RUNTIME Fixed potential crashes in HookDetector when running on Android 10 or higher. 9.0.6 DGD-2369 RUNTIME Fixed potential false positives in RASP emulator check when running on OnePlus devices. 9.0.6 DGD-2067 RUNTIME Renamed DexGuard runtime native library to avoid possible name collisions with other native libraries. 9.0.6 DGD-2918 RUNTIME Fixed potential false positives in EmulatorDetector when running on devices that provide desktop experience. 9.0.6 DGD-2969 CORE Updated Realm sample. 9.0.6 DGD-2602 GRADLE Added Firebase Crashlytics mapping file upload integration to the DexGuard Gradle plugin. 9.0.5 DGD-2953 CORE Fixed required signature scheme check always firing, regardless of maxSdkVersion. 9.0.5 DGD-2914 CORE Moved -keep rules for Moshi to a new dexguard-moshi.pro configuration file. 9.0.5 DGD-2942 CORE Fixed potential infinite loop when processing Dalvik input. 9.0.5 DGD-2954 CORE Fixed parsing failure of UTF-8 BOM encoded Javascript files. 9.0.5 DGD-2919 RUNTIME Fixed potential false positives in EmulatorDetector when running on certain Huawei, Teclast, Myria devices. 9.0.5 DGD-2531 GRADLE Added overwriteUnprotected option to have DexGuard overwrite the unprotected artifact. 9.0.4 DGD-2917 CORE Updated manual entry 'Tune the obfuscation level' to describe the configuration for new gradle plugin. 9.0.4 DGD-2197 CORE Using whitelists for configuring string encryption in JavaScript now properly obfuscates the matched strings. 9.0.4 DGD-2406 CORE Added Kotlin DSL Gradle script snippets to the manual. 9.0.4 DGD-2899 GRADLE Fixed the dexguardDownload task possibly being created multiple times. 9.0.4 DGD-2891 CORE Fixed missing files in the META-INF folder of apks generated from processed app bundles. 9.0.4 DGD-2797 GRADLE Fixed failure to add useLibrary dependencies to the library jars. 9.0.3 DGD-2636 CORE Added support for the WorkManager Multiprocess Library to the default configuration. 9.0.3 DGD-2844 GRADLE Fixed failure to add compileOnly dependencies to the library jars when building a library. 9.0.3 DGD-2870 CORE Fixed RASP resource injection on Windows environment. 9.0.3 DGD-2783 GRADLE Fixed build failure when using the Android Studio \"Generate Signed Bundle or APK\" window to generate protected bundles. 9.0.3 DGD-2687 GRADLE Added documentation for using Crashlytics with product flavors. 9.0.2 DGD-2724 CORE Fixed FileNotFoundException for encrypted native libraries in an SDK with extractNativeLibs=false . 9.0.2 DGD-2826 RUNTIME Fixed potential false positives in HookDetector when handling unresolved symbols. 9.0.2 DGD-2825 RUNTIME Fixed potential false positives in EmulatorDetector on Samsung devices connected to Samsung DeX. 9.0.2 DGD-2835 CORE Fixed potential infinite wait during dependency analysis 9.0.2 DGD-2808 CORE Fixed potential RASP file tamper check failure. 9.0.2 DGD-2790 GRADLE Fixed incorrect parsing of the Gradle version when using a Gradle release candidate. 9.0.2 DGD-2757 CORE Updated the list of available Maven artifacts in the manual. 9.0.2 DGD-2737 CORE Fixed potential NullPointerException while detecting GSON serialization location. 9.0.2 DGD-2411 CORE Made better error messages when the -obfuscatejavaScript and -javascriptconfiguration are not provided together 9.0.2 DGD-2804 RUNTIME Fixed a file descriptor double-close bug in the HookDetector . 9.0.1 DGD-2768 GRADLE Changed the location of the processed apk/aab/aar to be in the same location as the unprocessed one. 9.0.1 DGD-2719 GRADLE Fixed passing of arguments to DexGuard containing characters such as # in keystore passwords. 9.0.1 DGD-2753 CORE Fixed NullPointerException when using -dump. 9.0.1 DGD-2751 CORE Fixed printing of hash # characters when using -printconfiguration . 9.0.1 DGD-2732 CORE Fixed invalid backporting of static and default interface methods when post-processing. 9.0.0 DGD-2070 CORE Added threatcast-client artifacts. 9.0.0 DGD-2070 RUNTIME Added RASP injection library artifact. 9.0.0 DGD-2649 CORE Fixed certain resource table entries not being printed to the resource mapping file. 9.0.0 DGD-2663 CORE Removed old Cordova/CrossWalk sample. 9.0.0 DGD-2683 CORE Removed bin/install_gradle_plugin.{sh,bat} scripts. 9.0.0 DGD-2244 CORE Added rules for Jacoco coverage reports to the default configuration. 9.0.0 DGD-2587 CORE Fixed IllegalArgumentException (Stack size becomes negative) in optimization class/merging/wrapper . 9.0.0 DGD-1919 CORE Added automatic injection of DexGuard runtime library when using automatic RASP injection. 9.0.0 DGD-2468 CORE Gracefully handle corrupt Signature Attributes in the input. 9.0.0 DGD-2253 CORE Added automatic generation of a Protection Report. 9.0.0 DGD-1521 GRADLE Added a new Gradle plugin that supports AGP 4.x. 9.0.0 DGD-2226 CORE Made post-processing the default mode for DexGuard. Upgrade considerations for version 9.0.21 : If your application uses a custom android.app.Application class, please refer to this page to correctly setup your application for RASP root detection (both for manual checks and automatic code injection). Upgrade considerations for version 9.0.20 : The -pack option has been deprecated and will be removed in a future DexGuard release. Please refer to finer-grained techniques such as class encryption ( -encryptclasses ) and code virtualization ( -virtualizecode ) that provide more effective protection. ThreatCast App User ID: DexGuard can retrieve extra information at runtime which will be sent along with every threat that is detected. For example, this information can be used to identify your users. You can configure DexGuard using its new option -threatcastappuseridgetter . Upgrade considerations for version 9.0.17 : In order to detect the latest versions of Magisk and Magisk Hide (21.3+): For manual root detection with the runtime library, use the asynchronous, callback-based implementation of the root detection check that was added in DexGuard version 9.0.17. For automatic root detection with injected RASP checks, use RASP injection of DexGuard version 9.0.17. No configuration or code changes are required compared to previous versions. When building an SDK, the runtime library should be packaged using the embed configuration to make a fat AAR . Upgrade considerations : We removed DexGuard from the build process, it is now supposed to be executed as a command line tool. We added a new Gradle plugin that will help you to collect certain inputs for DexGuard. This plugin has support for AGP 4+. Version 8.7 June 2020 \u00b6 Automated RASP injection \u00b6 DexGuard can now automatically inject the various checks for Runtime Application Self-Protection into your application. You no longer need to manually change your source code to update the protection of your application. By simply rebuilding your app, you can let DexGuard add the latest checks, automatically and to their full extent. DexGuard provides: Automatic injection based on high-level configuration switches. Aggressiveness settings to control the impact. An optional callback mechanism enabling your app to react to threats. Optional application termination as a tamper response. Straightforward but flexible configuration options. Threat reporting capabilities \u00b6 Detecting and reacting to application and device threats are fundamental DexGuard features. You may also want to collect and visualize related data, in order to further improve hardening or to flag fraud. Our free ThreatCast console now adds convenient reporting capabilities. Seamless integration with the ThreatCast console. Automated threat reporting for all enabled RASP checks. Collection and reporting of additional threat information. Easy configuration through addition of a single api-key. Inconspicuous name obfuscation \u00b6 Typical name obfuscation stands out because of the unusual identifiers. In some cases this draws extra attention and helps focus reverse engineering efforts. New settings to switch between naming schemes. New naming scheme to generate realistic looking names. Fat AARs \u00b6 DexGuard can now combine and protect multiple AAR libraries and their internal and external dependencies into a single 'fat' AAR. You can thus more easily create and distribute secure SDKs. Improved Kotlin support \u00b6 The default processing of Kotlin applications has been improved. Various pieces of Kotlin-related semantic information are removed when not needed at run-time. You can still apply standard -keep rules when exceptions are needed, for example for SDK APIs. Version Issue Module Explanation 8.7.10 DGD-2734 CORE Fixed not all initialization methods being kept for Moshi Json deserialization. 8.7.09 DGD-2713 CORE Fixed parameter names in Kotlin interfaces not being kept when using -keepparameternames together with -keepkotlinmetadata. 8.7.09 DGD-2701 RUNTIME Fixed potential false negatives in EmulatorDetector . 8.7.08 DGD-2661 CORE Fixed UnsatisfiedLinkError when including DexGuard native runtime libraries with conservative default configuration. 8.7.08 DGD-2655 CORE Fixed corruption of decrypted strings on some devices. 8.7.08 DGD-2677 CORE Fixed potential issue related to increased string section length when processing native libraries. 8.7.08 DGD-2480 CORE Changed default configuration to keep native libraries with their original names in library projects. 8.7.08 DGD-2647 RUNTIME Fixed potential false positives in EmulatorDetector when running on certain Xiaomi devices. 8.7.08 DGD-2643 CORE Fixed potential NullPointerException during GSON optimization. 8.7.07 DGD-2382 CORE Fixed processing of Kotlin 1.4 metadata annotations. 8.7.07 DGD-2632 CORE Added support for localised values for fat AARs. 8.7.06 DGD-2580 CORE Fixed potential VerifyErrors on Android 4.4 and earlier when encrypting strings. 8.7.06 DGD-2539 CORE Added additional rules for Moshi GSON parser/unparser and added a sample Moshi project. 8.7.06 DGD-2498 STUDIO Added RASP configuration support in Android Studio plugin. 8.7.06 DGD-2554 CORE Fixed potential VerifyErrors on Android 4.4 and earlier when virtualizing code. 8.7.06 DGD-2540 CORE Fixed potential VerifyError: Bad type on operand stack error when injecting RASP callback. 8.7.06 DGD-2518 CORE Fixed potential corruption of RASP callback when using certain variable types. 8.7.05 DGD-2511 CORE Fixed regression in the Gradle plugin where Espresso tests contain too many classes. 8.7.05 DGD-2427 CORE Added additional configuration to keep attribute names related to in AndroidManifest.xml 8.7.05 DGD-2510 CORE Added further additional default configuration for the Firebase Crashlytics library. 8.7.04 DGD-2508 CORE Fixed NullPointerException when using native library encryption with app bundles. 8.7.04 DGD-2501 CORE Added additional default configuration for the Firebase Crashlytics library. 8.7.04 DGD-2372 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on devices running Android 11. 8.7.04 DGD-2492 CORE Prevented erroneous options in consumer rule generation for AARs. 8.7.04 DGD-2366 CORE Fixed string encryption possibly introducing private fields in interfaces. 8.7.04 DGD-2494 CORE Fixed naming conflict resolution potentially resulting in the renaming of android library members. 8.7.04 DGD-2493 CORE Fixed -keepresources being incorrectly written to consumer rules. 8.7.04 DGD-2479 CORE Fixed spuriously incorrectly decrypted strings on new thread. 8.7.04 DGD-2471 RUNTIME Fixed potential IllegalArgumentException when obfuscating/virtualizing code that has parameter type annotations. 8.7.04 DGD-2368 RUNTIME Fixed false negatives in EmulatorDetector when running on Android 11 emulator. 8.7.03 DGD-2425 GRADLE Fix Espresso test default input filter in the Gradle plugin which prevented kotlin metadata files from being included in the test apk. 8.7.03 DGD-2351 GRADLE Fix issue in the Gradle plugin where native libraries in library projects weren't picked up on a clean build. 8.7.03 DGD-2421 CORE Add default configuration for Google ML kit library. 8.7.03 DGD-2354 CORE Update the configuration to keep Gson annotations. 8.7.03 DGD-2352 CORE Fix potential NullPointerException in certain RASP injection locations. 8.7.03 DGD-2348 CORE Fix possible duplication of certain injected RASP checks. 8.7.03 DGD-2344 CORE Fix apps always crashing when a debugger is attached regardless of user configuration. 8.7.03 DGD-2329 CORE Improve potential code injection locations. 8.7.03 DGD-2299 CORE Add API method to DetectionReport for checking if the app was signed with debug keys. 8.7.03 DGD-1792 RUNTIME Fixed potential false positives when calling HookDetector.isApplicationHooked on devices with native bridge initialized. 8.7.03 RUNTIME Added integration with the Zimperium console. 8.7.03 RUNTIME Added integration with ThreatCast. 8.7.02 DGD-2288 CORE Fix potential crash when injecting code into methods with unsupported attributes. 8.7.01 DGD-2268 CORE Fix reporting of incorrect threat types when certain hooking and rooting checks are injected. 8.7.00 DGD-2205 CORE Changed default -optimizationpasses to 2. 8.7.00 DGD-2223 GRADLE Enabled -printinjectmapping by default in Gradle builds. 8.7.00 DGD-1891 CORE Fix potential NullPointerException when processing Kotlin metadata. 8.7.00 DGD-2147 CORE Added RASP configuration options. 8.7.00 DGD-2151 CORE Fixed a possible crash when the dexguard-rasp library is included without the dexguard-runtime library. 8.7.00 DGD-2166 CORE Added Kotlin reflect -keep rules to the default configuration. 8.7.00 DGD-2188 CORE Renamed -adaptkotlinmetadata configuration option to -keepkotlinmetadata. 8.7.00 DGD-2101 CORE Added exceptions and warnings for common RASP injection configuration mistakes. 8.7.00 DGD-2165 CORE Added KotlinReflection sample. 8.7.00 DGD-2170 GRADLE Fixed possible persistence problem with injection configurations when using a Gradle daemon. 8.7.00 DGD-2148 CORE Automatically encrypt strings in RASP callbacks. 8.7.00 DGD-2158 GRADLE Rename Kotlin samples: Kotlin to KotlinHelloWorld and KotlinDSL to GradleKotlinDSL. 8.7.00 DGD-1976 CORE Added dexguard-rasp.pro configuration (replacing multiple RASP/ThreatCast/Zimperium configuration files). 8.7.00 DGD-1975 CORE Added support for RASP callbacks and default crash/continue threat behaviour ( continueOn* switches). 8.7.00 DGD-1525 CORE Added new obfuscation scheme that uses kept names for name obfuscation. 8.7.00 DGD-1693 CORE Add support for injecting code that contains exception handling. 8.7.00 DGD-1969 CORE Add support for injecting code that contains switch blocks. 8.7.00 DGD-1787 CORE Strip Kotlin metadata unless explicitly kept via -keep rules. 8.7.00 DGD-2063 CORE Fixed configuration printing of members in class specification -define vars. 8.7.00 DGD-2055 CORE Ensure that code is not injected before super.onAttachBaseContext in Android applications. 8.7.00 DGD-2047 CORE Fixed possible NullPointerException if Kotlin referenced file facade does not exist. 8.7.00 DGD-1732 CORE Fixed retrace not deobfuscating certain stacktraces originating from Sentry. 8.7.00 DGD-1995 CORE Fixed constructing class hierarchy for optimization and obfuscation. 8.7.00 DGD-2001 CORE Keep INSTANCE fields in Kotlin object classes. 8.7.00 DGD-1795 CORE Prevent classes referenced from Android XMLs from being made packageless. 8.7.00 DGD-1780 CORE Removed dependency on internal sun.security API. 8.7.00 DGD-1851 GRADLE Updated Kotlin sample gradle configuration and moved from \"advanced\" to \"basic\" folder. 8.7.00 DGD-1434 CORE Improved default support for the AndroidX libraries. 8.7.00 DGD-1755 CORE Targeting Java 5 instead of Java 1.2 in generated Java class files in library projects. 8.7.00 DGD-1286 CORE Added support for PKCS11 signing through the new option -pkcs11configuration . 8.7.00 DGD-1754 WB-ADDON Fixed unsupported constants in bytecode when applying whitebox cryptography in library projects without optimization or obfuscation. 8.7.00 DGD-1240 RUNTIME Added a Cordova SystemWebViewClient that can do both SSL pinning and asset decryption. 8.7.00 DGD-123 CORE Added support for fat AAR creation. 8.7.00 RUNTIME Added integration with the Zimperium console. 8.7.00 RUNTIME Added integration with ThreatCast. Version 8.6 February 2020 \u00b6 Improved support for Kotlin. DexGuard is now able to process (shrink / obfuscate) information injected by the kotlin compiler ( kotlin.Metadata annotations, data classes, ...). Please refer to the Kotlin page for more information. Version Issue Module Explanation 8.6.19 DGD-2263 CORE Fixed native library name obfuscation to avoid potential conflict in library projects. 8.6.19 DGD-2332 CORE Further hardened code virtualization. 8.6.19 DGD-2356 RUNTIME Fixed potential false negative with regards to detection of new Android debug keys. 8.6.19 DGD-2354 CORE Update the configuration to keep Gson annotations. 8.6.19 DGD-2287 CORE Further hardened string encryption. 8.6.19 DGD-2340 CORE Include the required resources for Google Open Source Notices. 8.6.19 DGD-2297 CORE Fix potential post-processing VerifyError \"expected to be within a catch-all for an instruction where a monitor is held\". 8.6.18 DGD-2022 CORE Fixed issue in the Gradle plugin where classes were collected incorrectly when using Firebase performance monitoring, causing no monitoring information to be sent. 8.6.17 DGD-1513 STUDIO Added support for Android studio 4.0 to the Android studio DexGuard configuration file type plugin. 8.6.17 DGD-2174 GRADLE Fixed issue in the Gradle plugin where dynamic feature dependencies weren't collected properly when building app bundles with AGP 3.6. 8.6.17 DGD-2202 CORE Fixed invalid interface method access modifier when backporting lambdas with minSdkVersion >= 26. 8.6.16 DGD-1853 RUNTIME Fixed false negatives in EmulatorDetector when running on Nox player. 8.6.15 DGD-2179 GRADLE Fixed Crashlytics support regression with the Android Gradle plugin 3.6 in the Gradle plugin. 8.6.14 DGD-2159 GRADLE Fixed issue in the Gradle plugin where the build would crash when using Gradle 6. 8.6.14 DGD-1586 GRADLE Improved integration with the new Firebase Crashlytics SDK. Documented remaining steps for the integration. 8.6.14 DGD-2103 CORE Fixed potential crash when doing primitive castings during backporting. 8.6.14 DGD-2106 GRADLE Fixed issue in the Gradle plugin where specifying splits with both abi and density dimensions for an apk caused a crash. 8.6.13 DGD-2073 GRADLE Resolved task ordering issues between the DexGuard and Crashlytics Gradle plugins when using Android Gardle plugin version 3.6. 8.6.13 DGD-2076 GRADLE Fixed an issue in the Gradle plugin where library jars may be missing when building instrumented test APKs 8.6.13 DGD-2061 GRADLE Fixed issue in the Gradle plugin where the mapping file wasn't correctly set when using the Android Gradle plugin 3.6. This caused calls to variant.getMappingFile() to fail. 8.6.11 DGD-1792 RUNTIME Fixed potential false positives when calling HookDetector.isApplicationHooked on devices with native bridge initialized. 8.6.10 DGD-2043 CORE Fixed processing of section indices in ELF files. 8.6.10 DGD-2042 GRADLE Fixed an issue in the Gradle plugin where too many classes were included in instrumented test APKs. 8.6.10 DGD-2050 RUNTIME Fixed false negatives in RootDetector wrt detecting Magisk Manager app. 8.6.10 DGD-2018 CORE Improved analysis for necessary classes in the main dex file. 8.6.10 DGD-2046 CORE Fixed optimization leading to unexpected error \"Stack size becomes negative\". 8.6.10 DGD-1837 CORE Fixed potential IncompatibleClassChangeError when backporting lambda expressions. 8.6.09 DGD-1842 CORE Fixed possible stack overflow when many GSON classes are optimized. 8.6.09 DGD-1979 CORE Fixed transitive loading of encryption plugins when they were not explicitly loaded. 8.6.08 DGD-1897 CORE Fixed verifier error when declaring too many JNI methods. 8.6.07 DGD-1186 WB-ADDON Further fixed application of whitebox cryptography for debug builds. 8.6.07 DGD-1938 CORE Corrected file name to be uploaded to private Maven repository in manual. 8.6.06 DGD-1800 CORE Fixed obfuscation of functional interfaces with abstract Object methods. 8.6.06 DGD-1558 CORE Fix potential error caused by D8 \"expected to find a possibly throwing instruction\". 8.6.06 CORE Updated D8 tool for class conversion to version 1.6.68. 8.6.06 DGD-1883 GRADLE Updated parsing of resource tables in app bundles for Android Gradle Plugin 3.6 (\"Unsupported field number [5] in Attribute Symbol message\"). 8.6.05 DGD-1854 WB-ADDON Fixed application of whitebox cryptography for debug builds. 8.6.05 DGD-1836 GRADLE Fixed issue in the Gradle plugin where dependencies weren't collected correctly when using transforms with a limited scope. 8.6.05 DGD-1846 CORE Fixed potential IllegalArgumentException during optimization when there is only one core available. 8.6.04 DGD-1844 GRADLE Improved error message when including the DexGuard gradle plugin the wrong way. 8.6.04 DGD-1841 CORE Disabled internal debug logging and files. 8.6.03 DGD-1811 CORE Fixed threading issue causing spurious optimization problems. 8.6.03 DGD-1778 GRADLE Fixed an issue in the Gradle plugin which might cause variant selection to fail when using dynamic features. 8.6.03 DGD-1809 GRADLE Improved error message when including the DexGuard gradle plugin the wrong way. 8.6.03 DGD-1621 RUNTIME Updated the runtime library to allow integration with Unity. 8.6.03 DGD-1759 GRADLE Fixed issue in the Gradle plugin causing a FileNotFoundException when including certain dependencies using the Android Gradle plugin version 3.6. 8.6.03 DGD-1239 RUNTIME Add implementation for shouldInterceptRequest(WebView view, WebResourceRequest request) to EncryptedWebViewClient, introduced in API level 21. 8.6.03 DGD-1768 CORE Fixed potential deadlock in optimization phase. 8.6.03 DGD-1756 CORE Further avoiding Windows file naming issue of resource files in libraries. 8.6.02 DGD-1698 CORE Fixed possible NullPointerException while processing Kotlin modules. 8.6.02 DGD-1714 CORE Fixed extends not recognized in -encryptclasses rule. 8.6.02 DGD-1566 RUNTIME Added documentation for DexGuard runtime library integration in SDK projects. 8.6.01 DGD-1567 RUNTIME Fixed crashes in DexGuard runtime library on devices running Android API less than 21. 8.6.00 JSG-8 CORE Added support for JavaScript obfuscation of ECMAScript 6 code. 8.6.00 JSG-60 CORE Improved runtime performance of JavaScript string decryption. 8.6.00 DGD-1556 CORE Added default configuration for the Unity game engine. 8.6.00 JSG-4 CORE Improved integration with React Native apps. 8.6.00 JSG-31 CORE Improved error handling when parsing JavaScript configuration. 8.6.00 JSG-6 CORE Added function encryption to hide the implementation of sensitive JavaScript functions. 8.6.00 DGD-1562 CORE Fixed incomplete usage marking of Kotlin classes potentially causing NullPointerException at build time. 8.6.00 DGD-1444 CORE Improved speed of side effect marking. 8.6.00 DGD-1473 CORE Improved speed of instruction usage marking. 8.6.00 DGD-1204 CORE Added allowobfuscation modifier for resources, to allow renaming of the resource id. 8.6.00 DGD-1482 CORE Improved speed of peephole optimizer. 8.6.00 DGD-1471 CORE Improved speed of horizontal class merging. 8.6.00 DGD-1537 CORE Improved speed of partial evaluator. 8.6.00 DGD-1456 GRADLE Updated default resource input filters of the gradle plugin wrt files located in the META-INF directory. 8.6.00 DGD-1370 GRADLE Added support for the Android Gradle plugin version 3.6. 8.6.00 DGD-1219 CORE Added new option -printresourcemapping to print the mapping information for resource entries. 8.6.00 DGD-1487 CORE Fixed false positives wrt default constructors when using -addconfigurationdebugging . 8.6.00 DGD-1495 CORE Fixed false positives for missing assets and native libraries when using -addconfigurationdebugging . 8.6.00 DGD-1346 CORE Added new option -distinctclassmembernames to ensure that all matching members are distinct within a class. 8.6.00 DGD-1550 CORE Fixed potential NullPointerException when processing kotlin.Metadata annotations at build time. 8.6.00 DGD-1201 RUNTIME Added debug blocker and improved debug detection. 8.6.00 DGD-1472 CORE Improved speed of initial subclass initialization 8.6.00 DGD-1464 CORE Fixed non-determinism during apk input processing. 8.6.00 DGD-1463 CORE Ensured that printed optimization statistics are reported correctly. 8.6.00 DGD-1294 RUNTIME Added documentation to the performance of various environment checks of the DexGuard runtime library. 8.6.00 CORE Fix potential build error when obfuscating companion classes of nested Kotlin classes. 8.6.00 CORE Fix potential build error when partially keeping the kotlin.Metadata class. 8.6.00 DGD-1480 CORE Fix potential kotlin reflection runtime errors due to incorrect flags on properties. 8.6.00 DGD-1462 CORE Fixed initialization of enclosing method classes. 8.6.00 DGD-1405 CORE Fixed processing of Kotlin companion objects. 8.6.00 DGD-1455 CORE Fixed potential IllegalArgumentException in DataClassObfuscator. 8.6.00 DGD-1384 CORE Added support for Kotlin contracts. 8.6.00 DGD-1455 CORE Fixed processing of kotlin data classes. 8.6.00 CORE Fixed sample 'basic/KotlinDSL'. 8.6.00 CORE Fixed potential NullPointerException when processing kotlin.Metadata annotations at build time. 8.6.00 DGD-1094 CORE Added a cordova plugin to setup DexGuard automatically in cordova projects. 8.6.00 GRADLE Modified group Id in pom descriptors lib/gradle-plugin.xml and lib/maven-plugin.xml to com.guardsquare.dexguard to be in sync with artifacts on maven repository. 8.6.00 DGD-1382 CORE Added support to process kotlin.Metadata annotations . 8.6.00 DGD-1419 GRADLE Fixed issue in the Gradle plugin where dependency projects got compiled for all variants when this is only necessary for some of them. 8.6.00 PGD-753 CORE Fixed processing of signature attributes in constructors of inner classes and enum types. 8.6.00 PGD-756 CORE Fixed detection of functional interfaces. 8.6.00 PGD-750 CORE Fixed UnsupportedOperationException when optimizing enum types in closure arguments. 8.6.00 PGD-752 CORE Fixed preverification of initializers with inlined exception throwing code. 8.6.00 PGD-744 CORE Fixed potential ClassCastException when optimizing method handles of simple enum types. 8.6.00 PGD-741 CORE Improved incremental obfuscation. 8.6.00 PGD-740 CORE Fixed shrinking of nest member attributes. 8.6.00 PGD-739 CORE Fixed the counter for the number of inlined constant parameters. 8.6.00 PGD-188 CORE Added support for nest-based access control and dynamic constants in Java 11. 8.6.00 PGD-735 CORE Fixed processing of parameter annotations in constructors of inner classes and enum types. 8.6.00 PGD-734 CORE Fixed detection of functional interfaces with Object methods. 8.6.00 PGD-709 CORE Improved error messages for problems parsing wildcards. 8.6.00 PGD-680 CORE Fixed resolution of class members in Java 11 or higher. 8.6.00 DGD-1138 GRADLE Added support for the Android Gradle plugin version 3.5. Upgrade considerations : The DexGuard gradle plugin is now a separate jar ( lib/dexguard-gradle-plugin.jar ) and local integration in the build.gradle has slightly changed as it has now some transitive dependencies. The file lib/dexguard.jar does not include the gradle plugin anymore and should only be used for standalone processing. Version 8.5 August 2019 \u00b6 Dex conversion. Dex Conversion has been changed to use D8 by default. Multidex improvements. Support for multidexing in applications has been improved to be as compatible as possible to the standard Android gradle plugin. Improved root detection. DexGuard now more reliably detects magisk. Version Issue Module Explanation 8.5.18 DGD-1594 CORE Fixed merging of wrapper classes when processing some apk files. 8.5.18 DGD-1615 CORE Avoiding backup file naming issue of resource files in libraries. 8.5.17 DGD-1567 RUNTIME Fixed crashes in DexGuard runtime library on devices running Android API less than 21. 8.5.17 DGD-1564 CORE Fixed merging of wrapper classes when processing some apk files. 8.5.16 DGD-1552 CORE Avoiding Windows file naming issue of resource files in libraries. 8.5.15 DGD-1505 CORE Completed fix for encrypted resources which got corrupted in app bundles. 8.5.14 DGD-1539 RUNTIME Qualified Magisk as a root hider in root detection. 8.5.14 DGD-1497 RUNTIME Fixed crashes when calling HookDetector.isApplicationHooked in apps using TensorFlow libraries. 8.5.14 DGD-1486 RUNTIME Fixed crashes when calling HookDetector.isApplicationHooked in multiple threads simultaneously. 8.5.13 DGD-1507 CORE Fixed issue in Gson optimization that could cause verification errors when used on abstract classes. 8.5.12 DGD-1508 CORE Updated dictionary.txt to avoid problems on some Samsung devices. 8.5.12 DGD-1531 RUNTIME Fixed false positives when calling RootDetector.isDeviceRooted on devices running Android 9 and lower. 8.5.12 DGD-1532 GRADLE Fixed issue in the Gradle plugin where variant resolution could fail when a flavor dimension is declared but not used by any product flavor. 8.5.12 DGD-1516 CORE Added support for resource string encryption when resources are used as input to TextView.setText(int) . 8.5.12 DGD-1519 CORE Added support for new dialog destination elements introduced in navigation component v2.1.0. 8.5.12 DGD-1515 CORE Ensured that the build fails when using a minSdkLevel of 21+ and the resulting application does not fit into a single dex file but -multidex was not specified. 8.5.12 PGD-19 CORE Fixed potential issues when removing unused parameters in method descriptors (optimization method/removal/parameter ). 8.5.12 PGD-18 CORE Fixed potential case where parameterless constructors were made private during optimization. 8.5.12 CORE Fixed Windows batch script for generating keep rules for an aar file. 8.5.12 DGD-1454 CORE Adjusted defaults for dex conversion when using d8 to avoid rare build errors due to dex overflows. 8.5.12 DGD-1498 GRADLE Made gradle plugin more robust wrt gradle buildscript classpath issues and support including the plugin inside the buildSrc environment. 8.5.12 CORE Fixed configuration of advanced/KeyCzar sample wrt logging removal. 8.5.11 DGD-1474 RUNTIME Improved detection of Magisk Manager app. 8.5.11 JSG-53 CORE Fixed escaping of encrypted JavaScript strings. 8.5.11 JSG-47 CORE Fixed wrongly obfuscated JavaScript variables when obfuscation was disabled. 8.5.11 JSG-55 CORE Fixed wrong parenthesization of template call expressions in JavaScript code. 8.5.11 DGD-1503 CORE Added default filter to prevent processing of versioned class files. 8.5.11 CORE Fixed processing of app bundles that use -encryptresourcefiles in combination with bundletool. 8.5.11 DGD-1505 CORE Fixed encryption of resource strings when building app bundles. 8.5.11 DGD-1496 GRADLE Fixed issue in the Gradle plugin with missing consumer rules when using disabled variants in project dependencies. 8.5.10 DGD-1492 RUNTIME Fixed false positives when calling VirtualEnvironmentDetector.isRunningInVirtualEnvironment on Asus Zenfone 6 devices running Android 9. 8.5.10 DGD-1485 RUNTIME Fixed false positives when calling VirtualEnvironmentDetector.isRunningInVirtualEnvironment on Nvidia Shield TV devices. 8.5.10 DGD-1491 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on certain Xiaomi devices. 8.5.10 CORE Fixed parsing maxSdkVersion from the AndroidManifest.xml . 8.5.10 DGD-1477 GRADLE Fixed gradle plugin to support Android gradle plugin 3.5.2 due to missing dependencies. 8.5.10 DGD-1465 CORE Fixed potential NoSuchElementException when building projects with submodules and complex flavor setups. 8.5.10 DGD-1481 GRADLE Fixed including consumer Proguard rules from submodules when enabling on demand configuration with gradle 5.5+. 8.5.10 DGD-1489 CORE Fixed potential IllegalArgumentException with message Value \"x\" is not a reference value when optimizing code with conditional casts. 8.5.10 DGD-1483 CORE Added support for proper obfuscation of argument types (attribute argType ) when using the androidx navigation library. 8.5.10 DGD-1221 CORE Improve default configuration to support optimization of default constructors. 8.5.10 DGD-1381 GRADLE Fixed including dependent modules when building library projects with Android gradle plugin 3.5+. 8.5.10 DGD-1484 GRADLE Fixed issue in the gradle plugin where dependencies got collected wrongly in combination with the realm plugin. 8.5.10 DGD-1459 GRADLE Fixed issue in the gradle plugin where project dependencies in a composite build were included wrongly. 8.5.10 DGD-1476 CORE Fixed potential NullPointerException during processing when no -libraryjars option has been specified. 8.5.10 DGD-1424 CORE Fixed incomplete fix in case of inlining methods with type annotations. 8.5.10 CORE Added marker for dex files when using d8 as conversion mechanism. 8.5.10 DGD-1468 CORE Fixed default configuration of side effects for the java.lang.Character#toChars(int, char[], int) method which resulted in broken androidx emoji compatibility library. 8.5.09 CORE Fixed potential loading errors for encrypted native libraries when no abiFilter is defined and improved error reporting in case of problems. 8.5.09 CORE Fixed potential loading errors for encrypted native libraries on Android P+ devices in projects with targetSdkVersion >= 25 and not using the nativeloader mechanism. 8.5.08 CORE Fixed support for missingDimensionStrategy settings when including library modules that do not have any flavors. 8.5.07 DGD-1452 GRADLE Fixed issue in the gradle plugin where classes starting with an _ were not included correctly in library projects. 8.5.07 DGD-1447 CORE Added support for private resources in library projects. 8.5.07 DGD-1448 GRADLE Fixed potential infinite loop when analysing project dependencies in the gradle plugin introduced by adding support for AGP 3.5. 8.5.07 DGD-1449 CORE Fixed NoClassDefFoundError in library projects that use the Gson library. 8.5.07 DGD-1445 GRADLE Fixed support for missingDimensionStrategy settings in build.gradle when using the gradle plugin introduced by adding support for AGP 3.5. 8.5.06 CORE Fixed generation of maindexlist.txt and proguard.map in app bundles to not rely on default encoding. 8.5.06 DGD-1429 GRADLE Fixed considerable slowdown in configuration phase when using the gradle plugin with Android gradle plugin v3.5.0+. 8.5.06 DGD-1416 RUNTIME Fixed potential file descriptor leakage when calling HookDetector.isApplicationHooked on Android 7+ devices. 8.5.06 DGD-1343 CORE Ensured that lambda expressions are always backported by default even when specifying a minSdkVersion of 26+. 8.5.06 DGD-1430 RUNTIME Fixed potential exception when calling RootDetector.isDeviceRooted on some Tecno devices. 8.5.06 GRADLE Backported support for the Android Gradle plugin version 3.5. 8.5.06 DGD-1424 CORE Fixed potential build error when inlining methods into code attributes with type annotations. 8.5.06 DGD-1359 CORE Fixed removal of non-static write-only fields (optimization field/removal/writeonly ). 8.5.06 DGD-1421 GRADLE Added package-info.class files to the default input filter of the gradle plugin. 8.5.05 DGD-1406 GRADLE Removed redundant library jar input when building library projects with Android gradle plugin 3.4+. 8.5.05 CORE Fixed propagation of UnsatisfiedLinkErrors when trying to load missing native libraries with enabled native library encryption. 8.5.05 DGD-1414 CORE Improved detection of hard-coded reflection on class members. 8.5.05 DGD-1374 CORE Updated used kotlin version in sample advanced/Kotlin to 1.3.50 . 8.5.05 DGD-1378 CORE Added support for targeting jvm 1.8 ( jvmTarget = \"1.8\" ) when compiling kotlin code. 8.5.05 DGD-1378 CORE Added support to natively backport usages of the java.lang API introduced in Java 8. 8.5.04 CORE Improved deobfuscation of arbitrary lines when using the -greedy option of the retrace utility. 8.5.04 DGD-1381 CORE Fixed including dependent library projects as -libraryjar input when building library projects. 8.5.04 RUNTIME Fixed potential ANR when running the RootDetector on some Samsung devices. 8.5.04 RUNTIME Fixed crashes an potential false positives when running VirtualEnvironmentDetector on devices with API level < 17. 8.5.04 DGD-1377 CORE Fixed issue in SSLPinning(System)WebViewClient where web pages were loaded in plain text instead of being rendered. 8.5.04 CORE Ensured that the build fails when the dex file overflows and -multidex is not specified in the configuration. 8.5.03 DGD-1354 RUNTIME Fixed potential runtime exception when using the HookDetector on some Pixel 3 devices running Android Q beta 5+. 8.5.03 DGD-1361 CORE Kotlin DebugMetadata annotations are now removed by default unless the kotlin.coroutines.jvm.internal.DebugMetadata class is kept explicitly. 8.5.03 DGD-1372 CORE Correctly disable class level optimizations for classes originating from dynamic feature modules when building app bundles. 8.5.03 CORE Added support for Android Studio 3.5 in the Android Studio plugin. 8.5.03 DGD-1371 CORE Fixed partitioning of injected classes in case they are accessed from multiple dynamic feature modules. 8.5.02 DGD-1366 GRADLE Fixed issue in the Gradle plugin where file dependencies were collected incorrectly when using the Android Gradle plugin version 3.4. 8.5.02 DGD-1365 GRADLE Fixed issue in the Gradle plugin where annotation processor metadata files were not collected in library projects. 8.5.02 JSG-18 CORE Improved reporting of statistics for all processing steps of JavaScript obfuscator. 8.5.02 JSG-37 CORE Improved performance of name obfuscation of JavaScript obfuscator. 8.5.02 JSG-45 CORE Fixed possible NullPointerException in opaque predicate injection of JavaScript obfuscator. 8.5.02 JSG-44 CORE Fixed possible NullPointerException in debugger obstruction of JavaScript obfuscator. 8.5.02 DGD-1349 CORE Added option -greedy to the retrace utility in order to retrace obfuscated classnames in unrecognized lines. 8.5.02 DGD-1357 CORE Added support to retrace stacktraces printed by crashlytics including additional source line information (e.g. at o.afc.b + 45(:45) ). 8.5.01 DGD-1353 RUNTIME Fixed memory protection of executable regions in HookDetector while running on Android Q. 8.5.00 DGD-975 GRADLE Added documentation how to use the secure maven repository to easy integration into gradle. 8.5.00 JSG-2 CORE Added configuration debugging option for JavaScript obfuscator. 8.5.00 JSG-1 CORE Improve shrinking of JavaScript obfuscator by taking variable scopes into account. 8.5.00 DGD-1312 CORE Fixed duplicate execution of DexGuard when building app bundles in combination with the io.fabric plugin (requires io.fabric plugin version 1.31.0+). 8.5.00 DGD-891 CORE Improved -addconfigurationdebugging to reduce false positives. 8.5.00 DGD-1301 CORE Fixed optimization of exceptions as unused parameters. 8.5.00 CORE Fixed printing unintended warnings about constructors when using -virtualizecode . 8.5.00 CORE Updated D8 tool for class conversion to version 1.5.54. 8.5.00 DGD-1280 CORE Further improved multidex partitioning when using application classes extending other classes. 8.5.00 DGD-1280 CORE Fixed multidex partitioning to only perform recursive marking for classes referenced from the attachBaseContext and init methods instead of the whole application class. 8.5.00 CORE Added a command line tool to generate necessary rules to keep everything of an aar file. 8.5.00 DGD-1164 GRADLE Fixed potential warning about dependencies evaluated too early in the gradle plugin. 8.5.00 DGD-951 GRADLE Fixed warning about invalid task inputs in the gradle plugin. 8.5.00 DGD-1276 CORE Fixed optimization of Groovy code constructs causing Dalvik conversion errors. 8.5.00 DGD-1206 RUNTIME Fixed issue relating to the runtime library loading when both HookDetector and RootDetector are used and they encrypted too. 8.5.00 DGD-1058 CORE Take the minSdkVersion attribute into account when using d8 as conversion tool. 8.5.00 CORE Made d8 the default dex conversion mechanism which provides fixes for many device specific bugs. 8.5.00 DGD-1241 RUNTIME Fixed false positives when calling RootDetector.isDeviceRooted . 8.5.00 DGD-2018 CORE Added new option -printresourceusage to print a list of unused resources in the input APK. 8.5.00 DGD-1141 RUNTIME Improved magisk detection. 8.5.00 DGD-1180 CORE Fixed automatic generation of consumer ProGuard rules that accidentally included the inmaindex modifier. 8.5.00 CORE Updated dx tool for class conversion to build tools version 28.0.3. 8.5.00 DGD-1009 CORE Improved obfuscation of DexGuard runtime library. 8.5.00 RUNTIME Added support for inline hook detection. Tools like Frida use inline hooking. 8.5.00 RUNTIME Added a FAST flag to the HookDetector for faster hook detection. 8.5.00 RUNTIME Added a new Runtime API VirtualEnvironmentDetector.isRunningInVirtualEnvironment for virtual environment detection. 8.5.00 RUNTIME Improved security of RootDetector by removing package names. 8.5.00 RUNTIME Improved emulator detection to detect emulators, such as LDPlayer and Nox. 8.5.00 DGD-1072 GRADLE Added support for the Android Gradle plugin 3.4. 8.5.00 DGD-1137 CORE Added new option -printmaindexlist to print why classes are placed in the primary dex. 8.5.00 CORE Added modifier inmaindex to -keep rules to force classes to be put in the maindex. 8.5.00 DGD-521 GRADLE Multidex partitioning has been reworked to be as compatible as possible compared to the Android gradle plugin. 8.5.00 DGD-1093 CORE Improved handling of dynamic features and multidex. 8.5.00 DGD-1077 CORE Improved configuration of the FileChecker class. Upgrade considerations : The JavaScript obfuscator is now included in dexguard.jar instead of being packaged in a separate dexguard-javascript.jar . You should remove the line 'classpath ':dexguard-javascript:' from your build.gradle` file. Multidex partitioning has been reworked to be as compatible as possible compared to the standard Android gradle plugin. As a consequence, the allowmultidexing modifier for -keep rules is enabled by default. To force a specific class to be put in the main dex file you can either add the modifier inmaindex to any -keep rule, or specify a corresponding multiDexKeepFile or multiDexKeepProguard property in your build.gradle script. By default, d8 (default dex conversion tool from the standard Android build tools since v3.2.0), will be used to convert class files to the dex format. In order to use the old, internal conversion mechanism, specify a system property conversion.tool=internal . Alternatively, dx can be activated via conversion.tool=dx (system properties can also be specified in the gradle.properties file via systemProp.conversion.tool=xxx ). Note: in case the WhiteboxCrypto addon is used, it is advised to switch to the internal conversion for performance reasons. Various artifacts included in the distribution are now accessible via a secure maven repository. Version 8.4 February 2019 \u00b6 Support for dynamic features. DexGuard now supports the new Google Play Store app service model, called dynamic delivery. It allows to further reduce the initial application size by installing features on demand. Javascript obfuscation. DexGuard already had a plugin mechanism for third-party obfuscators. It now offers its own implementation with fundamental techniques, smoothly integrated. Improved runtime detections. Various detection mechanism for root or virtual environments and hooking frameworks have been improved. Version Issue Module Explanation 8.4.19 DGD-1345 GRADLE Fixed issue in the Gradle plugin where duplicate classes were collected when dependending on an android library project. 8.4.18 CORE Fixed system property obfuscate.applymapping.conservatively when used in combination with espresso tests. 8.4.17 CORE Added system property obfuscate.applymapping.conservatively to prevent applying new names to explicitly kept classes / members. 8.4.17 CORE Fixed potential build error when combining class encryption with apk processing in rare cases. 8.4.17 CORE Fail the build in case conversion tool d8 is chosen and there are conversion errors. 8.4.17 CORE Enabled -multidex by default when building espresso test apks. 8.4.16 DGD-1341 CORE Improved default configuration for the firebase library. 8.4.16 CORE Improved default configuration to prevent class merging for classes of the Android multidex support library. 8.4.16 DGD-1340 CORE Fixed SSLPinning and SSLPinningWebView samples by updating the used certificates. 8.4.16 DGD-1339 GRADLE Fixed processing of surrogate pairs (used by emoji characters) when using Android gradle plugin 3.3+. 8.4.16 DGD-1335 CORE Improved configuration for latest version of constraint-layout library (v 2.0.0-beta1+). 8.4.16 DGD-1326 GRADLE Added the DexGuard license file to the default input filter the Gradle plugin uses. 8.4.16 PGD-759 CORE Fixed backporting of Java 8 API types when used as parameters in private methods. 8.4.16 PGD-749 CORE Fixed merging of classes containing type annotations with empty targets. 8.4.15 DGD-1334 CORE Improved performance of name obfuscation of JavaScript obfuscator. 8.4.15 DGD-1210 CORE Improved build performance when using -useuniqueclassmembernames . 8.4.15 DGD-1332 CORE Added support for processing dex format 038 when performing apk processing. 8.4.15 DGD-1331 CORE Fixed conversion of not-int instructions when performing apk processing. 8.4.15 DGD-1328 CORE Fixed conversion of consecutive phi nodes when performing apk processing. 8.4.15 DGD-1282 CORE Fixed optimization of final fields that might be accessed before initialization. 8.4.15 DGD-1327 CORE Fixed generation of mapping information in case of class merging. 8.4.15 DGD-1253 CORE Fixed issue in JavaScript obfuscator that could cause IllegalStateException. 8.4.14 DGD-1323 CORE Fixed potential ClassCastException when virtualizing code. 8.4.14 DGD-271 CORE Worked around bug on Android 6/7 devices causing spurious EISDIR error when decrypting encrypted classes (regression introduced due to change of conversion tool). 8.4.14 DGD-1317 CORE Fixed potential build errors when optimizing methods with many parameters. 8.4.14 DGD-1322 CORE Fixed issue in JavaScript name obfuscation that could cause name collisions with undeclared global variables. 8.4.14 DGD-1321 CORE Fixed issue in control flow and arithmetic obfuscation of JavaScript code that could cause name collisions. 8.4.14 DGD-1320 CORE Fixed issue in string encryption of JavaScript obfuscator that could cause name collisions. 8.4.14 DGD-1319 CORE Fixed issue in JavaScript obfuscation of property declarations containing non-ASCII characters. 8.4.14 DGD-1311 CORE Fixed encoding of surrogate pairs contained in Android resource tables. 8.4.14 DGD-1313 CORE Fixed StackOverflowError in name obfuscation of large JavaScript files. 8.4.13 DGD-1304 CORE Fixed potential VerificationError on Android 4.4 when processing the Kotlin coroutines library. 8.4.13 DGD-1298 CORE Fixed optimization of exception handling in Kotlin runtime. 8.4.13 DGD-1301 CORE Fixed optimization of exceptions as unused parameters. 8.4.13 DGD-1276 CORE Fixed optimization of Groovy code constructs causing Dalvik conversion errors. 8.4.13 DGD-1308 CORE Fixed removal of annotation attributes from class members during Gson optimization. 8.4.13 DGD-1307 CORE Fixed potential NullPointerException when using -whyareyoukeeping . 8.4.13 DGD-901 CORE Added support to include a mainDexList.txt file when building app bundles with minSdkVersion < 21 . 8.4.13 DGD-1305 CORE Avoided unnecessary notes about descriptor classes that are not being kept. 8.4.13 DGD-1306 CORE Fixed issue in number obfuscation of JavaScript obfuscator that could cause an IllegalArgumentException . 8.4.12 DGD-1261 CORE Improved loading of applications using -pack option by adding additional fallback mechanisms. 8.4.12 DGD-1266 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked when using javascript library j2v8. 8.4.12 DGD-1275 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked when using React Native. 8.4.12 DGD-1302 CORE Fixed processing of pre-obfuscated native libraries that can not be read by DexGuard. 8.4.12 DGD-1299 CORE Improved default configuration for the wear / wearable support library. 8.4.12 DGD-1292 GRADLE Fixed severity of errors and warnings printed by the DexGuard Gradle plugin (from severity info to warn). 8.4.12 DGD-1296 CORE Fixed usage of signing certificates with DSA signature algorithm and minSdkVersion <= 21 . 8.4.12 DGD-1290 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on some Android 5.1 devices. 8.4.12 DGD-1291 GRADLE Fixed issue in the Gradle plugin where some metadata was generated incorrectly, causing issues with gradle install and Android Studio. 8.4.12 DGD-1288 CORE Improved default configuration for the Firebase Firestore library. 8.4.12 DGD-1284 CORE Improved performance of various processing steps in case many resource files are present. 8.4.12 DGD-1285 GRADLE Fixed issue in the Gradle plugin where changing the outputFile property of a VariantOutput instance could cause a FileNotFoundException . 8.4.12 DGD-1281 GRADLE Fixed issue in the Gradle plugin where building app bundles didn't get configured correctly on Windows. 8.4.12 DGD-1276 CORE Fixed bug in JavaScript obfuscator where parentheses weren't always added around expressions where they are necessary. 8.4.12 DGD-1278 CORE Added additional comments to the file generated by the tasks collectConsumerProguardFiles that state the origin of the rules below them. 8.4.12 DGD-1277 GRADLE Fixed issue in the Gradle where writing out the consumer proguard rules wouldn't be written out correctly when calling the Gradle task collectConsumerProguardFiles . 8.4.12 DGD-1273 GRADLE Fixed building some samples with gradle 4.10+. 8.4.12 DGD-1258 CORE Fixed potential VerifyError in JVM caused by inlining methods from super class. 8.4.12 CORE Improved default configuration for the Google GMS Wallet library. 8.4.11 CORE Fixed potential IllegalStateException(\"unexpected block size\") at runtime when reading encrypted data items. 8.4.11 DGD-1251 CORE Fixed unpacking and filtering of app bundles inside other archives. 8.4.11 DGD-1255 CORE Correctly take property minSdkVersion into account when using an external dex conversion tool. 8.4.11 DGD-1209 GRADLE Added support for the Android Gradle plugin version 3.4. 8.4.11 DGD-1249 CORE Added additional warnings in case obfuscation of JNI interfaces exceeds existing size of string section. 8.4.10 DGD-1242 GRADLE Fixed issue in the Gradle plugin where duplicate class warnings would be emitted when using file dependencies. 8.4.10 DGD-1124 CORE Fixed potential build error while optimizing tail recursion. 8.4.10 CORE Fixed potential NullPointerException when backporting lambda expressions that reference unknown classes. 8.4.10 CORE Fixed potential problem with class encryption on Android 6.0 devices. 8.4.10 DGD-1214 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on some Android 7.1.1 devices. 8.4.10 DGD-1237 CORE Added default configuration for the joda-time-android library. 8.4.10 DGD-1234 CORE Fixed duplicate library jars when building app bundles with dynamic features. 8.4.10 DGD-1229 CORE Fixed NoSuchMethodException caused by Gson optimization of enum types written in Kotlin. 8.4.10 DGD-1230 RUNTIME Fixed false positives in HookDetector in case native libraries are referencing each other. 8.4.10 DGD-1248 GRADLE Fixed usage of DexGuard elements in gradle build scripts when using Kotlin DSL. 8.4.10 DGD-1213 CORE Fixed obfuscation of property names in JavaScript code that occur in property definitions. 8.4.09 DGD-1212 CORE Fixed obfuscation of property names in JavaScript code that occur in destructuring assignments. 8.4.09 DGD-1227 CORE Include information about the conversion tool being used to build the apk. 8.4.09 DGD-1226 CORE Fixed including local variable information when using d8 as conversion tool for debuggable build types. 8.4.09 DGD-1222 CORE Fixed potential problems with class encryption on API 26+ devices. 8.4.09 DGD-1077 CORE Improved configuration of the FileChecker class. 8.4.09 DGD-1211 CORE Fixed incorrect values in enabled column of configuration overview printed out by JavaScript obfuscator. 8.4.09 PGD-745 CORE Fixed IllegalArgumentException for comparison of constant arrays with NaN float/double values. 8.4.09 DGD-1207 GRADLE Fixed issue in the Gradle plugin where too many libraries were included when using the databinding library and Gradle 5+. 8.4.09 DGD-1203 GRADLE Fixed issue where DexGuard wouldn't be executed when using gradle 4.6 in combination with Android gradle plugin 3.2+. 8.4.09 DGD-1205 RUNTIME Fixed potential NullPointerException when calling HookDetector.isAppplicationHooked . 8.4.08 CORE Fixed handling of missing or inaccessible system files in DexGuard runtime. 8.4.08 DGD-1196 CORE Fixed error in Gson optimization that could cause issues during class conversion. 8.4.08 DGD-1087 CORE Added missing case to fix potential verify error on Android 4.4 and below when virtualizing code. 8.4.08 DGD-1199 GRADLE Fixed issue in the Gradle plugin where in library projects Android resources from dependencies could end up in the final aar. 8.4.08 DGD-1197 GRADLE Fixed issue in the Gradle plugin where the default assetInputFilter contained a small mistake where hidden files would be accepted if present in the assets. 8.4.08 DGD-1198 CORE Treating dex files in assets and res directories as plain resource files. 8.4.08 DGD-1168 CORE Fixed potentially printing incorrect warnings during class encryption about not encrypting inner classes. 8.4.08 DGD-1178 CORE Fixed potential build errors when optimizing enums with private instance methods. 8.4.08 DGD-1190 RUNTIME Added hook detection for the linker. 8.4.08 DGD-1181 CORE Fixed runtime library to avoid linker warnings printed to logcat. 8.4.08 DGD-710 FP-ADDON Extended device fingerprinting add-on with new flags DEVICE, SIM_CARD, ADVERTISING_ID, and APP_USER_ID. 8.4.08 DGD-1193 CORE Updated sample license for Android Things samples. 8.4.07 DGD-1049 GRADLE Fixed regression in the Gradle plugin where the DexGuard bundle task was executed when building an apk with Crashlytics (or any other service that requests the mapping file via the variant interface). 8.4.07 DGD-1136 CORE Fix potential runtime exceptions when using class encryption on specific Android 6.x devices. 8.4.07 DGD-1105 CORE Print relevant information when encountering an error during class conversion using dx. 8.4.07 DGD-1179 CORE Added printing notes when encountering unknown classes in configuration options -encryptclasses, -obfuscatecode, and -virtualizecode. 8.4.07 DGD-504 CORE Fixed potential build errors when optimizing Kotlin code that combines let and the Elvis operator ?: . 8.4.06 DGD-1140 CORE Updated version check plugin to include version information in its user-agent settings. 8.4.06 CORE Fixed default configuration dexguard-debug-shrink.pro resulting in missing resource tables. 8.4.06 DGD-1173 CORE Fixed building app bundles when using stable resource ids that exceed the number of existing resource for a given type spec. 8.4.05 DGD-1173 CORE Fixed building app bundles when requesting stable resource ids (using --stable-ids flag to aapt2). 8.4.05 DGD-1174 CORE Fixed potential build error with missing class hierarchies (regression introduced by DGD-1148). 8.4.05 DGD-1172 CORE Fixed issue introduced by DGD-1164 where DexGuard wouldn't be executed when using configure on demand. 8.4.04 DGD-1169 GRADLE Updated samples so they all build with Gradle 5. 8.4.04 DGD-1170 CORE Fixed a potential build error when building app bundles with variable native library encryption (regression introduced by DGD-1070). 8.4.04 DGD-1148 CORE Fixed potential build errors when encrypting certain Kotlin classes. 8.4.04 CORE Improved default configuration for Android Architecture Lifecycle library. 8.4.04 DGD-1164 GRADLE Fixed issue in the Gradle plugin where tasks could be resolved too early when creating dependencies. 8.4.04 DGD-1166 CORE Added the possibility to specify a class input filter for Espresso tests. 8.4.04 DGD-1165 GRADLE Fixed issue in the Gradle plugin where the setup task for an Espresso test could run before the DexGuard task of the main app. 8.4.04 DGD-1163 GRADLE Improved performance of the Gradle plugin for Android Gradle plugin 3.2 and 3.3 support. 8.4.04 CORE Updated Espresso sample to use androidx. 8.4.04 DGD-1113 CORE Added default rules for androidx to the dexguard-espresso.pro default configuration. 8.4.03 DGD-1160 CORE Bump supported bundletool version to 0.5.0 when building app bundles. 8.4.03 DGD-1157 CORE Fixed shrinking of resource values that are only referenced from resource XML files (regression introduced by DGD-1039). 8.4.03 DGD-1158 CORE Fixed retrace tool in case the source file attribute contains digits. 8.4.03 DGD-1156 GRADLE Fixed issue in the Gradle plugin where the build could fail when using build types that have a capitalized name. 8.4.02 DGD-1153 GRADLE Fixed execution of DexGuard when building on Windows platform and using Android gradle plugin 3.2+. 8.4.02 DGD-1149 CORE Fixed name of intermediate apk when using apk processing. 8.4.02 DGD-1152 GRADLE Fixed building debug builds with minSdkVersion of 21+ in the gradle plugin when using Android gradle plugin 3.3.x. 8.4.02 DGD-1150 CORE Fixed run-time API FileChecker.checkAllFiles for app bundles with code that is fused in universal apks. 8.4.02 DGD-1151 CORE Fixed using option -applymapping in combination with injected classes / members. 8.4.01 DGD-1117 CORE Fixed asset encryption compatibility issue with Ionic webview plugin (version 3.0+) 8.4.01 DGD-1118 CORE Fixed issue in JavaScript obfuscator that could prevent app from launching when property access obfuscation is enabled. 8.4.01 DGD-1124 GRADLE Fixed issue in the gradle plugin where an exception would be thrown if you configured splits that resulted in only 1 output apk. 8.4.01 CORE Correctly take plural resources with quantity zero into account when building app bundles. 8.4.01 CORE Prevent potential out-of-memory exceptions when building app bundles in combination with -multidex . 8.4.01 DGD-1070 CORE Added support for splitting encrypted native libraries in app bundles. 8.4.01 DGD-1106 GRADLE The DexGuard Gradle plugin now provides a task to build an Espresso test apk that can test your obfuscated app bundles, see espresso for more info. 8.4.01 DGD-615 GRADLE Updated dexguard-versioncheck plugin to also take beta channels into account when configured accordingly. 8.4.00 GRADLE Fixed usage of consumerRuleFilter in gradle build scripts. 8.4.00 CORE Corrected broken fix for DGD-1083. 8.4.00 DGD-1086 CORE Fixed processing of -keep rules in the presence of -multidex in combination with app bundles and dynamic features. 8.4.00 DGD-438 CORE Added alternative class obfuscation dictionary which avoids use of UTF-8 characters, see default configs . 8.4.00 DGD-438 CORE Updated class obfuscation dictionary. 8.4.00 DGD-1083 GRADLE The DexGuard Gradle plugin now takes abiFilters correctly into account again. 8.4.00 CORE Fixed generation of app bundles in case multidex is needed and dynamic features are included. 8.4.00 DGD-1039 CORE Classes referenced from resource files are now automatically kept when using -adaptresourcefilecontents. 8.4.00 DGD-1046 GRADLE Added additional check in the gradle plugin to prevent dependency chain loops. 8.4.00 DGD-966 GRADLE Added support for the Android Gradle plugin 3.3.0-rc03. 8.4.00 DGD-826 CORE Added support for Javascript obfuscation. 8.4.00 DGD-933 CORE Extended runtime FileChecker with methods to check all files. 8.4.00 CORE Fixed ConcurrentModificationException when build an app bundle with multiple dynamic features including assets for native libraries. 8.4.00 DGD-1000 CORE Fixed reading of resource XML and resource table files in protobuf format wrt to default string values. 8.4.00 DGD-992 GRADLE Added support in the gradle plugin for the option matchingFallbacks to resolve the variants of the dynamic features used when building an app bundle. 8.4.00 CORE Removed obsolete sample basic/JackToolchain . 8.4.00 CORE Added two Android Things samples. 8.4.00 DGD-938 CORE Added samples basic/DynamicFeatures to show-case support for the new Android Dynamic Delivery feature. 8.4.00 DGD-938 CORE Added support for dynamic features (see also sample basic/DynamicFeatures ). 8.4.00 DGD-580 RUNTIME Added support for GOT hook detection. Also, extended support for hook detection in all native shared libraries. 8.4.00 DGD-905 RUNTIME Added support for virtual environment detection to detect virtual plugin apps, such as VirtualXposed. 8.4.00 DGD-828 RUNTIME Enhanced Magisk detection. Upgrade considerations : Runtime method HookDetector.isApplicationHooked now requires an additional Context argument. The Javascript obfuscation plugin mechanism is now replaced with a built-in Javascript obfuscator. Although the plugin API is still available, we recommend to use the built-in obfuscator. You can switch from a custom plugin to the built-in plugin by removing the -javascriptplugin option from your DexGuard configuration. Additionally, you have to provide a proper JavaScript configuration file via the -javascriptconfiguration option. The format and options of the configuration file are documented in the JavaScript manual that is available in the docs/javascript directory of the release. The Gradle plugin has been reimplemented from scratch. This plugin will be used by default with the Android Gradle plugin 3.2 and beyond, older versions will fall back to the previous implementation. You shouldn't notice any differences unless you are using the dexguard block to configure any filters as the syntax has slightly changed. The Gradle plugin has been made more strict and will fail the build when incompatible Android gradle plugin settings are detected. This is the case for both the old and new implementations of the Gradle plugin. The Gradle plugin does not include all optional libraries by default anymore, if you encounter an error like: Can't find common super class of [com/android/volley/toolbox/HttpClientStack$HttpPatch] (with 1 known super classes) and [com/android/volley/Request] , add the following to your build.gradle file: android { useLibrary 'org.apache.http.legacy' } Version 8.3 December 2018 \u00b6 Code virtualization. This advanced obfuscation technique protects algorithms and their implementations. Improved hook detection. We continue to follow up on the latest technologies. Kotlin support. DexGuard has always supported Kotlin, but it now automatically handles corner cases and optimizes common constructs. GSON optimization. Many Android developers rely on Google's GSON library to create JSON strings. DexGuard now optimizes the convenient but inefficient usage, and improves its obfuscation. Support for app bundles. DexGuard now supports this new format to upload apps to the Google Play store. It allows Google to further optimize downloads for individual end-users, by only packaging the necessary resource files, languages, native libraries, etc. Compatibility with Google Play metadata. Google Play automatically injects metadata into all uploaded apps. This process doesn't interfere with DexGuard's tamper detection techniques. Compatibility with Google Play signing. Google Play optionally signs the apps for developers, if they provide their keys. This process is a bit more intrusive, but it is still compatible with 2 out of 3 of DexGuard's tamper detection techniques. Apk signature scheme v3. The next app signature format, supported as of Android Pie, supports key rotation (developers can switch certificates when they release updates of their apps). Support for D8. DexGuard can convert optimized and protected code with its own internal compiler, with Google's DX compiler, or with the latest D8 compiler. Support for Espresso. DexGuard now works with Android's Espresso testing framework. Version Issue Module Explanation 8.3.15 DGD-1059 CORE Updated Android Studio plugin with recently added configuration options. 8.3.15 DGD-1136 CORE Fixed potential FileNotFoundException when decrypting encrypted classes on specific devices (Android 6.0). 8.3.15 DGD-1124 GRADLE Fixed inconsistency in the gradle plugin with the directory tree when splits were configured that resulted in only 1 output. 8.3.15 DGD-1111 CORE Added check to prevent incredibly small chance of creating invalid files when encrypting native libraries. 8.3.14 DGD-1132 CORE Fixed loading of encrypted native libraries with dependencies. 8.3.14 CORE Added additional fallback locations for loading encrypted classes on API 21+ devices. 8.3.14 DGD-1131 CORE Fixed retrace utility to correctly retrace obfuscated stacktraces with omitted colon before linenumber. 8.3.13 CORE Improved mechanism to determine potential locations for loading decrypted classes. 8.3.13 DGD-1126 CORE Fixed unnecessary compression of WEBP assets. 8.3.13 DGD-1125 CORE Ensure unique resource file names when building app bundles. 8.3.13 DGD-1092 CORE Fixed regression for fonts in different configurations. 8.3.13 DGD-1123 GRADLE Fixed issue in the gradle plugin where classes processed by transform tasks with a limited scope didn't get picked up by DexGuard. 8.3.13 CORE Fixed writing of referenced attribute values in protobuf format. 8.3.12 DGD-1114 CORE Fixed issue with Gson optimization that could cause StackOverFlowError when a serialized class extends a class with many descendants. 8.3.12 DGD-1110 CORE Excluded module-info.class files by default. 8.3.12 DGD-1085 CORE Fixed regression for DGD-185 which disabled signature scheme v2. 8.3.12 DGD-1115 CORE Fixed optimization of ProcessBuilder. 8.3.12 DGD-1092 CORE Fixed name obfuscation of font resources in App Bundles. 8.3.11 DGD-968 CORE Fixed backporting of lambda expressions inside default interface methods. 8.3.10 DGD-1087 CORE Fixed potential verify error on Android 4.4 and below when virtualizing code. 8.3.10 CORE Ensure closing of file resources when using the FileChecker of the DexGuard runtime library. 8.3.10 DGD-1085 GRADLE Fixed implicit usage of apk signature scheme v3 if v2 is disabled via the gradle DSL. 8.3.09 CORE Fixed injection of unneeded decryption code for encrypted resources in included library code. 8.3.09 DGD-1081 CORE Fixed issue in Gson optimization when using custom TypeAdapters for primitive types. 8.3.09 DGD-1076 CORE Fixed NullPointerException when using -addconfigurationdebugging in library projects. 8.3.08 DGD-1073 CORE Fixed issue with class merging that could cause problems with Gson library. 8.3.08 DGD-1074 CORE Refined configuration for the Google client API. 8.3.08 DGD-1062 CORE Added verbose statistics for Gson optimization. 8.3.08 DGD-1071 GRADLE Fixed gradle plugin to take modified output filenames correctly into account. 8.3.08 DGD-1063 CORE Updated default configuration to support recent changes in the Samsung store. 8.3.08 DGD-1069 CORE Fixed generation of app bundles in combination with native library encryption. 8.3.07 DGD-1067 CORE Added support for Android Studio 3.3 in the Android Studio plugin. 8.3.07 DGD-1068 GRADLE Fixed small issue in the gradle plugin where task dependencies on tasks from different projects couldn't be resolved. 8.3.07 DGD-1066 CORE Fixed encryption of resource strings. 8.3.06 CORE Fixed espresso test support by ensuring that no additional obfuscation is performed on the test apk. 8.3.06 DGD-1029 CORE Fixed NoSuchMethodException introduced by Gson optimization when using Gson version before 2.7. 8.3.05 DGD-1057 CORE Fixed potential build errors when performing debug builds using dx as conversion mechanism. 8.3.05 DGD-1027 GRADLE Fixed issue in the gradle plugin where creating a signed app bundle via Android Studio created an unsigned app bundle. 8.3.05 DGD-1051 GRADLE Fixed issue in the gradle plugin where instant run builds would fail. 8.3.04 DGD-1054 CORE Fixed writing of consumer proguard rules in library projects having consumer proguard rules but no API keep rules. 8.3.04 DGD-1024 CORE Fixed issue in resource name obfuscation that caused problems with ConstraintLayouts. 8.3.04 DGD-1049 GRADLE Fixed issue in the gradle plugin where the DexGuard bundle task is always executed when building an apk if the Crashlytics gradle plugin is used. 8.3.04 CORE Fixed encryption of string resources which are referenced from resource XML files in case of multiple configurations. 8.3.04 DGD-1050 CORE Fixed obfuscation of enums in annotations, for conversion by dx or D8. 8.3.04 DGD-1044 CORE Fixed NullPointerException during Gson optimization when field type of a serialized class is a class that is not processed by DexGuard. 8.3.04 DGD-1021 CORE Fixed backporting of default interface methods that reference private inner classes / members. 8.3.04 DGD-1040 GRADLE Fixed issue in the gradle plugin where bundle split options weren't picked up correctly. 8.3.03 DGD-1036 CORE Avoiding unpacking archives from the assets directory. 8.3.02 GRADLE Removed check for incompatible settings in the gradle plugin when apk processing is enabled. 8.3.02 DGD-1031 CORE Fixed loading of encrypted classes when used in combination with -obfuscatecode and strength medium or high on Android devices with API 26+. 8.3.02 DGD-996 CORE Fixed conversion of classes that contain large arrays when using dx or d8. 8.3.02 DGD-1033 CORE Fixed issue in Gson optimization that could result in constructors with invalid access modifiers. 8.3.02 CORE Write local variable information in dex format when keeping the LocalVariableTableAttribute . 8.3.02 DGD-980 CORE References to color attributes inside selector drawable XML's are no longer inlined (it may break the correct rendering of the drawable). 8.3.01 CORE Disabled resource deduplication and resource compaction optimizations. You can enable them again by including 'dexguard-resource-optimizations.pro' as the first configuration file. 8.3.01 DGD-1020 GRADLE Fixed dependency issue in the gradle plugin where the DexGuard task for app bundles was also executed when building an Espresso test. 8.3.01 DGD-1019 GRADLE Fixed issue in the gradle plugin where not all compile-only dependencies were picked up correctly. 8.3.00 CORE Updated sample advanced/Realm to the latest realm version 5.8.0. 8.3.00 DGD-1008 CORE Fixed NoClassDefFoundError during Gson optimization when running DexGuard standalone. 8.3.00 CORE Default configuration for androidx ( dexguard-androidx.pro ) is now included by default. 8.3.00 CORE Fixed loading of native libraries from encrypted classes (regression due to DGD-555). 8.3.00 DGD-812 GRADLE Added support in the gradle plugin for the matchingFallbacks option when collecting consumer proguard files. 8.3.00 DGD-974 CORE Enabled dx as default dex conversion mechanism. 8.3.00 DGD-986 CORE Removed setting encrypt.classes.showlog . 8.3.00 DGD-555 CORE Improved loading of encrypted classes on API level >= 26. 8.3.00 DGD-973 CORE Added new option -randomizationseed to provide an additional value that will be taken into account when generating a seed value to randomize the obfuscation. 8.3.00 DGD-967 GRADLE Improved performance of gradle plugin by evaluating dependencies at most once. 8.3.00 DGD-976 CORE The license check will now accept certain named suffixes when added to valid package names: .test, .dev, .qa, .debug, .alpha, .beta . 8.3.00 GRADLE Fixed building of app bundles when calling gradle with an absolute task path as start parameter, e.g. :app:bundleRelease . 8.3.00 GRADLE The gradle plugin will now fail the build when encountering incompatible settings for build variant configured for DexGuard. 8.3.00 CORE The FileChecker returns now a distinct error code if the control manifest is missing. 8.3.00 DGD-937 CORE Added support to include the mapping file when creating app bundles. 8.3.00 DGD-741 CORE Added support to preserve parameter names when applying -obfuscatecode or -virtualizecode on methods. 8.3.00 DGD-913 RUNTIME Added support for multiple digest algorithms when performing file-level tamper detection using the FileChecker (supported by default SHA1 and SHA-256). 8.3.00 DGD-931 CORE Added verbose output about removed resource entries and meta-data elements. 8.3.00 DGD-924 CORE Fixed encoding of file type for raw xml resources when building app bundles. 8.3.00 DGD-929 CORE Fixed support for using the FileChecker when building app bundles. 8.3.00 DGD-908 CORE Fixed references to resource files outside of the res directory when creating app bundles. 8.3.00 DGD-923 CORE Fixed handling of resource files in combination with -keepresourcefiles rules when creating app bundles. 8.3.00 DGD-921 CORE Fixed writing of resource XML files in protobuf format when creating app bundles. 8.3.00 DGD-921 CORE Fixed encoding of attributes encountered in resource tables when creating app bundles. 8.3.00 CORE Fixed encoding of some id resources in the resource table when creating app bundles. 8.3.00 DGD-909 CORE Fixed encoding of some configuration values in the resource table when creating app bundles. 8.3.00 DGD-906 CORE Improved obfuscation of target activity names in activity aliases. 8.3.00 DGD-892 CORE Invalid use of wildcards <fields> and <methods> in member specifications will now result in a ParseException. 8.3.00 DGD-896 CORE Fixed apk processing in case of implicit conversion of boolean values to integers. 8.3.00 CORE Added manual page about upgrading from ProGuard. 8.3.00 DGD-591 CORE Improved initialization and logging of reflection calls. 8.3.00 CORE Fixed backporting of default interface methods if an interface extends another one. 8.3.00 CORE Updated D8 to version 1.2.38. 8.3.00 DGD-809 CORE Fixed potential VerifyErrors in obfuscated code attributes due to an invalid assumption about the instance variable. 8.3.00 DGD-824 GRADLE Added support for apk signature scheme configuration in SigningConfig elements of gradle buildscripts. 8.3.00 DGD-824 CORE Added new option -apksignatureschemes to control the use of apk signature schemes. 8.3.00 DGD-874 CORE Ensure deterministic results when enabling class encryption. 8.3.00 DGD-875 CORE Fixed potential NullPointerException at runtime when obfuscating attachBaseContext(Context) methods. 8.3.00 PGD-708 CORE Fixed possible JVM runtime verification error due to exception handlers in Kotlin initializers. 8.3.00 PGD-709 CORE Improved error messages for problems parsing wildcards. 8.3.00 DGD-722 CORE Fixed potential VerifyError in optimized exception handlers. 8.3.00 PGD-712 CORE Fixed NullPointerException triggered by module-info classes with requires without version. 8.3.00 DGD-353 GRADLE Added improved support for Espresso tests , see also sample advanced/Espresso . 8.3.00 DGD-727 GRADLE Added support for app bundles (requires Android gradle plugin 3.2.0+). 8.3.00 DGD-360 CORE Added code virtualization with new option -virtualizecode . 8.3.00 DGD-719 CORE Added optimization for usages of the Gson library for serializing and deserializing Json. Upgrade considerations : The additional plugin dexguard-partial which was only used as a work-around in some cases when using the Android gradle plugin 3.0.X has been removed. It is highly recommended to upgrade the Android gradle plugin to at least version 3.1.0 or later. Replaced system properties omit.signature.scheme.v2 and enable.signature.scheme.v3 with configuration option -apksignatureschemes . When using gradle to build an application, consider using the v2SignatureEnabled property from the Android Gradle DSL instead. Keep rules for Gson annotated classes have been moved from dexguard-common.pro to dexguard-gson.pro . The newly introduced Gson optimization should remove the need for explicitly keeping these classes. You should try including dexguard-gson.pro in your configuration if there is an issue with Gson after upgrading. The gradle plugin will now fail the build if it detects a build variant that is configured for DexGuard but contains incompatible settings (i.e. minifyEnabled=true , multiDexEnabled=true or shrinkResources=true ). When minifyEnabled is set to true and no default DexGuard configuration is provided, the default minification tool of the Android gradle plugin is used instead of DexGuard. By default, dx (tool from the standard Android build tools), will be used to convert class files to the dex format. In order to use the old, internal conversion mechanism, specify a system property conversion.tool=internal . Alternatively, d8 can be activated via conversion.tool=d8 (system properties can also be specified in the gradle.properties file via systemProp.conversion.tool=xxx ). Note: in case the WhiteboxCrypto addon is used, it is advised to switch to the internal conversion for performance reasons. Version 8.2 May 2018 \u00b6 File tamper detection. DexGuard already supports checking the integrity of entire apk files and react, at run-time. It can now additionally check the integrity of any specified files. Hardened native library loading. DexGuard could already encrypt native libraries. It now further hardens the decryption and loading on the device. Javascript encryption plugins. DexGuard could already encrypt Javascript code inside cross-platform apps, e.g. with Cordova. It now provides a plugin mechanism to apply sophisticated external Javascript obfuscators. Improved hook detection and SSL pinning. DexGuard evolves along with the latest technology. Automatic library configuration. DexGuard can now automatically generate ProGuard/DexGuard consumer rules for libraries, for the convenience of the developers who use them. Universal support for stream and date APIs. Recent versions of Java and Android contain new APIs to work with streams and dates. The predominance of older devices in the market practically limits their use. DexGuard now has built-in backporting support to use them across all versions of Android. Resource optimization. DexGuard now optimizes the size of resource configurations in applications. Dex optimization. Developers can now pass collected performance profiles to let DexGuard optimize the structure of dex files, to improve the startup times of applications on older devices. Automatic update checking. DexGuard now comes with an optional plugin to automatically check for available updates. Version Issue Module Explanation 8.2.25 CORE Fixed potentially wrong instructions when calling methods with modified access flags and using an alternative dex conversion tool. 8.2.25 DGD-1006 CORE Fixed issue in the nativeloader where the jvm reference cap could be reached when a large amount of native functions were resolved. 8.2.25 CORE Fixed automatic generation of consumer ProGuard rules in library projects in combination with -repackageclasses '' . 8.2.25 DGD-1017 RUNTIME Improved resilience of TamperDetector of the DexGuard runtime library. 8.2.25 DGD-1014 CORE Fixed verification errors when accessing resource strings inside constructors and using -encryptresources . 8.2.24 PGD-730 CORE Fixed infinite loop in optimization. 8.2.24 DGD-1011 CORE Consumer ProGuard rules are now always included in AAR's, even when -printlibraryconfiguration is specified; rules generated by DexGuard are still excluded from the AAR in that case. 8.2.24 DGD-1013 GRADLE Fixed issue in the gradle plugin where native libraries were included multiple times when multiple transform tasks are active. 8.2.24 DGD-1012 GRADLE Fixed issue in the gradle plugin where the incorrect class files were used when multiple transform tasks are active. 8.2.24 DGD-995 CORE Fixed invalid rule suggestions when using -addconfigurationdebugging in case of array types. 8.2.24 CORE Fixed Ionic sample (samples/advanced/Cordova/Ionic). 8.2.23 DGD-948 CORE Fixed unwanted renaming of explicitly kept class member names. 8.2.23 DGD-994 CORE Fixed issue with kept class members being potentially obfuscated / shrunk after class merging. 8.2.23 PGD-731 CORE Fixed incorrect error message about generics in wildcard expressions. 8.2.23 DGD-989 CORE Fixed -addconfigurationdebugging in case of null parameters for certain reflection methods. 8.2.23 DGD-984 CORE Fixed Android studio plugin to support the asapi modifier. 8.2.22 DGD-965 CORE Added support for navigation resources. 8.2.22 CORE Fixed backporting of default interface methods in case the method is called with Interface.super.defaultMethod() and the class does not directly implement the interface. 8.2.22 CORE Fixed SSLPinningWebViewClient and SSLPinningSystemWebViewClient when trying to request non-existent URL's. 8.2.21 CORE Fixed backporting of default interface methods in case of an extension interface. 8.2.21 DGD-971 CORE Added class SSLPinningSystemWebViewClient to the DexGuard runtime library to support SSL pinning in Cordova applications. 8.2.21 DGD-969 CORE Fixed generation of mapping files in combination with class encryption which lead to duplicate entries. 8.2.21 DGD-964 GRADLE Fixed issue where the gradle plugin would add compileOnly dependencies as injar instead of libraryjar. 8.2.21 DGD-959 GRADLE Fixed potential build error when setting minifyEnabled=true for some build variants and using the Android gradle plugin 3.2.0+. 8.2.21 DGD-960 GRADLE Fixed issue in the gradle plugin where java resources weren't picked up due to the previous change when using the Android gradle plugin version 2.3. 8.2.20 DGD-960 GRADLE Fixed issue in the gradle plugin where java resource files ended up in the root of the apk instead of in the right directory structure. 8.2.20 DGD-959 GRADLE Fixed crash in gradle when using the fabric gradle plugin version 1.26.0+ with Android gradle plugin 3.2.0+ and the DexGuard gradle plugin. 8.2.20 DGD-958 CORE Fixed native library name obfuscation in library projects. 8.2.20 DGD-955 CORE Kotlin Metadata annotations are now removed by default in Android library projects unless the kotlin.Metadata class is kept explicitly. 8.2.20 GRADLE Updated inputFilter in gradle plugin to prevent that kotlin source files end up in the output by accident. 8.2.20 CORE Fixed potential build error when using D8 as dex conversion mechanism due to aggressive optimization. 8.2.20 CORE Fixed processing of native renderscript libraries included in build tools 28.0.3. 8.2.19 CORE Added default configuration for files with .mov extension. 8.2.19 DGD-952 CORE Fixed generation of mapping files for methods whose code has been obfuscated and contain inlined methods. 8.2.19 DGD-950 CORE Fixed generation of mapping files in case of inlined methods avoiding duplicate entries. 8.2.17 DGD-927 CORE Updated filedictionary.txt to avoid characters which are no longer supported by the Google Play Store. 8.2.17 DGD-927 CORE Updated resource string encryption to avoid encoding characters in the resource table that are no longer supported by the Google Play Store. 8.2.17 GRADLE Fixed gradle plugin to include consumer Proguard files when building library projects with Android Gradle plugin 3.2.0+. 8.2.17 GRADLE Fixed build error in gradle plugin when providing an empty multiDexKeepProguard file. 8.2.17 DGD-943 CORE Fixed support for Android Studio 3.2 in the Android studio plugin. 8.2.17 PGD-720 CORE Fixed unboxed enum types being compared to null. 8.2.17 DGD-942 CORE Fixed shrinking step not always shrinking all unused metadata from AndroidManifest. 8.2.17 CORE Prevent insertion of opaque predicates in interface classes. 8.2.17 CORE Fixed potential NoClassDefFoundError when using -addconfigurationdebugging . 8.2.16 CORE Improved default configuration for Google Firebase Analytics library. 8.2.16 DGD-932 CORE Added support for encryption of asset files that are loaded using a variable name and with a access mode specified (access mode will always be ACCESS\\_STREAMING ). 8.2.16 DGD-934 CORE Fixed cordova samples using the EncryptedSystemWebViewClient from the DexGuard runtime library with Chrome v69.0.3497.86+. 8.2.16 CORE Fixed false-positive notes about unkept descriptor classes for injected classes. 8.2.16 CORE Added warning when using -dontshrink in combination with optimization which might result in verification errors at runtime. 8.2.16 DGD-928 CORE Fixed notes about unknown class java.lang.AbstractStringBuilder when using Android SDK 28+. 8.2.16 DGD-926 CORE Fixed incompatibility with older versions of the runtime certificate checker. 8.2.16 DGD-925 CORE Fixed incorrect cleanup of caches by packer on Android 8.0 and higher. 8.2.15 DGD-907 CORE Fixed conversion of checkcast instructions with large variable indices. 8.2.15 DGD-917 RUNTIME Hardened the use of FileChecker in application code; added documentation . 8.2.15 DGD-914 CORE Fixed FileChecker of the DexGuard runtime library when checking files that have been obfuscated. 8.2.15 DGD-822 CORE Fixed potential ClassFormatError due to inconsistent local variable type table in library projects. 8.2.15 RUNTIME Fixed option FAST in root detector of the DexGuard runtime library. 8.2.15 CORE Fixed issue where consumer proguard files weren't picked up when coming from modules in nested subdirectories. 8.2.15 DGD-904 CORE Fixed generation of consumer Proguard file in library projects which might contain invalid modifiers. 8.2.15 DGD-903 CORE Automatically disabled encryption for resource strings that cannot be encrypted (e.g. used as parameter to TextView#setText(int)). 8.2.15 DGD-900 CORE Fixed the DexGuard runtime library when enabling StrictMode in an application. 8.2.13 DGD-879 CORE Added additional debug information in case certain methods could not be converted to dex format. 8.2.13 DGD-888 ADDONS Fixed regression introduced in version 8.2.12 wrt to missing classes. 8.2.13 DGD-884 CORE Fixed obfuscation of unused JNI methods in native libraries. 8.2.13 DGD-853 RUNTIME Fixed false negatives wrt BlueStacks emulator for EmulatorDetector in the DexGuard runtime library. 8.2.13 DGD-718 RUNTIME Fixed false positives for EmulatorDetector in the DexGuard runtime library. 8.2.13 CORE Improved default configuration for Android Architecture Lifecycle library. 8.2.13 DGD-793 CORE Fixed printing notes during the build for generic keep rules not matching any program class. 8.2.12 DGD-852 GRADLE Updated gradle plugin to support gradle 4.9. 8.2.12 GRADLE Fixed gradle plugin to use correct paths for creating mapping files when using Android gradle plugin 2.3 together with splits. 8.2.12 DGD-849 GRADLE Improved support for transform tasks in the gradle plugin when using Android gradle plugin 2.3. 8.2.12 CORE Improved default configuration for the Android support library. 8.2.12 DGD-847 GRADLE The gradle plugin now correctly parses empty lines and comments in files passed to the multiDexKeepFile option. 8.2.12 DGD-848 CORE Fixed potential NullPointerException when using class encryption due to reflection of protected / static methods. 8.2.12 DGD-845 CORE Added default configuration for using AndroidX ( dexguard-androidx.pro ). 8.2.12 DGD-846 GRADLE Added support for the gradle build cache . 8.2.12 DGD-734 RUNTIME Improved performance of root detector, also adding FAST option. 8.2.11 GRADLE Improved Kotlin support in the gradle plugin. 8.2.11 DGD-842 CORE Fixed issue where multiDexKeepProguard files weren't read correctly. 8.2.11 DGD-843 CORE Fixed potential overflow problems due to class encryption when using an alternative dex conversion mechanism. 8.2.11 DGD-841 CORE Fixed incorrect switch-case statements with android.R resources when applying resource optimizations. 8.2.11 DGD-827 CORE Fixed retracing of obfuscated class/method names in some exception messages. 8.2.10 DGD-812 CORE Fixed issue where consumer proguard files weren't picked up when the product flavors in local project dependencies didn't match exactly. 8.2.10 DGD-821 CORE Fixed issue with duplicate resource table type names that breaks resource reflection. 8.2.10 CORE Fixed potential ClassCastException at build time when using -whyareyoukeeping . 8.2.10 DGD-490 CORE Fixed Android Studio plugin inspection to display tooltips for all flags. 8.2.10 DGD-724 RUNTIME Improved performance of HookDetector in the DexGuard runtime library. 8.2.09 CORE Apk Signature Scheme v3 is now disabled by default. You can enable it by setting the system property -Denable.signature.scheme.v3 . 8.2.08 DGD-820 CORE Resource file encryption is now automatically disabled for apps targeting Android P or higher (resource encryption is technically no longer possible on these devices). 8.2.08 DGD-819 CORE Resource table type names are now always preserved (fixes failing APK uploads in the Google Play Store). 8.2.08 DGD-802 CORE Fixed reflection of protected or static methods declared in super classes. 8.2.08 DGD-720 CORE Added support for Apk Signature Scheme v3 and certificate rotation, with a new option -certificatelineage . 8.2.07 DGD-811 CORE Generated consumer rules that are specific to DexGuard are now written to a separate file inside the AAR, 'dexguard.txt' (next to 'proguard.txt'). 8.2.07 DGD-814 CORE Updated samples to load dependent jars from maven instead of redistributing them. 8.2.07 DGD-807 CORE Fixed issue with resource optimizations when resource IDs are assigned to a long variable. 8.2.07 DGD-813 CORE Improved default configuration wrt generated R classes. 8.2.07 DGD-810 RUNTIME Added RootDetector NO_ROOT_MANAGERS flag to disable scanning for root manager apps. 8.2.07 DGD-489 CORE Added inspection descriptions for Android Studio plugin. 8.2.07 DGD-517 CORE Added inspections group display name for Android Studio plugin. 8.2.07 DGD-800 CORE Added support for ConstraintLayout (resources referenced via the 'constraint_referenced_ids' attribute are now automatically preserved). 8.2.07 DGD-789 CORE Fixed potential verification errors at runtime due to code obfuscation being applied to code attributes. 8.2.06 DGD-788 CORE Fixed Android Studio plugin compatibility with Android Studio v3.1+. 8.2.06 DGD-801 CORE Improved multidex processing including some default rules to ensure that classes matching -keep rules end up in the main dex file. 8.2.06 DGD-794 CORE Fixed injection of decryption code for non-encrypted resources when using -encryptresources . 8.2.05 DGD-765 CORE Completed fix for incorrect switch-case statements when applying resource optimizations. 8.2.05 CORE Fixed default settings of dexguard-transform plugin to be compatible with InstantRun. 8.2.05 GRADLE Updated the gradle plugin to support the Android gradle plugin version 3.2.0-beta01. 8.2.05 DGD-792 GRADLE Fixed issue in the gradle plugin where interactions with some versions of some plugins could cause missing Java resources in the resulting apk. 8.2.04 DGD-775 CORE Fixed keeping of onClick handlers defined for MenuItem elements in resource xml files 8.2.03 DGD-783 CORE Fixed apk processing when encountering methods whose code exceeds the 64k limit. 8.2.03 DGD-548 CORE Fixed option -adaptclassstrings if no additional filter is provided. 8.2.03 DGD-742 GRADLE Added support for the Android gradle plugin version 3.2.0-alpha18. 8.2.02 CORE Improved Instant App partitioning. 8.2.02 CORE Added build-time notes and suggestions on Instant App partitioning. 8.2.02 DGD-772 CORE Improved automatic handling of native Facebook libraries. 8.2.02 DGD-768 CORE Fixed NullPointerException during build when specifying -dontobfuscate and -printresourceencryption. 8.2.02 DGD-767 CORE Fixed Resources$NotFoundExceptions when applying resource optimizations. 8.2.02 DGD-765 CORE Fixed incorrect switch-case statements when applying resource optimizations (fixes support for the Android Data Binding framework). 8.2.02 DGD-697 GRADLE Updated the gradle plugin to exclude an additional libraryJar added in the Android gradle plugin version 3.1 that caused duplicate class warnings. 8.2.02 DGD-690 GRADLE Fixed warning caused by the gradle plugin due to using deprecated gradle features. 8.2.02 DGD-770 CORE Fixed processing of obfuscated native libraries. 8.2.02 DGD-769 GRADLE Fixed regression in the gradle plugin where local Java project dependencies caused a build error. 8.2.01 DGD-766 CORE Added support for encrypting strings that refer to obfuscated classes or class members (via -accessthroughreflection,encryptstrings). 8.2.00 DGD-192 CORE Introduced lib/dexguard-nativeloader.aar which if included into the project will provide a more secure way of loading encrypted native libraries. 8.2.00 CORE Added the possibility to encrypt the dependencies of encrypted native libraries without adding additional System.loadLibrary(string) calls. 8.2.00 DGD-672 CORE Updated hashing algorithm of SSLPinning and CertificateChecker from MD5 to SHA-256. 8.2.00 CORE Improved configuration for libGDX. 8.2.00 DGD-286 CORE Improved name obfuscation of encrypted native libraries. 8.2.00 DGD-592 CORE Added fallback mechanism to use D8 (version 1.1.11) from Android SDK for class conversion. 8.2.00 CORE The name of the 'extractNativeLibs' XML attribute in the AndroidManifest.xml is now kept by default (fixes the setting being ignored at runtime). 8.2.00 DGD-138 CORE Disabled optimization code/allocation/variable in the default library release configuration. 8.2.00 DGD-662 CORE Native library dependencies referenced only from other native libraries are now automatically kept. 8.2.00 DGD-541 CORE Removed class com.guardsquare.dexguard.runtime.net.SimpleSSLPinningWebViewClient from the DexGuard runtime library. 8.2.00 DGD-509 CORE Added new option -performanceprofile to optimize app startup performance, based on an hprof file. 8.2.00 DGD-352 CORE Added new option -printlibraryconfiguration for generating an output configuration for library projects requiring additional processing. 8.2.00 DGD-612 GRADLE Added gradle plugin dexguard-transform which provides various features also in non-DexGuard enabled builds (e.g. with active InstantRun). 8.2.00 DGD-197 GRADLE Added gradle plugin dexguard-versioncheck which checks if a more recent DexGuard version is available. 8.2.00 DGD-202 CORE Added support for Javascript obfuscation plugins. Included sample for Cordova and React Native under samples/advanced/Javascript . 8.2.00 DGD-137 CORE Processed native libraries are now stripped more aggressively. 8.2.00 DGD-688 CORE Added support for backporting the Java 8 time API using the threetenbp library (see also sample basic/TimeAPI). 8.2.00 DGD-165 CORE Added support for backporting the Java 8 stream API using the streamsupport library (see also sample basic/StreamSupport). 8.2.00 DGD-579 RUNTIME Improved hook detection for stripped libraries. 8.2.00 DGD-617 RUNTIME Improved hook detection to more reliably detect various known hooking frameworks. 8.2.00 DGD-281 CORE Added section explaining the various default configurations to the manual. 8.2.00 DGD-385 RUNTIME Improved SSL pinning support of the DexGuard runtime library (added hardened class SSLPinner, updated samples). 8.2.00 DGD-572 CORE Added sample 'advanced/Crashlytics' to use the Crashlytics library for Java and native crash reporting. 8.2.00 DGD-523 CORE Updated sample 'advanced/IOCipher' to use latest IOCipher release 0.4. 8.2.00 DGD-395 CORE Improved default configuration for the Facebook Conceal library v2.0+. 8.2.00 DGD-574 CORE Updated sample 'advanced/Conceal' to use latest conceal release v2.0.2. 8.2.00 DGD-569 CORE Updated dx tool as fallback mechanism for class conversion to version 27.0.3. 8.2.00 DGD-387 CORE Added new option -keepcode for keeping code attributes. 8.2.00 DGD-102 RUNTIME Added file-level tamper detection. Upgrade considerations : Additional file lib/dexguard-java8.jar has been removed as it was only needed as a workaround for Android gradle plugin versions [2.1.0, 2.2.0-alpha5]. You should remove the following line classpath ':dexguard-java8:' from your build.gradle file and update to a more recent version of the Android gradle plugin. Class com.guardsquare.dexguard.runtime.net.SimpleSSLPinningWebViewClient has been removed from the DexGuard runtime library, and should be replaced by com.guardsquare.dexguard.runtime.net.SSLPinningWebViewClient . Certificate hashes for SSL pinning and the CertificateChecker now need to be generated with SHA-256. MD5 certificate hashes are no longer valid for SSL pinning and deprecated for certificate checking. Added the lib/dexguard-nativeloader.aar which provides a more secure way to load encrypted native libraries if it is included as a dependency into your project. Due to changes in the internals of the Android OS, resource encryption is no longer supported as of Android P. Resource encryption will therefore automatically be disabled as of DexGuard 8.2.08 if the maxSdkVersion attribute is not present in the Android Manifest, or if it is set to 28 or higher. Version 8.1 Dec 2017 \u00b6 Code packing. DexGuard could already encrypt specified sensitive classes. It can now also efficiently encrypt all combined bytecode as an additional layer of protection. Android Studio plugin. The DexGuard plugin for Android Studio provides syntax highlighting, auto-completion, and highlighting of potentially suboptimal or erroneous configuration. Hook detection. The DexGuard runtime SDK now also provides hook detection, for frameworks like Xposed and Substrate. Instant Instant Apps. DexGuard can now automatically create Instant Apps from traditional installed app projects, without requiring you to manually refactor your code or restructure your projects. Reduce the conversion time from weeks to minutes! Version Issue Module Explanation 8.1.23 DGD-796 CORE Reverted accidental fix for DGD-687 when processing apk files. 8.1.23 RUNTIME Fixed potential crashes when using the hook detection. 8.1.23 GRADLE Fixed regression in the gradle plugin where consumer proguard files in recursive local module dependencies weren't picked up. 8.1.22 DGD-791 SK-ADDON Fixed potential IllegalStateException when detaching the secure keyboard from a layout. 8.1.22 CORE Fixed potential IllegalAccessError when backporting static interface methods. 8.1.21 DGD-787 CORE Fixed issue where local file dependencies cause an ArrayIndexOutOfBoundsException when gathering consumer Proguard files. 8.1.20 DGD-782 GRADLE Fixed issue in the gradle plugin where trying to collect the consumer proguard files of dependencies also ended up downloading the sources of these dependencies. 8.1.20 DGD-786 GRADLE Fixed issue in the gradle plugin where the classes of submodule projects ended up in the libraryJars when building on Windows, causing them to be missing at runtime. 8.1.20 SK-ADDON Fixed processing of the SecureKeyboard addon after change DGD-744. 8.1.20 DGD-777 GRADLE Made the gradle plugin more robust with regards to collecting consumer Proguard rules. 8.1.20 DGD-713 GRADLE Fixed issue in the gradle plugin where dependencies declared as compileOnly were picked up incorrectly and ended up in the apk. 8.1.19 CORE Added default configuration for the IBM MobileFirst library. 8.1.19 DGD-760 CORE Improved default configuration for the Firebase libraries. 8.1.19 DGD-753 GRADLE Fixed issue in the gradle plugin where resources and the Android manifest weren't picked up when using multiple flavor dimensions in combination with splits. 8.1.19 DGD-708 RUNTIME Improved performance of hook detection. 8.1.19 DGD-752 GRADLE Fixed regression in the gradle plugin where the mapping file wasn't set properly when using gradle 4.1+. 8.1.18 DGD-751 WB-ADDON Improved default obfuscation of the whitebox cryptography code. 8.1.17 DGD-744 CORE Ensured that classes of the DexGuard runtime library can be properly obfuscated, regardless of user-defined rules. 8.1.17 DGD-747 GRADLE Fixed issue in the gradle plugin where consumer proguard files from transient dependencies might not be picked up. 8.1.17 DGD-730 CORE Fixed native library encryption on Android P when targetSdkVersion > 24 . 8.1.17 DGD-725 CORE Fixed potential IllegalArgumentException when simplifying null enum values. 8.1.17 PGD-701 CORE Fixed potential VerifyError in the presence of branches to instruction offset 0. 8.1.16 DGD-698 GRADLE Fixed regression in the gradle plugin where when including a local java project as a dependency an exception was thrown at build time claiming the jar could not be found. 8.1.16 DGD-687 CORE Fixed processing of apk files that perform exception handling involving class constants. 8.1.16 CORE Fixed multidex partitioning if more than 10 dex files are needed. 8.1.16 DGD-684 GRADLE Fixed regression in the gradle plugin where apk post-processing was broken. 8.1.16 DGD-681 CORE Fixed backporting of lambda functions using the alternative factory method. 8.1.15 DGD-674 CORE Fixed obfuscation of custom classnames in some resource XML files (related to PreferenceScreen configurations). 8.1.15 PGD-699 CORE Fixed obfuscation of closures that implement multiple interfaces. 8.1.15 DGD-676 GRADLE Fixed issue with the gradle plugin where resources in dependency jar files were not present in the resulting apk when using the Android gradle plugin version 3.1. 8.1.15 DGD-673 CORE Invalid use of generics in a class specification now results in a ParseException. 8.1.15 DGD-668 GRADLE Fixed regression where a warning appeared about duplicate AndroidManifest.xml files when using the Android gradle plugin version 2.3 or lower. 8.1.15 PGD-694 CORE Fixed classes prefix when writing output to directories. 8.1.14 DGD-670 CORE Duplicate resource files are now processed in a pick-first logic. 8.1.13 DGD-640 GRADLE Fixed issue when using DexGuard with the Android gradle plugin v3.1 on a library project where some files were misplaced in the aar. 8.1.12 PGD-186 CORE Added support for Java 10. 8.1.12 DGD-637 GRADLE Updated the gradle plugin to fully support the Android gradle plugin version 3.1. 8.1.12 PGD-698 CORE Fixed possible NullPointerException when parsing configuration. 8.1.12 PGD-693 CORE Fixed obfuscation of closures for functional interfaces with default methods. 8.1.12 CORE Improved default configuration for the Retrofit/RetroFit2 libraries. 8.1.12 DGD-618 CORE Fixed NullPointerException during build if -obfuscatecode was used with a field specification. 8.1.12 PGD-655 CORE Fixed access from static methods to protected methods in superclasses. 8.1.11 DGD-616 CORE Fixed potential 'VerifyError' at runtime when applying code obfuscation to methods with boolean variables. 8.1.11 DGD-609 CORE Now silently ignoring type annotations (unsupported by the Dalvik VM) instead of throwing an UnsupportedOperationException. 8.1.11 DGD-611 GRADLE The gradle plugin now throws an exception when building variants without DexGuard while using the Android gradle plugin v3.0 and Java8 instead of issuing a warning and creating an invalid apk. 8.1.11 DGD-607 CORE Fixed encryption of native libraries that are loaded via System.loadLibrary(String) with a non-constant String argument. 8.1.11 DGD-606 GRADLE Fixed gradle plugin to automatically output encryption mapping information also in library projects. 8.1.11 DGD-605 CORE Added troubleshooting entry for publishing Android applications to AirWatch . 8.1.11 DGD-604 CORE Fixed use of 'com.guardsquare.dexguard.runtime.net.SSLPinningWebViewClient' on older Android devices (< 5.0). 8.1.11 DGD-604 CORE Specify minSdkVersion of '11' for DexGuard runtime library (= Android 3.0 Honeycomb). 8.1.11 DGD-600 SK-ADDON Fixed SecureKeyboardVisibilityListener to return correct visibility on custom 'onBackPressed' event. 8.1.11 CORE Improved default configuration for the Glide library. 8.1.11 DGD-554 SK-ADDON Fixed crash for targetSdk 26 or higher caused by depecrated window types. 8.1.11 DGD-596 CORE Improved default configuration for the CrossWalk/XWalk library. 8.1.11 DGD-597 CORE Improved default configuration for classes extending 'android.view.ActionProvider'. 8.1.10 DGD-595 GRADLE Fixed issue with the gradle plugin where class input wasn't collected when a transform task with multiple class inputs was used. 8.1.10 DGD-594 CORE Added classname filter for mappings loaded via rule '-applymapping' . 8.1.10 DGD-561 CORE Prevent inlining of methods that assign final fields. 8.1.10 DGD-466 CORE Fixed conversion of invocation instructions using range parameters. 8.1.10 DGD-567 CORE Fixed enum unboxing for already obfuscated code. 8.1.09 DGD-588 RUNTIME Fixed false positives for hook detection on armeabi architecture. 8.1.09 DGD-587 CORE Fixed potential NullPointerException at runtime when encrypting strings in classes that extend 'android.content.Context'. 8.1.09 DGD-584 CORE Fixed trimming of strings with control characters in certificates. 8.1.08 DGD-568 GRADLE Fixed issue with the gradle plugin where transformed dependencies were included twice in the DexGuard input. 8.1.08 DGD-577 CORE Fixed potential ClassCastException when encrypting Strings that refer to program classes or program class members. 8.1.08 DGD-480 WB-ADDON Added support for whitebox cryptography in library projects. 8.1.08 DGD-409 WB-ADDON Fixed Android boot loop when using whitebox cryptography on old versions (< 5.0) of Android. 8.1.08 PGD-688 CORE Fixed method type annotations triggering UnsupportedOperationException in optimization pass. 8.1.08 DGD-575 CORE Fixed samples 'basic/AssetEncryptionLibrary' and 'basic/NativeLibraryInLibraryProject'. 8.1.08 DGD-576 CORE Fixed sample 'basic/InstantApp'. 8.1.08 DGD-570 CORE Fixed class conversion using the dx tool in combination with class encryption. 8.1.08 DGD-533 GRADLE Fixed disabling DexGuard for some build types when using Java8 in gradle plugin (requires Android gradle plugin v3.1.0-beta3+). 8.1.08 DGD-154 CORE Added warning when encrypting outer classes without encrypting their inner classes. 8.1.08 DGD-565 CORE Fixed reporting of reason why a class has been kept when using option -whyareyoukeeping . 8.1.08 DGD-564 CORE Fixed backporting of method references to private constructors. 8.1.07 DGD-481 CORE Fixed optimization of instructions potentially causing unexpected error while processing. 8.1.07 DGD-562 CORE Fixed conversion of invalid invoke instructions. 8.1.07 CORE Fixed preverification support for Android library projects. 8.1.07 DGD-84 CORE Fixed parsing of class specifications that contain comments in their member specification. 8.1.07 DGD-556 CORE Fixed regression where consumerProguardFiles weren't picked up from local library project dependencies. 8.1.07 DGD-559 GRADLE Fixed issue with the gradle plugin when using an older version of the Android Gradle plugin together with local file dependencies. 8.1.07 DGD-558 CORE Adding preverification information to Java classes in libraries. 8.1.06 CORE Improved default configuration for library projects that use the DexGuard runtime library. 8.1.06 PGD-662 CORE Fixed obfuscation causing clashing private and default method names. 8.1.06 PGD-654 CORE Fixed processing of MethodParameters attributes with nameless parameters. 8.1.06 DGD-552 CORE Fixed calculation of statistics for generalized field accesses during optimization. 8.1.06 RUNTIME Improved root detection. 8.1.06 DGD-551 RUNTIME Fixed false positives in hook detection. 8.1.06 DGD-160 CORE Added troubleshooting entry for using -accessthroughreflection . 8.1.06 DGD-547 CORE Fixed packaging of local file dependencies in AAR's. 8.1.06 PGD-684 CORE Fixed obfuscation of extensions of functional interfaces that are implemented with closures. 8.1.06 PGD-681 CORE Fixed potential IllegalArgumentException in simplification of tail recursion. 8.1.06 DGD-523 CORE Updated SQLCipher sample to use latest sqlcipher library for android. 8.1.06 DGD-546 CORE Fixed regression potentially causing IllegalStateException while backporting code. 8.1.06 GRADLE Added warning when the minifyEnabled true , shrinkResources true and/or multiDexEnabled true options are used in the build.gradle file. 8.1.06 DGD-544 CORE Fixed automatic handling of reflection with known names on inaccessible fields and methods. 8.1.05 DGD-531 CORE Fixed possible unexpected error (IllegalStateException: Variable too large for instruction new-array) in conversion to Dalvik code. 8.1.05 DGD-516 CORE Fixed samples basic/SSLPinning and basic/SSLPinningWebView. 8.1.05 DGD-476 CORE Fixed issue with asset encryption causing ArrayIndexOutOfBoundsException at build time. 8.1.05 DGD-540 CORE Fixed issue where building a variant with a dependency on a different variant of another project resulted in an apk without a classes.dex. 8.1.05 DGD-524 CORE Fixed sample advanced/Kotlin. 8.1.04 DGD-539 CORE Fixed regression where certain resources weren't detected when product flavors where used resulting in a NullPointerException. 8.1.04 CORE Fixed issue with code obfuscation on older Android devices which might result in crashes of the JIT compiler. 8.1.02 DGD-538 GRADLE Fixed issue with the gradle plugin where the same AndroidManifest.xml was used for all outputs when using the splits option in gradle. 8.1.02 DGD-537 CORE Fixed issue were font families defined in xml files were obfuscated incorrectly. 8.1.02 DGD-535 CORE Fixed conversion to Dalvik bytecode potentially causing VerifyError for allocated registers. 8.1.01 DGD-534 CORE Fixed code obfuscation potentially triggering infinite loop at build time. 8.1.01 CORE Improved vertical class merging. 8.1.01 DGD-530 CORE Fixed memory leak writing compressed zip entries. 8.1.00 CORE Added Android Studio plugin 8.1.00 DGD-394 CORE The names of classes that are passed as arguments to the android.content.ComponentName class are now kept. 8.1.00 DGD-181 CORE Added new encryptstrings modifier for the -accessthroughreflection option, to encrypt all strings that are created for the reflection. 8.1.00 DGD-410 RUNTIME Added hook detection to runtime SDK. 8.1.00 DGD-290 CORE Added new option -pack for packing Android apps. 8.1.00 DGD-477 CORE Added support for the font resource type. 8.1.00 DGD-411 CORE Added new option -instantappfeature for automatically creating Instant Apps. 8.1.00 CORE Added new option -if to allow conditional rules. 8.1.00 CORE Added support for wildcard references in options. 8.1.00 GRADLE Added support for multiDexKeepFile option in gradle. 8.1.00 GRADLE Added support for multiDexKeepProguard option in gradle. 8.1.00 CORE Added support for allowmultidex option in keep rules. 8.1.00 SK-ADDON Added a listener for the visibility of the secure keyboard. 8.1.00 SK-ADDON Added customization options for the secure keyboard. 8.1.00 DGD-473 CORE Fixed possible NullPointerException when backporting closures. Upgrade considerations : The options -printassetmapping , -printresourcemapping , and -printnativelibrarymapping have been combined into a new option -printresourcefilenamemapping , which writes out a single mapping file for all resource file names. Runtime method RootDetector.isDeviceRooted now requires an additional Context argument. Version 8.0 May 2017 \u00b6 Annotation-based configuration. You can now specify configuration directly in the source code using annotations. These configurations are complementary to the existing rules in configuration files such as dexguard-project.txt. Encryption of resource strings and metadata strings. New configuration options support the encryption of resource strings and meta-data values. Improved support for asset and native library encryption. DexGuard can now encrypt asset files and native libraries that are loaded via a variable string, dependent native libraries and native libraries loaded via JNA. Improved statistics and logging. New settings have been added to display detailed statistics on package level as well as details about encrypted content (strings, classes,...) Version Issue Module Explanation 8.0.24 DGD-536 CORE Fixed regression where the AndroidManifest.xml was incomplete for library projects. 8.0.24 DGD-529 CORE Fixed regression where the splits option wouldn't generate different apks. 8.0.23 DGD-527 GRADLE Fixed problem with Kotlin kapt plugin where the gradle plugin would throw an exception. 8.0.23 DGD-526 GRADLE Fixed regression with Android gradle plugin v2.1 and older. 8.0.22 DGD-423 CORE Extended handling of strings whose stored lengths have overflowed in resource files. 8.0.21 DGD-514 CORE Added system properties 'encode.resourcexml.utf16' and 'encode.resourcetable.utf16' as a workaround for system crashes on selected devices. 8.0.20 DGD-511 GRADLE Fixed issue with the gradle plugin where only 1 apk generated with the splits option had a classes.dex file. 8.0.20 DGD-508 CORE Fixed regression, workaround for bug in Android 4.1 and older segfaulting on null parameter annotation sets. 8.0.20 DGD-505 CORE Fixed incorrect generalization of fields with identical names in the class hierarchy. 8.0.19 DGD-486 CORE Fixed potential VerifyError when generalizing classes of method invocations that are not available on all platform versions. 8.0.18 DGD-484 CORE Fixed issue where debug dex tasks would crash due to method ID overflow even though Dexguard handles multidexing. 8.0.18 DGD-488 GRADLE Fixed issue where the AndroidManifest.xml wasn't included in Android libraries when using Android gradle plugin v3.0. 8.0.18 DGD-487 GRADLE Updated the gradle plugin to support the Android gradle plugin v3.1.0-alpha02. 8.0.18 DGD-485 WB-ADDON Fixed NullPointerException when building whitebox cryptography apps in debug mode. 8.0.18 DGD-479 CORE Whitebox encryption options are now included when printing configurations. 8.0.17 GRADLE Tuned the gradle plugin Java8 handling. 8.0.16 DGD-475 CORE Fixed class encryption performance regression. Code obfuscation is now disabled for encrypted classes by default. You can still enable it using -obfuscatecode. 8.0.15 CORE Improved class encryption performance. 8.0.15 GRADLE Added support for gradle version 4.3-rc-1. 8.0.14 DGD-469 CORE Added default keep rules for the Android animation resources support library. 8.0.14 CORE Fixed regression where dex files were missing from build output of variants not using Dexguard. 8.0.12 DGD-468 GRADLE Fixed kotlin classes not being included in resulting apk when using the DexGuard gradle plugin and the Android gradle plugin version 3.0. 8.0.12 DGD-464 GRADLE Different splits now generate different mapping files in the gradle plugin. 8.0.12 DGD-467 GRADLE Fixed setting of mapping file in gradle plugin. 8.0.11 DGD-463 CORE Fixed crash when using Java8 features in debug builds. 8.0.11 DGD-461 GRADLE Fixed apk processing feature in gradle plugin. 8.0.11 DGD-460 CORE Fixed compatibility issue with Crashlytics. 8.0.11 DGD-453 CORE Added class whitelist to the member specializer. 8.0.11 DGD-465 RUNTIME Fixed runtime exception in root detection on Galaxy Tab3 with Android 4.0.3. 8.0.11 DGD-462 CORE Fixed incorrect array optimization when processing already obfuscated code. 8.0.11 DGD-459 CORE Fixed conversion of conditional jumps. 8.0.10 DGD-412 GRADLE Updated gradle plugin for compatibility with Android gradle plugin versions 2.4 and 3.0. 8.0.10 DGD-454 CORE Injected code no longer relies on the Android Crypto provider. 8.0.10 DGD-451 CORE Fixed jar signing with certificates with distinguished names with non-ASCII characters. 8.0.09 DGD-449 CORE Fixed jar signing with certificates with distinguished names with quoted attribute values. 8.0.09 DGD-448 CORE Fixed jar signing with certificates that are not self-signed. 8.0.09 DGD-447 CORE Fixed potential IOException/IndexOutOfBoundsException when processing native libraries. 8.0.08 DGD-446 WB-ADDON Fixed configuration parsing error when using the AES whitebox encryption algorithm in CBC mode. 8.0.08 DGD-442 CORE Fixed potential build error while performing code obfuscation. 8.0.08 DGD-445 CORE Fixed IllegalAccessError when loading encrypted resources on Android 7.0. 8.0.08 DGD-443 CORE Fixed filtering of native libraries from jar files to split apk files. 8.0.07 DGD-441 CORE Reduced runtime memory usage of resource decryption. 8.0.06 DGD-438 CORE Updated dictionaries to avoid characters causing ANR's on some Samsung devices. 8.0.05 DGD-435 CORE Fixed unclosed inputstreams of non-encrypted resource XML's. 8.0.05 DGD-433 CORE Added support for adaptive icons in Android O. 8.0.05 DGD-429 CORE Fixed build error when adding configuration debugging on classes that load resources. 8.0.05 DGD-428 CORE Now ignoring classes in the default package when adapting resource filenames. 8.0.05 SK-ADDON Added an API method to detach the keyboard. 8.0.05 DGD-427 SK-ADDON Fixed issues with secure keyboard being attached to an AlertDialog. 8.0.05 DGD-426 SK-ADDON Fixed secure keyboard overriding the edit text's gravity. 8.0.05 DGD-425 SK-ADDON Added an API method to attach listeners in addition to the secure keyboard's listeners. 8.0.05 DGD-340 SK-ADDON Added an API method to get the height of the secure keyboard. 8.0.05 CORE Updated configuration for the Glide library. 8.0.04 DGD-423 CORE Now handling resource strings whose stored lengths have overflowed in the resource files. 8.0.04 DGD-422 CORE Fixed inlining of boolean metadata into code. 8.0.03 DGD-421 CORE Fixed potential IllegalStateException (variable too large) during conversion to Dalvik bytecode. 8.0.02 DGD-420 CORE Fixed potential ClassCastException in optimization step. 8.0.02 DGD-419 CORE Fixed potential VerifyError when applying encryption in classes with multiple constructors. 8.0.01 CORE Improved default configuration for the Kotlin runtime. 8.0.01 DGD-416 CORE Fixed apk signing when certificate specifies optional email address. 8.0.01 CORE Extended default regular expression of ReTrace. 8.0.00 DGD-405 CORE Fixed potential ArrayIndexOutOfBoundsException in the optimization step. 8.0.00 GRADLE Updated sample Gradle build files to recent Android tools. 8.0.00 DGD-404 CORE Added support for null chunks in resource tables. 8.0.00 DGD-403 CORE Only merging classes with equal class versions. 8.0.00 DGD-402 CORE Fixed potentially incorrect stack sizes when enabling configuration debugging. 8.0.00 DGD-401 CORE Fixed class unwrapping optimization for unusual instantiation code. 8.0.00 DGD-400 CORE Fixed parsing of unsorted styles in string pools. 8.0.00 DGD-398 CORE Improved storage of strings in resource files. 8.0.00 CORE String references are now supported as metadata key names in the Android Manifest. 8.0.00 DGD-294 CORE Added support to print extended statistics with option -printstatistics . 8.0.00 DGD-393 CORE Updated obfuscation dictionaries to avoid characters confusing the Android runtime on some devices. 8.0.00 CORE Improved default configuration for Android support libraries. 8.0.00 DGD-320 CORE Unused string constants matched by an -encryptstrings rule are not encrypted anymore. 8.0.00 DGD-320 CORE The -keep modifier includecode now also prevents string encryption from being applied on matching methods. 8.0.00 DGD-287 CORE Added support to print native library encryption details with option -printnativelibraryencryption . 8.0.00 DGD-287 CORE Added support to print resource encryption details with option -printresourceencryption . 8.0.00 DGD-287 CORE Added support to print asset encryption details with option -printassetencryption . 8.0.00 DGD-287 CORE Added support to print string encryption details with option -printstringencryption . 8.0.00 DGD-287 CORE Added support to print class encryption details with option -printclassencryption . 8.0.00 DGD-256 CORE Improved protection of encrypted classes. 8.0.00 CORE Updated Realm sample to use realm v2.3.2. 8.0.00 DGD-380 GRADLE The Gradle plugin will now automatically generate mapping files in Android Library projects. 8.0.00 DGD-382 GRADLE Improve build time for projects with many product flavors in Gradle plugin. 8.0.00 DGD-353 GRADLE Added support to backport Java 8 language features for instrumentation tests in Gradle plugin. 8.0.00 CORE Unparsed data at the end of resource table chunks are now preserved during processing. 8.0.00 DGD-374 CORE Added support for the resource table library (0x203) chunk type. 8.0.00 DGD-378 CORE Fixed utf8 encoding of resource strings with length >= 128. 8.0.00 DGD-179 CORE Added annotations for -obfuscatecode rules. 8.0.00 DGD-320 CORE The -keep modifier includecode now also prevents code obfuscation and reflection from being applied on matching methods. 8.0.00 DGD-363 CORE Added support to encrypt also dependent native libraries (see SQLCipher sample) which did not work on Android versions < 6.0. 8.0.00 DGD-341 CORE Reduced size of resource table (resources.arsc) in Android application projects. 8.0.00 CORE Added optimizations code/simplification/object for primitive boxing and other object instantiation. 8.0.00 DGD-359 CORE Updated default configuration to keep EnclosingMethod attributes by default. 8.0.00 DGD-357 CORE Fixed potential build error when obfuscating the JNI interface of native libraries (Error string: New string section exceeds the length of the original). 8.0.00 DGD-239 CORE Added sample advanced/JNA. 8.0.00 DGD-239 CORE Added support to obfuscate the file names of native libraries accessed via JNA (using Native.loadLibrary(\"name\", Class)). 8.0.00 DGD-239 CORE Improved default configuration for using the JNA library. 8.0.00 DGD-289 CORE Reduced injected code for encrypted strings that occur more than once in a method. 8.0.00 DGD-354 CORE Improved processing speed of classes containing large arrays (e.g. classes with encrypted strings). 8.0.00 DGD-253 CORE Reduced visibility of encrypted class loading. 8.0.00 DGD-322 CORE Fixed potential problem with conversion of primitive arrays when processing apk files. 8.0.00 DGD-58 CORE Added support for fall-back license files dexguard-license2.txt , etc. 8.0.00 DGD-336 CORE Fixed potential warnings about unnatural loops when processing obfuscated dex files with dex2oat . 8.0.00 RUNTIME Fixed false-positives for root detection. 8.0.00 DGD-325 GRADLE Added instructions how to upload the DexGuard Gradle plugin to a Maven repository. 8.0.00 DGD-273 CORE Random variation is now affected by additional attributes in the Android manifest (packageName, versionCode, versionName). 8.0.00 CORE Fixed null handling in string peephole optimization. 8.0.00 CORE Added sample for the NewRelic analytics library. 8.0.00 DGD-323 CORE Added support to parse url parameters provided to -include and -xxxdictionary rules. 8.0.00 DGD-321 CORE Added support for extractNativeLibs attribute in AndroidManifest.xml. 8.0.00 DGD-291 CORE Improved code obfuscation for simple methods. 8.0.00 DGD-282 GRADLE Fixed detection of configuration changes for incremental builds in Gradle plugin. 8.0.00 DGD-300 CORE Added default configuration for the Facebook Fresco library. 8.0.00 DGD-303 CORE Native libraries whose native methods are being kept are kept as well. 8.0.00 CORE Added default configuration for the OkHttp library. 8.0.00 CORE Added default configuration for the Otto library. 8.0.00 DGD-313 CORE Added optimization class/merging/wrapper to merge wrapper classes with their wrapped classes. 8.0.00 DGD-198 CORE Added optimizations field/generalization/class and method/generalization/class to generalize the classes in field accesses and member invocations. 8.0.00 DGD-285 CORE Added support for encryption of native libraries that are loaded via System.loadLibrary using a variable string argument. 8.0.00 DGD-254 CORE Added support for encryption of assets that are loaded via the AssetManager using a variable string argument. 8.0.00 DGD-193 CORE Added new option -encryptresources for encrypting resource strings. 8.0.00 DGD-312 CORE Added new option -encryptmetadata for encrypting Android Manifest metadata. 8.0.00 DGD-309 CORE Avoiding incompatible class version numbers when merging classes. 8.0.00 DGD-308 CORE Improved shrinking of interface declarations. 8.0.00 DGD-296 GRADLE Changed consumerRuleFilter in Gradle plugin to filter on artifacts (Maven coordinates) rather than file names. 8.0.00 DGD-211 GRADLE Added additional tasks in Gradle plugin to list/collect all consumer ProGuard rules. 8.0.00 CORE Added verbose statistics for inlined meta-data elements. 8.0.00 DGD-179 CORE Added sample basic/Annotations. 8.0.00 DGD-179 CORE Updated configuration to support ProGuard/DexGuard annotations. 8.0.00 DGD-179 CORE Added lib/dexguard-annotations.jar, containing annotations for -keep , -encryptclasses and -encryptstrings rules. 8.0.00 DGD-179 CORE Improved support for annotation-based configurations (annotation types don't have to be kept explicitly anymore). 8.0.00 DGD-302 CORE No longer using internal com.sun API to sign apk files. 8.0.00 DGD-229 CORE Added support for APK signature scheme v2. 8.0.00 DGD-260 CORE Changed loading of default configurations in the Ant plugin to be consistent with other plugins (see upgrade consideration below). 8.0.00 DGD-278 CORE Added fallback mechanism to use dx tool from Android SDK for class conversion. 8.0.00 DGD-111 CORE Added support to include consumer Proguard files from AAR dependencies in Maven plugin. 8.0.00 DGD-111 CORE Updated Maven plugin for Android Maven plugin version 4.4.3. 8.0.00 DGD-183 CORE Added support for custom drawable classes in XML resources. Upgrade considerations : The contents of the folder extras/annotations have migrated to the following locations: lib/annotations.jar has moved to lib/dexguard-annotations.jar lib/annotations.pro has been integrated into the default configuration examples has been replaced by samples/basic/Annotations Default configuration and dictionary files have been removed from lib folder in the DexGuard distribution. The Ant plugin will now load default configurations directly from dexguard.jar similar to other plugins (Gradle, Maven, Eclipse). The file ant/custom_rules.xml has been updated and needs to be copied to the main directory of your Android project. For stand-alone processing, default configurations should be included using their resource path, e.g.: -include /lib/dexguard-release.pro . The consumerRuleFilter extension of the Gradle Plugin has been changed to filter on Maven coordinates rather than on file names (necessary due to changes in the Android gradle plugin 2.3.0). The DexGuard Maven plugin pom descriptor file has been renamed from lib/pom.xml to lib/maven-plugin.xml . -encryptassetfiles [file_filter] now encrypts all assets that match the given file filter - it is no longer limited to files for which a matching AssetManager.openAsset(fileName) invocation is found in the application. These file filters may need to be refined, to prevent assets which are read via other mechanisms from being encrypted. -encryptnativelibraries [file_filter] now encrypts all native libraries that match the given file filter - it is no longer limited to libraries for which a matching System.loadLibrary(libraryName) invocation is found in the processed code. These file filters may need to be refined, to prevent libraries which are read via other mechanisms from being encrypted. Version 7.3 Oct 2016 \u00b6 Version Issue Module Explanation 7.3.25 DGD-407 CORE Fixed potential IllegalArgumentException due to overflow when writing out library code. 7.3.24 DGD-406 CORE Fixed instrumentation for configuration debugging for System.load. 7.3.23 PGD-641 CORE Fixed possible NullPointerException due to optimized enum types. 7.3.21 DGD-393 CORE Removed some characters from obfuscation dictionaries that resulted in problems on some devices. 7.3.21 DGD-392 CORE Fixed simplification of enum types in invokedynamic calls. 7.3.21 DGD-391 CORE Fixed conversion of method references to constructors with parameters. 7.3.21 CORE Added system property to specify an alternative location to use for native library encryption (useful for system/platform applications). 7.3.20 DGD-388 CORE Fixed processing of NOBITS sections in ELF files. 7.3.19 CORE Fixed unwrapping of exceptions for reflected calls. 7.3.19 DGD-322 CORE Fixed potential problem with conversion of primitive arrays when processing apk files. 7.3.19 DGD-376 GRADLE Fixed problem with latest Android Gradle plugin (v2.3.0) in Android library projects with setting publishNonDefault=false . 7.3.18 CORE Encrypted class data can now be embedded inside classes with a build time flag. 7.3.18 CORE Improved performance of encryption plugins. 7.3.18 DGD-336 CORE Fixed potential warnings about unnatural loops when processing obfuscated dex files with dex2oat . 7.3.18 DGD-368 CORE Fixed possible invalid code when simplifying enum types that are stored in arrays. 7.3.18 CORE DexGuard now terminates when an error occurs during parallel optimization. 7.3.17 GRADLE Disabled execution of DexGuard for instrumented test variants in Gradle plugin. 7.3.17 CORE Updated default configuration to fix broken icons in some stores and devices. 7.3.17 CORE Added Cordova 6.0 sample. 7.3.16 CORE Fixed potential build problem with some encryption plugins (fixed regression in version 7.3.15). 7.3.15 DGD-350 CORE Fixed potential problem with Android library projects using class encryption when processed by standard Android tools (i.e. dx). 7.3.15 DGD-349 CORE Fixed default resource encryption plugins for Android runtimes older than API level 9. 7.3.15 DGD-348 CORE Fixed potential performance problems with certain resource encryption plugins. 7.3.15 DGD-244 CORE Fixed conversion of obfuscated exception handlers. 7.3.15 DGD-335 GRADLE Fixed execution of instrumentation tests that require Java 8 conversion in Gradle plugin. 7.3.15 CORE Improved the default configuration for the Google Play Services library. 7.3.14 DGD-344 CORE Fixed potential verification error on Android devices <= 4.4.x when using class encryption. 7.3.14 DGD-342 CORE Fixed Dex conversion of ternary operators with constructors with many arguments. 7.3.14 DGD-343 CORE Fixed VerifyError triggered by merging classes with shrinking disabled. 7.3.13 CORE Fixed NullPointerException during build when applying class encryption. 7.3.13 DGD-332 CORE Fixed invalid class merging for classes referenced from native libraries. 7.3.13 DGD-330 CORE Android Resources instances now always return an up-to-date Configuration object when resources are encrypted. 7.3.12 CORE Reduced injected code size when applying class encryption in library projects. 7.3.12 CORE For library projects, encrypted class data is now stored in the directory matching the package name of the encrypted class. 7.3.12 CORE Fixed conversion of lambda expressions that access protected methods. 7.3.11 CORE Reduced injected code size when applying encryption in library projects. 7.3.11 DGD-324 CORE Fixed handling of CR characters in dictionary files. 7.3.11 SK-ADDON Fixed a bug in the secure keyboard when moving between fields using the 'Next' button. 7.3.11 DGD-315 SK-ADDON Fixed potential NullPointerException in the secure keyboard. 7.3.11 CORE Fixed conversion of lambda expressions with array type parameters. 7.3.10 DGD-318 CORE Fixed conversion of exception handlers in highly obfuscated code. 7.3.10 DGD-317 CORE Fixed problem with string encryption in code with subroutines. 7.3.10 CORE Reduced injected code size for certain string encryption plugins. 7.3.10 DGD-314 RUNTIME Fixed false positives for root detection. 7.3.10 CORE Fixed conversion of method references to private methods. 7.3.09 CORE Added default configuration for the Glide image loading library. 7.3.09 DGD-279 GRADLE Fixed problem with latest Android Gradle plugin (v2.3.0-beta1+). 7.3.09 DGD-311 CORE Fixed possible access error for obfuscated internal classes on Android 4.4. 7.3.09 DGD-310 CORE Fixed native library encryption for declared target API level 25 or higher. 7.3.09 CORE Updated configuration for the Greenrobot EventBus library. 7.3.08 DGD-306 CORE Fixed NullPointerException when applying both String and Class encryption. 7.3.08 DGD-305 CORE Fixed merging of classes sometimes resulting in final methods being overridden. 7.3.08 DGD-304 CORE Fixed potential bug in class encryption when applying code obfuscation. 7.3.08 CORE Fixed adding reflection during apk processing. 7.3.08 DGD-301 FP-ADDON Fixed uniqueness of hardware-based fingerprints in case of a factory reset. 7.3.07 DGD-297 CORE Fixed native library encryption for Android 2.2 and older. 7.3.07 DGD-298 CORE Reduced injected code size when applying String encryption. 7.3.07 DGD-292 RUNTIME Fixed RootDetector: flag ALLOW\\_CYANOGENMOD implicitly enabled NO\\_CIRCUMSTANTIAL as well. 7.3.07 DGD-295 CORE Fixed default encryption plugins for Android runtimes older than API level 9. 7.3.06 DGD-284 CORE Fixed default assumption for StringBuilder.append(Object). 7.3.06 RUNTIME Restored public constants in RootDetector and EmulatorDetector of the runtime library. 7.3.06 GRADLE Fixed duplicate task names in Gradle plugin when using Android Gradle plugin v2.2.0+. 7.3.06 CORE Added debugging output in case a class cannot be written to the output, e.g. due to overflows. 7.3.06 GRADLE Fixed filtering of consumer ProGuard rules in Gradle plugin on Windows platforms. 7.3.05 DGD-283 CORE Fixed potential method size overflow when applying string encryption on classes with many strings. 7.3.05 DGD-280 CORE Fixed too many false-positive notes about classes/methods/fields potentially being used from native code. 7.3.05 DGD-279 GRADLE Fixed problem with latest Android Gradle plugin (v2.3.0-alpha1+). 7.3.05 GRADLE Fixed problem with missing classes whose names are prefixed by '_' when using Android Gradle plugin v2.2.0+. 7.3.05 GRADLE Reverted previous change for packagingOptions in Gradle plugin, they are now applied again as input filter. 7.3.04 CORE Fixed invalid conversion of float arrays when processing apk files. 7.3.04 DGD-263 GRADLE Fixed support for asset files with zip extension in Gradle plugin in combination with Android Gradle plugin v2.2.0+. 7.3.03 DGD-277 CORE Fixed build error when using a string encryption plugin with a try-catch block in its decryptString method. 7.3.03 GRADLE Fixed backporting of Java 8 language features for Android library projects in Gradle plugin. 7.3.03 DGD-236 GRADLE Fixed resolution of AAR dependencies for Android library projects in Gradle plugin. 7.3.03 DGD-274 CORE Ensure fully deterministic generation of dex files. 7.3.02 DGD-275 CORE Reduced number of injected methods and fields when applying encryption. 7.3.02 DGD-276 CORE Fixed missing obfuscation of injected classes due to custom -keep rules. 7.3.01 CORE Improved performance of pluggable String encryption. 7.3.01 DGD-272 GRADLE Fixed problems with external native builds in Gradle plugin (available since Android gradle plugin v2.2.0). 7.3.01 CORE Fixed support for -dontshrink when using encryption. 7.3.00 DGD-271 CORE Worked around bug in Android 6.0 causing spurious EISDIR error when decrypting encrypted classes. 7.3.00 DGD-220 CORE Added sample for Google Play Services SafetyNet library. 7.3.00 CORE Improve performance of internal pattern matching implementation by avoiding unneeded data copying. 7.3.00 DGD-250 GRADLE Packaging options are now applied as output filter in the Gradle plugin. 7.3.00 DGD-101 FP-ADDON Added device fingerprinting SDK. 7.3.00 DGD-261 CORE Added support for Dex format 037 (Android 7+). 7.3.00 DGD-231 SK-ADDON Added secure keyboard SDK. 7.3.00 CORE Added support for class encryption plugins. 7.3.00 WB-ADDON Added whitebox cryptography SDK for encryption/decryption of dynamic data at runtime. 7.3.00 DGD-242 CORE Added support for resource encryption on Android 7.0+ devices. 7.3.00 CORE Improved debugger detection. 7.3.00 DGD-241 CORE Improved emulator detection. 7.3.00 DGD-33 GRADLE Improved input filters for Gradle, Ant and Maven plugins to avoid including DexGuard related configuration files by mistake. Known issues: License files located in the same directory as dexguard.jar can not be found anymore when using Gradle 3.1+. Use a different mechanism to setup your license file as described here . Version 7.2 Jun 2016 \u00b6 Version Issue Module Explanation 7.2.17 DGD-268 Added system property allow.incomplete.class.hierarchy to avoid warnings \"Can't find common super class\". 7.2.17 Fixed removal of constant value attributes from encrypted string fields that are kept via -keep rules. 7.2.16 DGD-267 Locale script, locale variant and extra screen configuration information in the resource tables are now preserved during processing. 7.2.16 Fixed error when applying encryption with the Eclipse plugin. 7.2.15 DGD-264 Fixed attribute strings of inlined string resources in XML resources. 7.2.15 Fixed conversion of stateless method references that require explicit casting. 7.2.14 Fixed conversion of interface method references. 7.2.14 DGD-262 Added support for AppDynamics instrumentation in Gradle plugin. 7.2.13 DGD-259 Fixed conversion of lambda expressions that access private methods. 7.2.13 DGD-258 Fixed conversion of lambda expressions that might shadow lambda expressions in super classes. 7.2.13 DGD-246 Fixed certificate pinning when used in combination with okhttp3 library. 7.2.12 DGD-237 Fixed pluggable encryption when using -dontshrink. 7.2.12 Added configuration for Facebook SoLoader library. 7.2.12 DGD-235 Fixed conversion of methods that re-use a cat1 parameter for cat2 values. 7.2.11 DGD-230 Fixed problem when encrypting string constants that were not inlined by the Java compiler. 7.2.11 Added default configuration for the Firebase library. 7.2.11 DGD-219 Fixed Dalvik variable allocation for large numbers of variables. 7.2.11 Fixed potential error when trying to export an apk with the Eclipse plugin. 7.2.11 Improved error message when building an Android application without including a default DexGuard configuration. 7.2.10 DGD-213 Added default configuration for the RetroFit2 library. 7.2.10 DGD-213 Added default configuration for the Okhttp3 library. 7.2.10 Added default configuration for the Video Experts Group MediaPlayer SDK. 7.2.10 DGD-212 Fixed backporting of lambda expressions with array types as parameter. 7.2.09 DGD-210 Fixed infinite loop in dexopt for classes with many encrypted strings in Android 4.4 and earlier versions. 7.2.08 DGD-208 Fixed processing of apk files that contain already obfuscated code (Google mobile services). 7.2.08 Updated configuration for the Droidsonroids Gif library. 7.2.08 Fixed too many warnings when checking class encryption configuration. 7.2.08 Added support to select the used default configuration in Eclipse plugin. 7.2.08 DGD-38 Fixed potential duplicate constructors when using -encryptclasses . 7.2.08 Updated license agreement. 7.2.07 Improved SSL Pinning: mitigated CVE-2016-2402 and added option to specify custom trust store or trust manager. 7.2.07 Added configuration for the ZBar library. 7.2.06 Output filters are now also applied to classes / resources injected by DexGuard. 7.2.06 DGD-167 Added support to print native library file mappings with option -printnativelibrarymapping . 7.2.06 DGD-167 Added support to print resource file mappings with option -printresourcemapping . 7.2.06 DGD-167 Added support to print asset file mappings with option -printassetmapping . 7.2.06 Fixed wrong removal of interfaces from inner classes in rare cases. 7.2.06 Fixed potential race condition during parallel optimization. 7.2.04 DGD-190 Fixed order of input in Gradle plugin. 7.2.04 Fixed reading of archives in nested directory structures. 7.2.04 DGD-188 Improved initialization of encrypted string data for Android library projects. 7.2.04 DGD-186 Updated Gradle plugin to improve support for integrated ndk builds (avoiding duplicate jar entry warnings). 7.2.04 Fixed hash_certificate tool when retrieving certificates from virtual hosts while using Java 8. 7.2.04 DGD-185 Fixed bug when building library projects with -addconfigurationdebugging enabled. 7.2.04 Updated default configuration for Android library projects to improve compatibility with Android gradle plugin 2.1.0+. 7.2.02 Updated class obfuscation dictionary due to problems on some Samsung devices. 7.2.02 DGD-184 Fixed incorrect parsing of Strings in resources that exceed 32767 characters. 7.2.02 DGD-169 Added support to filter consumer proguard rules from dependencies to Gradle plugin. 7.2.02 DGD-178 Updated Gradle plugin for Android Gradle plugin version 2.2.0-alpha2+. 7.2.02 DGD-182 Fixed reading of zip archives with extraneous bytes. 7.2.02 Improved compatibility of Java 8 support with recent versions of the Android gradle plugin (2.1.0+). 7.2.01 Refined default configuration for runtime invisible annotations (not kept anymore in application projects). 7.2.01 DGD-143 Added support to use class specifications with option -encryptclasses . 7.2.01 Added configuration for @Keep annotation from android support-annotations library. 7.2.00 Added support for configuration debugging with option -addconfigurationdebugging . 7.2.00 DGD-83 Added support for Java 8 language features (lambda expressions, method references, default and static interface methods). 7.2.00 Added support for the Jack&Jill toolchain in the Gradle plugin. 7.2.00 DGD-80 Added support for processing apk files directly. Version 7.1 Jan 2016 \u00b6 Version Issue Module Explanation 7.1.34 DGD-135 Fixed potential dex overflow when keeping EnclosingMethod attributes and using option -multidex . 7.1.34 Added missing -addconfigurationdebugging option when writing out configuration with -printconfiguration . 7.1.33 DGD-174 Fixed obfuscation of injected members in case of asset and native library obfuscation. 7.1.33 DGD-173 Added variation when applying obfuscated names. 7.1.33 DGD-172 Fixed obfuscation of injected members due to custom -keep rules. 7.1.33 Fixed removal of method invocations that have been marked with -assumenoexternalsideeffects . 7.1.32 Added alternative mechanism to store encrypted classes. 7.1.32 Fixed removal of constant pool entries for encrypted classes in unencrypted classes. 7.1.32 Fixed conversion of code with special stack obfuscation. 7.1.32 DGD-170 Fixed potential invalid casts when adding reflection to obfuscated code attributes. 7.1.32 Added configuration for the MorphoSmart library. 7.1.31 Fixed shrinking of nameless parameters attribute. 7.1.31 Added configuration for the Greenrobot EventBus library. 7.1.31 Refined configuration for the Crashlytics library. 7.1.31 Fixed ClassCastException when combining Class encryption with dex splitting. 7.1.31 Fixed repackaging of classes in the default package. 7.1.31 Fixed removal of string constants that have been encrypted in case -dontshrink is enabled. 7.1.31 DGD-155 Fixed potentially missing classes when combining asset, native library or string encryption with class merging. 7.1.31 Class names of encrypted classes are now also encrypted. 7.1.31 Added support to keep the source file attribute for kept classes with system property obfuscate.keptclasses.dontrenamesourcefileattribute . 7.1.30 DGD-162 Fixed adding of native library files outside of the regular lib directory. 7.1.30 Added flag 'enableJava8' to gradle plugin to enable support for Java 8 language features. 7.1.30 DGD-161 Fixed conversion of multi-dimensional boolean arrays. 7.1.29 Added sample basic/Java8. 7.1.29 DGD-83 Added support for backporting of Java 8 language features (lambda expressions, method references, default and static interface methods). 7.1.29 DGD-46 Fixed potential problem \"New string section exceeds the length of the original\". 7.1.28 DGD-158 Fixed potential ClassNotFoundException when applying both class encryption and optimization. 7.1.28 DGD-156 Unsupported use of generics in the configuration will now result in a parsing exception. 7.1.28 Updated Gradle plugin for Android Gradle plugin version 2.2.0-alpha1+. 7.1.28 DGD-115 Gradle plugin will now disable DexGuard if InstantRun is activated. 7.1.27 Fixed support of plugins using Transform API in gradle builds on Windows platforms. 7.1.27 Samsung-specific metadata are now preserved in the default configuration. 7.1.27 DGD-157 Components that have both an intent filter and the exported flag set to false are now name obfuscated. 7.1.27 Added support for the Cordova CrossWalk plugin. 7.1.27 Improved configuration debugging support for loading of classes and native libraries. 7.1.26 Fixed configuration for sample projects NetCipher and SecurePreferences. 7.1.26 DGD-60 Added -keep modifier includecode . This modifier will prevent optimization of code attributes for matching methods. 7.1.26 Added sample advanced/Realm. 7.1.26 Fixed support for latest Realm plugin (0.88+). 7.1.25 Removed restriction on native libraries to be in the 'lib/' folder to get encrypted. 7.1.25 Classes containing attributes that can not be copied will not be considered for merging anymore. 7.1.25 DGD-153 Fixed potential ClassCastException with primitive arrays when obfuscating code. 7.1.25 Improved optimization of already obfuscated bytecode when 'optimize.conservatively' is enabled. 7.1.25 Conversion to Dalvik bytecode will now keep all instructions that might have side-effects. 7.1.24 DGD-152 Fixed NullPointerException while processing native libraries. 7.1.24 DGD-151 Fixed potential IllegalAccessError when applying asset encryption in library projects. 7.1.24 DGD-150 Fixed potential NullPointerException when combining class encryption with multidex. 7.1.24 DGD-149 Fixed incorrect application of negative -keep rules during class encryption. 7.1.24 Fixed potential NullPointerException during DexGuard processing of encrypted resources in case integer resource values are included as type string. 7.1.24 Reduced increase of code size due to automatic code obfuscation applied to classes containing encrypted strings. 7.1.23 DGD-148 Fixed IllegalArgumentException when creating arrays with more than 5 dimensions. 7.1.23 DGD-147 Fixed potential VerifyError when running multidexed applications on Android 4.x devices. 7.1.23 DGD-146 Refined the configuration lib/dexguard-release-aggressive.pro for Dagger 2. 7.1.23 Java classes referenced from native code by name are now excluded from shrinking and obfuscation. 7.1.23 Added warnings for shrunk or obfuscated class members whose names are still present in native code. 7.1.22 Fixed potential VerifyError when combining class encryption with multidex. 7.1.21 Fixed potential VerifyError when running multidexed applications on Android 4.x devices. 7.1.21 Improved shrinking of native libraries. 7.1.21 DGD-142 Fixed potential VerifyError when encrypting classes. 7.1.21 DGD-142 Classes being referred to from XML's are now excluded from class encryption (fixes potential NoClassDefFoundErrors). 7.1.20 Google Play Services version metadata are now preserved in the default configuration, fixing a potential runtime issue with the Play library. 7.1.20 Dependent jars in Android library projects will now be bundled into a single classes.jar, unless -dontobfuscate is specified. 7.1.19 DGD-133 Code obfuscation of methods will now retain source line information. 7.1.19 Fixed potential 'Can't remap constant index [..]' error during DexGuard processing with enabled -obfuscatecode option. 7.1.19 DGD-136 Classes referenced from XML resources (e.g., activities in the Android Manifest) are now excluded again from encryption. 7.1.19 DGD-62 Classes referenced from XML resources are now preserved in the primary dex file, when splitting dex files. 7.1.19 Gradle plugin will throw FileNotFoundException when trying to load a non-existing configuration file using getDefaultDexGuardFile(...). 7.1.19 Include generated class BuildConfig in aar file of Android library projects. 7.1.19 Fixed configuration for vector drawables in Android 4.4 and earlier versions. 7.1.19 Filename extensions are now preserved for application icons. 7.1.18 DGD-128 Fixed duplicate class definition warnings in Android library projects with file-based dependencies. 7.1.18 Added parallel processing of optimization step (Use -Dparallel.threads=XX to override default). 7.1.18 DGD-132 Fixed variable allocation in conversion step. 7.1.18 DGD-131 Fixed build exception when adding asset encryption to classes having a constructor throwing exceptions. 7.1.17 DGD-127 Fixed reflection on inherited protected fields. 7.1.17 DGD-124 Fixed potential verify error in conversion of exception handlers. 7.1.16 Fixed processing of native library files in Android library projects. 7.1.16 Added sample basic/NativeLibraryInLibraryProject to demonstrate the use of native libraries in Android library projects. 7.1.16 Fixed potential duplicate fields when applying code obfuscation. 7.1.14 Fixed NullPointerException when processing library projects. 7.1.14 Fixed incorrect encryption of fonts. 7.1.14 Fixed asset name obfuscation not being applied in some cases. 7.1.14 Added a warning for native libraries that can't be processed and will be copied instead. 7.1.13 Updated configuration for Apache Cordova: missing CordovaWebViewEngine does not create a note message anymore. 7.1.13 DGD-121 Disabled code obfuscation of methods containing monitor instructions. 7.1.13 DGD-117 Fixed incorrect inlining of resource id's referring to resources outside the processed application. 7.1.12 Refined configuration for Google Play Services library. 7.1.12 DGD-114 Fixed possible Verification errors for android applications when using string encryption in combination with method inlining. 7.1.12 Added verbose statistics for created dex files. 7.1.12 DGD-118 Fixed potential ArrayIndexOutOfBoundsException when merging classes with parameter annotations. 7.1.12 Improved shrinking of assets: assets referred to from XML and resource tables are now preserved, asset detection in bytecode has been improved. 7.1.12 DGD-113 Fixed potential IllegalArgumentException during optimization in case of missing super-classes. 7.1.10 DGD-112 The fileSize parameter of the ResourceEncryptionPlugin.encryptResource() method was not always correct and has been removed. You can use the length of the byte\\] parameter instead. 7.1.10 DGD-112 The NativeLibraryEncryptionPlugin.createNativeLibraryEncryptionKey() method now takes an additional approximate fileSize parameter. 7.1.09 Fixed possible IllegalArgumentException when encrypting strings in combination with tail-recursion optimization. 7.1.09 Fixed gradle builds with aar dependencies. 7.1.09 Fixed evaluation order of configuration files in gradle builds. 7.1.08 DGD-109 Fixed possible NoSuchMethodError when applying encryption in combination with -dontshrink. 7.1.08 Updated configuration for libGDX. 7.1.08 Added sample for libGDX: advanced/SuperJumperDemo. 7.1.08 DGD-105 Updated configuration for embedded Android wear apps. 7.1.08 DGD-107 Fixed updating of resource xml files due to obfuscated classes in android library projects. 7.1.08 DGD-106 Updated configuration for applications using JNA. 7.1.07 Improved loading of encrypted native libraries. 7.1.07 Added support for latest retrolambda plugin (3.3.0-beta4+). 7.1.07 Resources with identical values for all device configurations are now inlined. 7.1.06 DGD-99 Added default configuration for Google Maps API key. 7.1.06 Fixed possible NullPointerException when trying to encrypt missing asset files. 7.1.06 Fixed possible IllegalAccessError when accessing annotations at runtime in combination with option -multidex . 7.1.05 DGD-73 Updated configuration for Google Play Services. 7.1.05 DGD-98 Added shrinking and obfuscation of font assets. 7.1.05 DGD-71 Added inlining of Resources#getIdentifier, keeping resource names if inlining is disabled. 7.1.04 Fixed possible NullPointerException during optimization when encrypting strings. 7.1.03 Default configuration file dexguard-library-release-aggressive.pro now allows/requires to specify which API classes to keep. 7.1.03 DGD-86 Now treating ConstantValue attributes as optional for non-static fields. 7.1.03 DGD-96 Added optional attribute filter support for -keepresourcexmlelements option. 7.1.03 Fixed building wear applications with Gradle plugin. 7.1.02 DGD-95 Fixed packaging of the string encryption plugin API. 7.1.02 Fixed configuration of native library encryption in samples. 7.1.01 Added support for Cordova 5.1. 7.1.01 DGD-93 Fixed loading of native libraries from encrypted classes. 7.1.01 DGD-48 Fixed loading of native libraries from split classes. 7.1.01 DGD-91 Fixed inlining of mixed-type metadata. 7.1.01 DGD-94 Fixed certificate checking of the application certificate. 7.1.00 Added obfuscation of code, with new option -obfuscatecode . 7.1.00 Added plugin APIs for custom encryption of strings, assets, resources, and native libraries, with new option -pluginjars . 7.1.00 Added shrinking of native library files. 7.1.00 Added obfuscation of native library file names. 7.1.00 Added shrinking of assets. 7.1.00 Added obfuscation of asset file names. 7.1.00 Added encryption of resources, with new option -encryptresourcefiles . 7.1.00 Added inlining of Android manifest metadata in code. 7.1.00 DGD-68 Updated Android-specific math optimizations. 7.1.00 DGD-82 Keeping Relocation Read-Only (RELRO) information of native libraries in shrinking step. 7.1.00 Renamed dexguard_util.jar to dexguard-runtime.jar and updated package names for its contents. 7.1.00 Updated documentation and examples. Upgrade considerations: DexGuard now removes unused native libraries and asset files, and renames the remaining files. If this causes problems like UnsatisfiedLinkError or FileNotFoundException , you may need to preserve them with their original names, with -keepresourcefiles . DexGuard now offers a few alternative default configuration files, for convenience: the original dexguard-release.pro and the new dexguard-release-conservative.pro (disabling name obfuscation of native methods) and dexguard-release-aggressive.pro (enabling shrinking and name obfuscation of asset files). Version 7.0.1 Dec 2015 \u00b6 Added new option -multidex as an alternative to -splitdexfiles , for convenience and for compatibility. Added support to encrypt native libraries and assets in Gradle library projects. Added configuration for Android Wear. Added configuration for RxJava. Added configuration for JNA. Allowing .so files in res/raw and in assets . Refined filter for runtime classes in org.w3c.dom . Improved license error reporting in Eclipse. Added configuration for the android-gif-drawable library. Improved configuration for the Google Play Services library. Improved configuration for the Realm library. Updated configuration for the ButterKnife 7 library. Fixed configuration for the Cordova library. Refined default configuration for animation holder classes. Added default configuration for design support library. Fixed optimization of complex entries in the resource table. Fixed handling of duplicate keys in the resource table. Fixed spurious incomplete packaging of native libraries. Fixed encoding of section indices in native libraries (DGD-57). Worked around initialized array size bug in Android 4.4 and older. Added support for animator, interpolator, and transition resources. Added support for styled strings. Added support to explicitly keep specified resources from being inlined. Added conversion of Exceptions attributes to Throws annotations. Reduced code size for decrypting encrypted assets. Fixed root detection. Fixed merging of classes with package visible fields. Fixed optimization of non-string resources in Resources#getString. Fixed optimization of resource references in custom styleable attributes. Fixed optimization of resource references in Android manifest. Fixed optimization of references to resource files in XML resources. Fixed optimization of non-string resources in Resources#getString. Fixed optimization of drawable resource references in selectors, etc. Fixed optimization of chained resource references. Fixed optimization of string resources with both styled and unstyled representations. Fixed possible invalid code when simplifying enum types. Fixed NegativeArraySizeException optimizing obfuscated code. Fixed possible type verification error in encrypted classes. Fixed StringIndexOutOfBoundsException obfuscating overlapping native function names. Fixed obfuscation of class names in resource files for DexGuard Standard. Fixed obfuscation of icon drawables in the resource table. Fixed handling of -dontcompress option for obfuscated resource files (DGD-69). Fixed NullPointerException obfuscating native libraries. Fixed ClassCastException while writing native libraries. Fixed loading of native libraries when using -splitdexfile or -multidex option (DGD-48). Fixed ArrayIndexOutOfBoundsException while writing native libraries (DGD-52). Fixed reflection on clone method for arrays. Fixed variable allocation in conversion of obfuscated code. Fixed IllegalStateException in conversion of long method invocations. Fixed conversion of dup/checkcast instruction sequences. Fixed conversion of put/store instructions in complex methods (DGD-70). Fixed NullPointerException in absence of -keepresourcefiles option. Fixed obfuscation of .xml resource file name extensions. Fixed conversion of complex methods with more than 256 local variables. Fixed IllegalStateException converting unusual Kotlin code. Fixed inclusion of application classes in main dex file. Fixed NullPointerException when not specifying expected class members. Fixed UTF-8 encoding for META-INF files. Fixed parsing of license file for Eclipse plugin in path with spaces. Fixed handling of multiDexEnabled and disablePreDex in Gradle plugin. Fixed missing native libraries from library jars in Gradle plugin. Fixed compatibility with Google Services Gradle plugin. Fixed compatibility with io.fabric Gradle plugin. Fixed stand-alone use of the Gradle task. Fixed multi-project builds with Gradle (DGD-85). Fixed backward compatibility of Ant task. Fixed incorrect styling for string resources with identical string values (DGD-64). Fixed market billing sample. Fixed market licensing sample. Creating intermediate classes jar for unit tests in Maven plugin. Updated Gradle plugin for Android Gradle plugin version 1.5.0. Updated Maven plugin for Android Maven plugin version 4.3.0. Fixed market billing sample. Fixed market licensing sample. Fixed signing config for debug builds in samples. Updated documentation and examples. Version 7.0 May 2015 \u00b6 Added optimization and obfuscation of resources, with new options -keepresources and -keepresourcefiles . Added obfuscation of JNI function names in native libraries. Added samples for various common security-related libraries. Added optimized configuration for the Realm library. Added multi-threading for conversion to Dalvik bytecode. Added support for includeLibsJarsFromAar option in Maven plugin. Added support for immediate Android runtime jar in Maven plugin. Skipping DexGuard if no configuration files in Gradle plugin. Improved obfuscation of Application names and ContentProvider names. Improved compatibility with Crashlytics. Refined configuration for possible external org.json library. Changed conversion of multiply instructions, to work around bug in ART 4.4. Changed conversion of switch instructions, to work around bug in ART 4.4. Fixed certificate checking method with string parameter and ok parameter. Fixed configuration for Thread.interrupted(). Fixed possible exceptions while processing generic signatures. Fixed accounting for dependencies with dex splitting. Fixed possible NullPointerException when combining class encryption and dex splitting. Fixed conversion of empty switch instructions. Fixed conversion of NaN constants. Fixed conversion of NoClassDefFoundError handlers for .class constructs. Fixed conversion of obfuscated overlapping catch handlers. Fixed conversion of code with control flow obfuscation. Fixed inclusion of .aar files in Maven plugin. Fixed processing of libraries with library dependencies in Gradle. Fixed late binding of output file name in Gradle plugin. Fixed copying of .a files in Eclipse plugin. Updated Gradle plugin for Android Gradle plugin version 1.2.0. Updated Maven plugin for Android Maven plugin version 4.1.0. Updated documentation and examples. Upgrade considerations: DexGuard now requires a personal license file. You should copy the license file that you receive to your home directory or one of the other supported locations. DexGuard may now optimize and remove Android resources and resource files. If your application accesses some resources in a non-standard way, that is, not using their resource IDs, you may need to preserve them with the new options -keepresources or possibly -keepresourcefiles . You may need to change any references in your Gradle scripts from com.saikoa to our new name com.guardsquare . Version 6.1 Dec 2014 \u00b6 Added optimized configuration for the Paypal card.io library. Fixed IllegalArgumentException during optimization. Fixed escape analysis for desynchronization of methods. Fixed escape analysis with double or long method arguments. Fixed IllegalStateException when combining class encryption and dex splitting. Fixed conversion of monitor exit instructions in try blocks. Fixed conversion of obfuscated overlapping catch handlers. Fixed conversion of unreachable code in obfuscated exception handlers. Fixed conversion of catch handlers without named exceptions. Fixed conversion of scrambled code with temporary registers. Fixed conversion of synchronization code. Fixed handling of encrypted or split exception classes. Worked around bug in ART causing crash. Updated Gradle plugin for Android Gradle plugin version 1.0.0-rc1. Updated documentation and examples. Version 6.0 Sep 2014 \u00b6 Added best practices to the documentation. Added new option -splitdexfile to automatically partition large dex files. Added sample for debug detection, emulator detection, and root detection. Extended sample for tamper detection. Added sample for SSL pinning. Added sample for a web view with asset encryption. Added sample for Apache Cordova with asset encryption. Added optimized configuration for new AdMob library. Added optimized configuration for the Amazon Ads library. Added optimized configuration for the Facebook Conceal library. Added optimized configuration for the OrmLite library. Added optimized configuration for the Retrofit library. Added optimized configuration for the Tapjoy library. Added optimized configuration for the libGDX library. Added optimized configuration for the Java mail library. Added optimized configuration for the LogBack library. Added optimized configuration for the Google Cloud Messaging library. Added configuration for attributes in libraries. Improved configuration for the ButterKnife library. Added support for signing applications with Maven plugin. Added missing support for intent with targetClass in preferences XML. Improved robustness of native library encryption. Worked around bug in ART causing crash. Fixed possible ClassCastException when simplifying enum types. Fixed possible IllegalArgumentException when simplifying enum types with encrypted constant names. Fixed overly optimistic optimization of some Class methods. Fixed possible ClassCastException due to class encryption. Fixed conversion of duplicate annotations. Fixed conversion of overflowing branch instructions. Fixed conversion of overflowing negation instructions. Fixed conversion of empty try blocks. Fixed conversion of parameter names for ART. Fixed class encryption causing verification error. Fixed processing of class names in meta-data elements. Fixed processing of custom classes in res/xml-*/*.xml files. Fixed keeping of onClick handlers with extensions of MenuItem as parameters. Fixed inclusion of libraries in library projects in custom Ant rules. Fixed inclusion of native libraries in Maven plugin. Fixed lazy resolution of input and output files in Gradle plugin. Fixed inclusion of Renderscript support library in Gradle plugin. Fixed finding default configuration files in Gradle plugin in Windows. Fixed keeping of package names in Gradle library plugin. Updated Gradle plugin for Android Gradle plugin version 0.11.1. Updated Eclipse plugin for Android Eclipse plugin version 22.6.3. Updated Maven plugin for Android Maven plugin version 3.9.0-rc.3. Fixed unsuitable builder in library projects in Eclipse plugin. Fixed support for dependencies on aar files in Maven plugin. Updated documentation and examples. Version 5.5 Mar 2014 \u00b6 Added optimized configuration for the Guava library. Added optimized configuration for the SQLCipher library. Added optimized configuration for the Couchbase Lite library. Added optimized configuration for the Ektorp library. Added optimized configuration for the Jackson library. Added optimized configuration for the Nuance Vocalizer library. Added support for lazily specified credentials in Gradle plugin. Fixed encryption of native libraries when not optimizing. Fixed optimization causing NullPointerException during processing. Fixed reflection causing exceptions during processing and execution. Fixed interference between reflection, class encryption, and string encryption. Fixed obfuscation of reference values in custom XML attributes. Fixed handling of library jars in library projects in Gradle plugin. Fixed variable allocation in conversion step. Fixed index overflow for strings in conversion step. Fixed parsing of some unusual characters in ReTrace. Fixed lint checking with Gradle. Fixed instrumentation testing with Gradle. Fixed packaging of resource files from source directory in Ant task. Refined filter for files in META-INF/services in plugins. Refined filter for duplicate Apache http libraries. Added support for 'jniLibs' directive in Gradle plugin. Updated Gradle plugin for Android Gradle plugin version 0.9.0. Updated documentation and examples. Version 5.4 Dec 2013 \u00b6 Added encryption of native libraries. Added preferences in Eclipse plugin to enable or disable processing steps for debug builds and export builds. Sending Eclipse export logs to console panel. Added 'dexguard-library' plugin for Gradle. Updated Gradle plugin for Android Gradle plugin version 0.6.3. Adapted Gradle plugin to work with Android Studio. Updated Maven plugin for Android Maven plugin version 3.8.0. Added support for provided libraries in Maven plugin. Added support for properties in keystore options. Added default filter in Maven plugin to clean up input. Added optimized configuration for the v7 compatibility library. Added optimized configuration for the Apache logging library. Added optimized configuration for the Google Play Services library. Added optimized configuration for the Dagger/ButterKnife libraries. Refined filtering of duplicated Apache http libraries from input. Reduced processing time for string/class/asset encryption. Fixed string encryption and class encryption for Android 1.5. Fixed spuriously incorrect string encryption and asset encryption. Fixed interfering string encryption and asset encryption. Fixed verification error caused by class encryption. Fixed conversion of optimized chained assignments to fields. Fixed conversion of some method invocations with many arguments. Fixed conversion of unused exception handlers. Fixed constructor flag for static initializers. Fixed simplification of redundant boolean variables. Fixed removal of unused parameters from methods with more than 64 arguments. Fixed optimization of caught exceptions passed as parameters. Fixed optimization of throwing exceptions received as parameters. Fixed processing of view elements in layout XML files. Fixed processing of parentActivityName attribute in manifest files. Fixed parsing of additional jar options in Eclipse plugin. Fixed Gradle builds with dependencies on library projects. Fixed releasing of resources in tamper detection. Fixed configuration of Amazon IAP sample. Fixed market detection sample. Updated documentation and examples. Version 5.3 Jul 2013 \u00b6 Improved string encryption. Improved asset encryption. Added Gradle plugin for Android Gradle plugin version 0.5.1. Updated Maven plugin for Android Maven plugin version 3.6.0. Updated Eclipse plugin for ADT release 22. Added configuration for compatibility library. Added configuration for annotated Javascript interface methods. Added configuration for AdMob library. Filtering copies of runtime classes from third-party libraries. Always reading and writing resource files using UTF-8 for Android. Fixed processing of raw resource XML files. Fixed check for numeric resource XML attribute ID. Fixed encoding problem of encrypted assets. Fixed initialization of settings in Eclipse. Fixed version numbers in Maven plugin. Fixed configuration of standard android-maven-plugin goals. Fixed conversion of unusual obfuscated code. Fixed string encryption for JME. Updated documentation and examples. Version 5.2 Mar 2013 \u00b6 Added asset encryption. Extended obfuscation of binary resource XML files. Added Maven plugin. Added alternative ways to configure string encryption. Only preserving v4 fragments when necessary. Fixed class encryption for Android 1.5. Improved class encryption for Android 4.0 and higher. Now including dependent libraries when building library project. Fixed optimization of instanceof test on interface. Fixed exception when adding reflection in large classes. Fixed exception handling of reflected method invocations. Fixed exception when referencing encrypted interfaces. Fixed spurious and rare NullPointerException in encrypted classes. Fixed encryption of empty strings. Fixed encryption of strings in static initializers of interfaces. Fixed handling of non-reachable code in optimization step. Fixed handling of dynamically accessed class members with identical names. Fixed conversion of code invoking methods with many arguments. Fixed conversion of unusual exception handlers. Fixed conversion of enclosing method attributes without methods. Fixed exception converting subtractions with nearly short constants. Fixed exception converting overflowing branch instructions. Fixed automatic recompilation in Eclipse plugin. Fixed use of newly created key store when exporting in Eclipse. Added sample for Amazon In-App Purchasing library. Added sample for automatically removing logging statements. Improved hardening configuration of License Verification Library sample. Updated Ant script and Eclipse plugin for Android SDK Tools r21. Updated documentation and examples. Version 5.1 Oct 2012 \u00b6 Added support for processing Android library projects. Added obfuscation of binary resource XML files. Adapted Eclipse plugin for Android Development Tools revision 20. Adapted Ant rules for compatibility with standard build process. Adapted class encryption for Android 4.1. Fixed class encryption for Android 2.2 and older. Extended automatic detection of reflective access to class members. Improved removal of unused code in optimization step. Improved string encryption for very long strings. Fixed specialization of class member descriptors. Fixed type mismatch of reflected method invocations. Fixed access problems for reflected class member access. Fixed potential overflow of branch offsets in conversion to dex bytecode. Fixed handling of primitive array types in conversion to dex bytecode. Added support for parameter annotations. Fixed conversion of default annotation values to dex bytecode. Fixed conversion of repeated arguments to dex bytecode. Fixed conversion of optimized exception handlers to dex bytecode. Fixed conversion of optimized synchronized methods to dex bytecode. Working around bug in Dalvik VM causing spurious crashes. Added source name debug information for stack traces to dex bytecode. Fixed shrinking of local variable debug information. Fixed handling of duplicate classes in dex files. Fixed handling of merged manifest files. Detecting dynamic method invocations with longer method signatures. Updated documentation and examples. Version 5.0 May 2012 \u00b6 First release of DexGuard. Added support for signing jars, with new options -keystore , -keystorepassword , -keyalias , and -keypassword . Added new archiving options -dontcompress and -zipalign . Added Java to Dalvik bytecode conversion. Added support for apk archives. Added parameter escape analysis. Added parameter modification analysis. Added specialization of field and method descriptors. Added method desynchronization. Added more peephole optimizations. Added Android-specific optimizations. Added obfuscation through introspection. Added string obfuscation. Added detection of WebView.addJavascriptInterface. Now always using UTF-8 encoding for all input and output. Updated documentation and examples.","title":"Release Notes"},{"location":"releasenotes.html#changelog","text":"","title":"Changelog"},{"location":"releasenotes.html#version-927-14-12-2021","text":"","title":"Version 9.2.7 (14-12-2021)"},{"location":"releasenotes.html#improved","text":"Upgrade log4j2 dependency in response to CVE-2021-44228. ( T7315 )","title":"Improved"},{"location":"releasenotes.html#bugfixes","text":"Enhance root detection to avoid false negatives in certain cases when CF-Auto-Root is used. ( T7175 ) Prevent possible LinkageError when making package-private final methods that are shadowed protected. ( T7056 ) Prevent possible buffer overflow during hook detection. ( T6888 )","title":"Bugfixes"},{"location":"releasenotes.html#version-926-07-12-2021","text":"","title":"Version 9.2.6 (07-12-2021)"},{"location":"releasenotes.html#improved_1","text":"Ensure that inlining always respects the code obfuscation configuration. ( T4720 ) Inject the automatic RASP checks more consistently at the start of the application ( T6877 ) Further hardening of the runtime library. ( T3730 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_1","text":"Ensure that the overwriteUnprotected option works for all tasks. ( T7022 ) Fix a NullPointerException originating from isolated processes when enabling ThreatCast. ( T6865 ) Prevent potential non-deterministic DEX files when encrypting assets and/or native libraries. ( T6867 ) Enable configuration updates when performing resource file encryption. ( T7101 ) Prevent wrong appearance of resources with empty attribute values. ( T7053 )","title":"Bugfixes"},{"location":"releasenotes.html#version-925-19-11-2021","text":"","title":"Version 9.2.5 (19-11-2021)"},{"location":"releasenotes.html#improved_2","text":"Add default configuration for Android manifest metadata elements in apps using the Google Play Billing library and Android TV apps using content providers. ( T6638 , T6516 ) Implement additional detection methods for Magisk's Zygisk feature. Improve automatically generated configuration by the DexGuard Gradle plugin. ( T6778 ) Add a seatbelt to detect invalid ThreatCast API keys. ( T6912 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_2","text":"Prevent references to non-existent methods from being injected during JavaScript processing. ( T7012 ) Prevent possible StringIndexOutOfBoundsException when signing the application. ( T7004 ) Prevent possible StackOverflowException in hashCode method when using RASP injection. ( T6826 ) Prevent possible OutOfMemoryError when parsing BundleConfig.pb during input reading. ( T7019 ) Prevent possible UnsatisfiedLinkError when using RASP injection combined with a generic -keepresourcefiles rule. ( T6208 )","title":"Bugfixes"},{"location":"releasenotes.html#version-924-05-11-2021","text":"","title":"Version 9.2.4 (05-11-2021)"},{"location":"releasenotes.html#improved_3","text":"Improve obfuscation of the runtime-library by allowing -encryptclasses to cover sensible injected classes. ( T6617 ) Add new ways to detect emulator x86 image. ( T6589 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_3","text":"Fix Javascript syntax error after processing in for loops containing a binary in-operator. ( T6875 )","title":"Bugfixes"},{"location":"releasenotes.html#version-923-25-10-2021","text":"","title":"Version 9.2.3 (25-10-2021)"},{"location":"releasenotes.html#bugfixes_4","text":"Fix potential false negatives caused by a SIGBUS error in the RootDetector. ( T6824 )","title":"Bugfixes"},{"location":"releasenotes.html#version-922-22-10-2021","text":"","title":"Version 9.2.2 (22-10-2021)"},{"location":"releasenotes.html#added","text":"Additional checks to detect BlueStacks 5 emulators. ( T5521 )","title":"Added"},{"location":"releasenotes.html#bugfixes_5","text":"Prevent possible SecurityException in Android 11 devices due to enabling ThreatCast. ( T6667 ) Fix UnsatisfiedLinkError when generating the protection report on Windows. ( T6683 )","title":"Bugfixes"},{"location":"releasenotes.html#version-921-13-10-2021","text":"","title":"Version 9.2.1 (13-10-2021)"},{"location":"releasenotes.html#added_1","text":"Add support for encrypting styled resource strings. ( T6618 )","title":"Added"},{"location":"releasenotes.html#bugfixes_6","text":"Prevent possible R8 compilation error when using enum default values in an interface definition. ( T6097 ) Fix negative rules failing to exclude optimized resource names. ( T5984 ) Fix potential fatal error during memory allocation on M1-based Macs when generating the protection report. ( T6084 ) Fix potential breaking of 'Hide KPI details' link after clicking on feature impact breakdown in the protection report. ( T327 ) Prevent the introduction of illegal method names during resource file encryption. ( T4478 ) Prevent app from potentially crashing before detected threats are reported to ThreatCast when automatic crashing is on. ( T6133 )","title":"Bugfixes"},{"location":"releasenotes.html#version-920-01-10-2021","text":"","title":"Version 9.2.0 (01-10-2021)"},{"location":"releasenotes.html#codepush-support","text":"We already had support for React Native and Cordova applications, we're adding compatibility with the CodePush service for those apps. CodePush is an App Center cloud service that enables Apache Cordova and React Native developers to deploy mobile app updates directly to their users\u2019 devices. Using DexGuard, it is now possible to secure a CodePush update separately from your app. Read more about the new workflow on our in-depth page . Supporting both platforms: iOS & Android. Zero changes required for existing users of our Javascript obfuscation. Gradle support for processing CodePush update packages.","title":"CodePush Support"},{"location":"releasenotes.html#automatic-rasp-improvements","text":"Our automatic RASP facilities have made another step forward: we can now automatically apply RASP protection in libraries. This means that if you are a library developer, you are not required anymore to rely on manual RASP checks and can use DexGuard to insert all the RASP checks during processing time. We also improved the resilience of our checks, making them harder to identify and remove using static analysis. Enable the use of RASP injection in combination with libraries. Improve the spread of RASP checks in applications. Better hiding of the check within the surrounding code.","title":"Automatic RASP Improvements"},{"location":"releasenotes.html#bugfixes_7","text":"Improve dex file processing to avoid ArrayStoreException when processing large char arrays. ( T6399 ) Upgrade considerations for version 9.2.0 : The armeabi and mips ABI's have been deprecated since August 2017. They are no longer supported for our RASP features.","title":"Bugfixes"},{"location":"releasenotes.html#version-9115-22-09-2021","text":"","title":"Version 9.1.15 (22-09-2021)"},{"location":"releasenotes.html#improved_4","text":"Update manual about the authentication mechanism for the secure Maven repository when using the Kotlin Gradle DSL. ( T6401 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_8","text":"Fix potential unsupported field error when reading app bundles. ( T6306 ) Fix variant resolution error in application projects including a Kotlin multiplatform library project which includes another Kotlin multiplatform library project as a dependency. ( T6388 )","title":"Bugfixes"},{"location":"releasenotes.html#version-9114-15-09-2021","text":"","title":"Version 9.1.14 (15-09-2021)"},{"location":"releasenotes.html#added_2","text":"Improved support for the Android Studio plugin up to stable version 2020.3.1 and development version 2021.1.1. ( T5409 )","title":"Added"},{"location":"releasenotes.html#bugfixes_9","text":"Fix variant resolution error in Kotlin multiplatform library projects when including another Kotlin multiplatform library as a dependency. ( T6167 ) Remove invalid syntax error raised on * symbol in the Android Studio plugin. ( T3976 ) Prevent potential IllegalStateException due to retrieving configuration properties too early in the DexGuard Gradle Plugin. ( T6205 )","title":"Bugfixes"},{"location":"releasenotes.html#version-9113-09-09-2021","text":"","title":"Version 9.1.13 (09-09-2021)"},{"location":"releasenotes.html#bugfixes_10","text":"Prevent InvalidUserCodeException during project evaluation of Dynamic Projects with Gradle 7. Prevent possible emulator detector false positives due to wrongly detected hooking attempts. ( T2637 ) Prevent the printing of a -multidex deprecation warning in the build log when processing Espresso tests. ( T5766 ) Avoid printing invalid Asn1DecodingException message when v4 signing is enabled ( T5637 ) Prevent false positives in virtual environment detector. ( T5989 ) Prevent false positive in hook detector when using Realm in a React Native app ( T6136 ) Prevent app bundle build failures due to the introduction of non-existent language codes. ( T6223 ) Prevent unencryptable resource strings that are referenced from XMLs inside res/values from being encrypted. ( T6200 )","title":"Bugfixes"},{"location":"releasenotes.html#version-9112-19-08-2021","text":"","title":"Version 9.1.12 (19-08-2021)"},{"location":"releasenotes.html#bugfixes_11","text":"Add Crashlytics support for AGP 7. Fix potential runtime crashes due to invalid string decryption parameters. ( T6071 )","title":"Bugfixes"},{"location":"releasenotes.html#version-9111-16-08-2021","text":"","title":"Version 9.1.11 (16-08-2021)"},{"location":"releasenotes.html#added_3","text":"Add support for resource file encryption on Android 12. ( T5833 ) The DexGuard Gradle Plugin now supports AGP 7. ( T5888 ) Add RASP checks to detect Android 12 emulators. ( T6008 ) Add support for detecting BlueStacks 4. ( T5521 )","title":"Added"},{"location":"releasenotes.html#improved_5","text":"Remove restriction where APKs can't be signed with signature scheme v2 when min SDK version is set to 28 or higher and max SDK version is set to 30 or higher. ( T5813 ) Using the fat AAR support for local project dependencies will now match variants. This means that e.g. the debug build type of the library will embed the debug build type of the dependency. Update IOCipher dependency of the IOCipher sample to support running it on Android 12. ( T5898 ) Add additional MagiskHide detection. Update basic/AppBundle sample to work with the latest version of bundletool . ( T5824 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_12","text":"Fix incorrect -raspclassfilter configuration snippet in the RASP manual page. ( T5968 ) Fix duplicate libraryjar when having the same useLibrary library in a dynamic feature and the main module. ( T5967 ) Fix possible Resources$NotFoundException on encrypted resources inside the res/xml folder.","title":"Bugfixes"},{"location":"releasenotes.html#version-9110-06-08-2021","text":"","title":"Version 9.1.10 (06-08-2021)"},{"location":"releasenotes.html#improved_6","text":"Improve root detection checks to detect MagiskHide. Avoid potential false positive while checking for emulator when connected to ethernet via USB ethernet adapter. ( T5541 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_13","text":"Fix potential NullPointerException during Kotlin metadata initialization when using -keepkotlinmetadata . ( T5899 ) Fix input reading of APKs when passed as -libraryjars during Espresso testing. ( T5788 ) Fix potential runtime ArrayIndexOutOfBoundsException in app bundle projects with multiple targetSdkVersions. ( T5535 )","title":"Bugfixes"},{"location":"releasenotes.html#version-919-30-07-2021","text":"","title":"Version 9.1.9 (30-07-2021)"},{"location":"releasenotes.html#added_4","text":"Add support for Kotlin 1.5. ( DGD-3467 )","title":"Added"},{"location":"releasenotes.html#improved_7","text":"Improve reliability of the root detector w.r.t. various SELinux configurations. ( T5264 ) Improve root detection checks to detect MagiskHide. Improved RASP manual about custom application protection. ( T5816 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_14","text":"Fix threat detection potentially occurring before ThreatCast is initialized. ( T5769 )","title":"Bugfixes"},{"location":"releasenotes.html#version-918-23-07-2021","text":"","title":"Version 9.1.8 (23-07-2021)"},{"location":"releasenotes.html#bugfixes_15","text":"Fix initialization and obfuscation of Kotlin callable references when using Kotlin 1.4. ( T5631 ) Fix potential hanging of DexGuard process during optimization or obfuscation. Avoid potential false positive in the VirtualEnvironmentDetector when running inside system apps. ( T4626 )","title":"Bugfixes"},{"location":"releasenotes.html#version-917-16-07-2021","text":"","title":"Version 9.1.7 (16-07-2021)"},{"location":"releasenotes.html#improved_8","text":"Throw an error when a certificate tamper check injection is enabled for a library or app bundle without specifying a certificate hash. ( T4870 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_16","text":"Fix build failure when using the Android Studio \"Generate Signed Bundle or APK\" window to generate protected bundles on AGP 4.2+. ( T5642 ) Fix incorrect count of encrypted resource files in the protection report. ( T5663 ) Disallow merging of nest hosts or members during class merging optimization. ( T4935 ) Always enable v1 and v2 signing via the Gradle plugin, to prevent problems related to signing when using bundles or in combination with the FileChecker.","title":"Bugfixes"},{"location":"releasenotes.html#version-916-09-07-2021","text":"","title":"Version 9.1.6 (09-07-2021)"},{"location":"releasenotes.html#added_5","text":"Add support for the resource optimizations introduced in AGP 4.2. ( T4229 ) Add support for APK signature scheme v4. ( T4377 ) Automatically pass the v3 and v4 signature scheme settings of the Android Gradle Plugin to DexGuard. ( T5104 )","title":"Added"},{"location":"releasenotes.html#improved_9","text":"Make it possible to configure the used signature schemes on an individual basis. ( DGD-2784 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_17","text":"Ensure correct processing of negative integer values in resource XML files with App Bundles, preventing possible runtime exceptions. ( DGD-3142 ) Fix potential InflateException due to non-matching rules because of the resource optimizations introduced in AGP 4.2. ( T4859 ) Fix a possible NullPointerException when processing large constant arrays. ( T5051 ) Don't ignore native libraries without the lib prefix when applying the -keepresourcefiles rules. ( T5424 ) Fail Gradle build when IncompleteClassHierarchyException is encountered, ( T5007 ) Fix possible native crashes in Xamarin apps due to interference of signal handlers present in the DexGuard runtime library with other signal handlers present in the application. ( T5461 ) Fix variant resolution error in app bundle projects using matchingFallbacks in combination with dynamic features. ( T5518 )","title":"Bugfixes"},{"location":"releasenotes.html#upgrade-considerations","text":"","title":"Upgrade considerations"},{"location":"releasenotes.html#resource-keep-rules","text":"Version 9.1.6 introduces support for the resource optimizations that were introduced in AGP 4.2, which are only applicable to APKs. These optimizations change and shorten the names of resource files inside the APK in order to reduce application size. To keep your current rules targeting resource files applicable, DexGuard reconstructs the file names based on the information in the resource table. In rare cases, this reconstruction could be different from the names the resource folders would have in an application that was not optimized. You can look at the resource file name mapping to know how the optimized file names have been reconstructed. This is only applicable if you are targeting resources for specific configuration types, e.g. res/color/* or res/color-vX/* .","title":"Resource keep rules"},{"location":"releasenotes.html#signing","text":"The DexGuard Gradle plugin now takes the signing settings specified in the Android Gradle plugin configuration into consideration. The new default behaviour (v1, v2, v3 and v4 if applicable) is different from the original behavior (v1 and v2 enabled, v3 and v4 disabled) . If you want to preserve the previous behavior you can enable v3 signing in AGP using enableV3Signing true .","title":"Signing"},{"location":"releasenotes.html#version-915-24-06-2021","text":"","title":"Version 9.1.5 (24-06-2021)"},{"location":"releasenotes.html#bugfixes_18","text":"Fix a possible RuntimeException during input reading. ( T5347 ) Add Internal annotation to all DexGuardTask properties, as required by Gradle 7 ( T5322 ) Prevent potential IllegalArgumentException during optimisation on single-threaded machines. ( T3796 )","title":"Bugfixes"},{"location":"releasenotes.html#version-914-18-06-2021","text":"","title":"Version 9.1.4 (18-06-2021)"},{"location":"releasenotes.html#added_6","text":"Add clearer error messages for incompatibility with resource optimizations introduced in AGP 4.2. Add new sample ( samples/basic/Flavors ) demonstrating DexGuard applied to a project using product flavors. ( T4556 )","title":"Added"},{"location":"releasenotes.html#improved_10","text":"Split off Unity bindings from the DexGuard runtime library to avoid class collisions with these bindings. ( T3164 ) Add support for passing HTTPs proxy system properties to the Crashlytics mapping file upload. ( T5253 ) Separate the stripping of native library sections functionality of -adaptresourcefilecontents into a new -stripnativelibrarysections rule. ( DGD-2628 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_19","text":"Reinstate compatibility with Gradle versions older than 5.6, preventing a No main class specified error. ( T4988 ) Generate missing consumer keep rules for native libraries in library projects. ( DGD-3411 ) Fix additional case of constant strings potentially becoming null during string encryption. ( DGD-3288 ) Fix unexpected error while writing dex file using D8 when processing AARs with class encryption enabled and min-sdk 26+ ( T3774 ) Fix potential run-time StackOverflow error when using wildcards in -accessthroughreflection . ( T2360 , T4185 )","title":"Bugfixes"},{"location":"releasenotes.html#version-913-10-06-2021","text":"","title":"Version 9.1.3 (10-06-2021)"},{"location":"releasenotes.html#improved_11","text":"Add a rule in the default configurations to prevent a potential IllegalStateException after a LifecycleOwner object has been garbage collected. ( T4202 )","title":"Improved"},{"location":"releasenotes.html#bugfixes_20","text":"Remove the dexguard-rasp version check due to possible variant resolution errors for projects containing dynamic features. ( T5171 )","title":"Bugfixes"},{"location":"releasenotes.html#version-912-09-06-2021","text":"","title":"Version 9.1.2 (09-06-2021)"},{"location":"releasenotes.html#added_7","text":"Add sample for WearOS applications. ( T4365 ) Add warning to the protection report when no certificate hash is passed when certificate tampering RASP checks are enabled. ( T4400 ) Add a version check that checks that the version of the included dexguard-rasp.jar in your build is the same as the version of DexGuard used. ( T4169 )","title":"Added"},{"location":"releasenotes.html#improved_12","text":"Prevent 'raspclassfilter' rules from overriding previous declarations.","title":"Improved"},{"location":"releasenotes.html#bugfixes_21","text":"Fix FileNotFoundException when processing test APK with the dexguard-debug configuration. ( T4722 ) Fix ClassCastException when processing APKs with min-sdk 26+ containing invoke-polymorphic instructions. ( T3710 ) Fix RuntimeException when using whitebox encryption inside large classes. ( T4568 ) Fix potential output writing or runtime errors after incorrect backporting of interface method references. ( DGD-3164 )","title":"Bugfixes"},{"location":"releasenotes.html#version-911-31-05-2021","text":"","title":"Version 9.1.1 (31-05-2021)"},{"location":"releasenotes.html#improved_13","text":"DexGuard can now automatically inject protection code needed to prevent DexGuard root detection isolated process from crashing. This protection code is injected into all derived methods (including the constructor) of custom Application classes when -raspchecks root is enabled ( T4456 ). Improved upgrading manual page with regard to removed version check plugin.","title":"Improved"},{"location":"releasenotes.html#bugfixes_22","text":"Fix constant strings potentially becoming null during string encryption. ( DGD-3288 ) Fix InvalidUserCodeException in Gradle 7.0 when calling Project.afterEvaluate after the project has already been evaluated. ( T4630 ) Fix potentially incorrect class merging optimizations that could cause a run-time NullPointerException . ( DGD-3377 ) Fix incorrect processing of obfuscated JS files in bundles. ( DGD-3430 ) Fix conversion of primitive class constant instructions that could cause a run-time ClassNotFoundException . ( T4942 ) Fix potential UnsatisfiedLinkerError caused by injecting native libraries for ABIs which aren't already present in the input. ( T4616 ) Adapt obfuscated resources referenced in the R classes during fat AAR creation. Prevent duplicate R.txt zip entries during fat AAR creation. ( T4647 ) Fix potential NullPointerException during shrinking after incorrect backporting of static interface methods. ( DGD-3509 ) Fix potential output writing or runtime errors after incorrect backporting of interface method references. ( DGD-3164 )","title":"Bugfixes"},{"location":"releasenotes.html#version-910-21-05-2021","text":"","title":"Version 9.1.0 (21-05-2021)"},{"location":"releasenotes.html#improved-protection-report","text":"The protection report gives you insight into how well your app or SDK is protected by DexGuard and now provides you with even more detailed information. Compared to DexGuard 9.0, the report will now give you additional insights in the amount of entities that are matched by your rules. The report will now also warn about rules which seem out-of-place, such as when a rule matches no entities. To ensure that new warnings always stand out we now also provide the ability to suppress specific warnings when you are sure that they are not applicable to your case.","title":"Improved Protection Report"},{"location":"releasenotes.html#improved-app-bundle-support","text":"App bundles have been supported by DexGuard for a while, this release enhances that capability. This enhanced support includes enabling RASP certificate checking in conjunction with Google Play Signing. This way you can trust that nobody can tamper with your app, even when you don't upload the final apk to the Play Store. You only have to include the certificate hash from your Google Play console in your configuration using -raspcertificatehash","title":"Improved App Bundle Support"},{"location":"releasenotes.html#detailed-forensics-for-threatcast-users","text":"ThreatCast is a free to use product that allows real-time monitoring of protected applications. With a new DexGuard release comes new capabilities. You can now track which part of your application generated a particular threat event. This enables you to gain even more insight when the detection occurs. DexGuard will output a threatcast_mapping.yml file when ThreatCast is configured. This file should be uploaded to your ThreatCast portal. DexGuard can now also retrieve extra information at runtime which will be sent along with every threat that is detected. This information can be used to identify which users are trying to reverse engineer your app. You can configure DexGuard using its new option -threatcastappuseridgetter .","title":"Detailed forensics for ThreatCast users"},{"location":"releasenotes.html#minor-changes","text":"","title":"Minor Changes"},{"location":"releasenotes.html#new","text":"DexGuard will now print a message when a new version is available.","title":"New"},{"location":"releasenotes.html#improved_14","text":"Add check to prevent multiple -raspcallback rules being specified ( T4643 ) Make Gradle plugin compatibile with Crashlytics mapping file uploads when using Gradle 7.0 . ( T4846 ) DexGuard can now automatically inject protection code needed to prevent DexGuard root detection isolated process from crashing. This protection code is injected into all derived methods of custom Application classes when -raspchecks root is enabled.","title":"Improved"},{"location":"releasenotes.html#bugfixes_23","text":"Fix variant resolution problem when running the assemble task, or building through Android Studio, in a project with dynamic features. ( DGD-3337 ) Fix variant resolution problem when running the test or check task in a project with dynamic features. ( DGD-3378 ) Fix potential ConcurrentModificationException when executing multiple RASP checks in parallel. ( T4748 )","title":"Bugfixes"},{"location":"releasenotes.html#version-90-august-2020","text":"DexGuard 9.0 integration in Android projects requires configuration changes that are detailed in the upgrading guide .","title":"Version 9.0 August 2020"},{"location":"releasenotes.html#new-gradle-plugin-with-agp-40-support","text":"DexGuard 9.0 comes with a brand new companion Gradle plugin that is less sensitive to changes in the Android Gradle Plugin. The main difference is that DexGuard now post-processes your application or library, rather than integrating itself into the build process. This means that the DexGuard input is now the unobfuscated application, app bundle or library produced by the standard Android build process. More details can be found here .","title":"New Gradle plugin with AGP 4.0 support"},{"location":"releasenotes.html#protection-report","text":"DexGuard now automatically produces a visual HTML report to help you improve the overall security of your DexGuard hardened builds. This Protection Report allows you to continuously assess and improve the protection of your application or library. More details can be found here .","title":"Protection report"},{"location":"releasenotes.html#android-11-support","text":"DexGuard 9.0 fully supports Android 11.","title":"Android 11 support"},{"location":"releasenotes.html#auto-injection-of-rasp-libraries","text":"DexGuard can now inject some of the RASP dependencies that previously had to be added as project dependencies. More details on RASP configuration can be found here . Version Issue Module Explanation 9.0.22 T4065 CORE Fix potential NPE while using native library encryption with classes that extend android.app.Service or android.app.Activity . 9.0.22 DGD-3224 CORE Update the Reflection sample to correctly showcase the access through reflection feature. 9.0.22 DGD-3238 CORE Add default -keep rules for compatibility with Android App Actions. 9.0.21 T4589 GRADLE Fix variant resolution error when an APK dependency is provided. 9.0.21 DGD-3520 CORE Add ability to escape quotes in keystore passwords with backslashes. 9.0.21 DGD-3075 CORE Add check to prevent wildcards being used in RASP callback and ThreatCast App User ID configurations. 9.0.21 DGD-3523 CORE Add a runtime API to determine if the current process corresponds to the DexGuard isolated process. 9.0.20 DGD-3421 CORE Fix missing parentheses in await expressions during JavaScript processing. 9.0.20 DGD-3470 CORE Add -threatcastappuseridgetter configuration option. 9.0.20 DGD-2856 GRADLE Fix Gradle plugin compatibility with Gradle 7.0. 9.0.20 DGD-3543 CORE Fix potentially incorrect transformation during conversion of dex files. 9.0.20 DGD-3397 CORE Deprecated the -pack option. See upgrade considerations . 9.0.20 DGD-2978 GRADLE Use the JVM set via JAVA_HOME when executing DexGuard through the Gradle plugin. 9.0.20 DGD-3323 RUNTIME Fix Frida library check to detect deleted entries of the library. 9.0.19 DGD-3517 CORE Fix NullPointerException which could potentially be raised while decrypting strings. 9.0.19 DGD-3338 CORE Generate the right proguard.map when using app bundles in conjunction with R8 for preserving runtime invisible annotations. 9.0.19 DGD-0013 CORE Improve error message when missing classes result in an incomplete class hierarchy. 9.0.19 DGD-3297 GRADLE Add support for apk splits in combination with the overwriteUnprotected option. 9.0.18 DGD-3397 CORE Fix NullPointerException which could potentially be raised while decrypting strings. 9.0.18 DGD-3429 CORE Additionally harden string encryption. 9.0.17 DGD-3274 RUNTIME Improve root detection checks to detect Magisk and MagiskHide versions 21.3 and higher. 9.0.17 DGD-3274 RUNTIME Provide asynchronous root detection interface . 9.0.17 DGD-3274 RUNTIME Deprecate synchronous RootDetector.isDeviceRooted() interface. 9.0.17 DGD-3276 CORE Adapt obfuscated classes referenced in the AndroidManifest.xml during fat AAR creation. 9.0.17 DGD-3399 CORE Fix Cordova plugin inserting incorrect relative paths to DexGuard. 9.0.16 DGD-3398 RUNTIME Fix potential crashes when calling multiple obfuscated versions of the hook detector in parallel. 9.0.15 DGD-3388 CORE Fix potentially encrypting too many string resources. 9.0.15 DGD-3139 CORE Prevent possible SecurityException when applying string encryption. 9.0.15 DGD-3262 GRADLE Prevent the addition of AGP 4.0 in the classpath when using the DexGuard Gradle Plugin. 9.0.14 DGD-3343 RUNTIME Fix a crash in DexGuard runtime checks when used on devices running Android API 25 or lower. 9.0.14 DGD-3344 GRADLE Automatically disable fat AAR generation in our gradle plugin, if another fat AAR plugin is already enabled. 9.0.14 DGD-3321 CORE Fixed encryption of constant field strings when -encryptstrings is specified with only the class name. 9.0.13 DGD-3313 CORE Fix missing parentheses in await subexpressions during JavaScript processing. 9.0.13 DGD-3333 CORE Fix potential ClassCastException while processing app bundles that contain kotlin modules. 9.0.13 DGD-3334 CORE Fix incorrect timestamps for Threatcast threats sent between 12 pm and 1 am UTC. 9.0.13 DGD-3137 RUNTIME Fixed potential ANR issue when calling DexGuard runtime checks. 9.0.13 DGD-3232 CORE Allow to encrypt string resources, but keep their name. 9.0.13 DGD-3036 CORE Fixed potential incorrect removal of exception handlers during optimization. 9.0.13 DGD-3317 CORE Fixed potential NullPointerException when processing Kotlin nested classes. 9.0.13 DGD-3070 GRADLE Allow the use of spaces in the path of build folders on Windows. 9.0.13 DGD-3009 CORE Fix potential ArrayIndexOutOfBoundsException at runtime when using -virtualizecode. 9.0.12 DGD-3002 CORE Fix potential ClassCastException while processing app bundles that contain Android Wear APKs. 9.0.12 DGD-3290 CORE Fix ArrayIndexOutOfBoundsException when -pack is used in combination with a pre-existing Application class. 9.0.12 DGD-3068 CORE Prevent verifier error on Android 4.4 when using encryption features. 9.0.12 DGD-3068 RUNTIME Prevent verifier errors on Android 4.4 in runtime checks. 9.0.11 DGD-2850 GRADLE Fix app bundle inputs not being found when using Android Gradle Plugin 3.5.x 9.0.11 DGD-2720 GRADLE Add support for variant-specific embeddings for fat AARs. 9.0.11 DGD-2834 CORE Add a version check for the runtime library. 9.0.11 DGD-2541 CORE Fix class name obfuscation with long names causing potential overflow of the string section in native libraries. 9.0.11 DGD-2512 CORE Print which configuration files were used to DexGuard's build log. 9.0.11 DGD-1582 CORE Add clear exception message when processing an application with a library config or the other way around. 9.0.11 DGD-2746 GRADLE Clarify exception message when the 'path' property of the DexGuard block does not point to the root of a DexGuard installation. 9.0.11 DGD-1933 CORE Automatically apply the -multidex option. 9.0.10 PGC-0006 CORE Filter out signatures that do not conform with the java specification. 9.0.10 DGD-3231 CORE Fix -accessthroughreflection,encryptstrings potentially introducing a call to a non-existent method. 9.0.10 JSG-74 CORE Don't activate javascript protection for non-javascript script tags in html files. 9.0.10 DGD-2808 CORE Fix invalid app bundle structure when performing automatic RASP injection. 9.0.10 DGD-2924 CORE Print protection report location to DexGuard's build log. 9.0.9 DGD-3235 CORE Create additional locations for RASP injection early in the application lifecycle. 9.0.9 DGD-3153 CORE Improved performance by deduplicating configuration rules. 9.0.9 DGD-3165 CORE Fixed code obfuscation potentially introducing infinite recursion in extensions of Context.getResources() . 9.0.9 DGD-3034 CORE Allow -keepresources flag without explicitly listing resources. 9.0.9 DGD-3109 CORE Added support for M1-based macs to the Protection Report. 9.0.8 DGD-2363 CORE Updated package structure of Dagger sample. 9.0.8 DGD-2363 CORE Updated SSLPinning and SSLPinningWebView samples. 9.0.8 DGD-2861 CORE Fix Error Code 10 when using the DebugBlocker . 9.0.8 DGD-2892 CORE Fixed possible runtime VerifierError caused by -accessbyreflection . 9.0.8 DGD-2235 CORE Added support for encrypting resource files in APKs using SDK 28+. 9.0.8 DGD-3080 GRADLE Fixed issue in the Gradle plugin where libraryjars in dynamic feature modules weren't deduplicated before passing them to DexGuard. 9.0.8 DGD-3023 CORE Fixed issue where RASP checks wouldn't crash the application when logging code was removed using '-assumenosideeffects'. 9.0.8 DGD-3060 CORE Fixed an issue in RASP file checks which could potentially lead to missing checked file. 9.0.7 DGD-2659 CORE Fixed an issue where resource files and encrypted native libraries may receive the same name after obfuscation. 9.0.7 DGD-2887 GRADLE Fixed issue in the Gradle plugin where variant resolution would fail for app bundles with dynamic features when using an Android Gradle plugin version below 4.0 and a Gradle version below 6.0. 9.0.7 DGD-2886 GRADLE Fixed issue in the Gradle plugin where variant resolution failed when a dynamic feature has a dependency on another dynamic feature. 9.0.7 PGC-0015 CORE Added support for Java 16. 9.0.7 PGD-0064 CORE Added support for Java 14 and 15. 9.0.7 PGD-0064 CORE Added support for sealed classes (permitted subclasses attributes). 9.0.7 PGD-0064 CORE Added support for record attributes. 9.0.7 DGD-2877 STUDIO Added support for Android Studio 4.1 and 4.2 to the Android Studio plugin. 9.0.7 DGD-2898 CORE Added rule to configuration to shrink annotations.zip in an Android library by default. 9.0.7 DGD-2884 CORE Fixed parsing of table config in resource table files, causing NullPointerException at processing time 9.0.6 DGD-2828 GRADLE Fixed issue in the Gradle plugin where consumer rules weren't picked up for file dependencies. 9.0.6 DGD-2987 GRADLE Fixed issue in the Gradle plugin where the mapping files are overwritten when APK splits are used. 9.0.6 DGD-2983 RUNTIME Fixed potential crashes in HookDetector when running on Android 10 or higher. 9.0.6 DGD-2369 RUNTIME Fixed potential false positives in RASP emulator check when running on OnePlus devices. 9.0.6 DGD-2067 RUNTIME Renamed DexGuard runtime native library to avoid possible name collisions with other native libraries. 9.0.6 DGD-2918 RUNTIME Fixed potential false positives in EmulatorDetector when running on devices that provide desktop experience. 9.0.6 DGD-2969 CORE Updated Realm sample. 9.0.6 DGD-2602 GRADLE Added Firebase Crashlytics mapping file upload integration to the DexGuard Gradle plugin. 9.0.5 DGD-2953 CORE Fixed required signature scheme check always firing, regardless of maxSdkVersion. 9.0.5 DGD-2914 CORE Moved -keep rules for Moshi to a new dexguard-moshi.pro configuration file. 9.0.5 DGD-2942 CORE Fixed potential infinite loop when processing Dalvik input. 9.0.5 DGD-2954 CORE Fixed parsing failure of UTF-8 BOM encoded Javascript files. 9.0.5 DGD-2919 RUNTIME Fixed potential false positives in EmulatorDetector when running on certain Huawei, Teclast, Myria devices. 9.0.5 DGD-2531 GRADLE Added overwriteUnprotected option to have DexGuard overwrite the unprotected artifact. 9.0.4 DGD-2917 CORE Updated manual entry 'Tune the obfuscation level' to describe the configuration for new gradle plugin. 9.0.4 DGD-2197 CORE Using whitelists for configuring string encryption in JavaScript now properly obfuscates the matched strings. 9.0.4 DGD-2406 CORE Added Kotlin DSL Gradle script snippets to the manual. 9.0.4 DGD-2899 GRADLE Fixed the dexguardDownload task possibly being created multiple times. 9.0.4 DGD-2891 CORE Fixed missing files in the META-INF folder of apks generated from processed app bundles. 9.0.4 DGD-2797 GRADLE Fixed failure to add useLibrary dependencies to the library jars. 9.0.3 DGD-2636 CORE Added support for the WorkManager Multiprocess Library to the default configuration. 9.0.3 DGD-2844 GRADLE Fixed failure to add compileOnly dependencies to the library jars when building a library. 9.0.3 DGD-2870 CORE Fixed RASP resource injection on Windows environment. 9.0.3 DGD-2783 GRADLE Fixed build failure when using the Android Studio \"Generate Signed Bundle or APK\" window to generate protected bundles. 9.0.3 DGD-2687 GRADLE Added documentation for using Crashlytics with product flavors. 9.0.2 DGD-2724 CORE Fixed FileNotFoundException for encrypted native libraries in an SDK with extractNativeLibs=false . 9.0.2 DGD-2826 RUNTIME Fixed potential false positives in HookDetector when handling unresolved symbols. 9.0.2 DGD-2825 RUNTIME Fixed potential false positives in EmulatorDetector on Samsung devices connected to Samsung DeX. 9.0.2 DGD-2835 CORE Fixed potential infinite wait during dependency analysis 9.0.2 DGD-2808 CORE Fixed potential RASP file tamper check failure. 9.0.2 DGD-2790 GRADLE Fixed incorrect parsing of the Gradle version when using a Gradle release candidate. 9.0.2 DGD-2757 CORE Updated the list of available Maven artifacts in the manual. 9.0.2 DGD-2737 CORE Fixed potential NullPointerException while detecting GSON serialization location. 9.0.2 DGD-2411 CORE Made better error messages when the -obfuscatejavaScript and -javascriptconfiguration are not provided together 9.0.2 DGD-2804 RUNTIME Fixed a file descriptor double-close bug in the HookDetector . 9.0.1 DGD-2768 GRADLE Changed the location of the processed apk/aab/aar to be in the same location as the unprocessed one. 9.0.1 DGD-2719 GRADLE Fixed passing of arguments to DexGuard containing characters such as # in keystore passwords. 9.0.1 DGD-2753 CORE Fixed NullPointerException when using -dump. 9.0.1 DGD-2751 CORE Fixed printing of hash # characters when using -printconfiguration . 9.0.1 DGD-2732 CORE Fixed invalid backporting of static and default interface methods when post-processing. 9.0.0 DGD-2070 CORE Added threatcast-client artifacts. 9.0.0 DGD-2070 RUNTIME Added RASP injection library artifact. 9.0.0 DGD-2649 CORE Fixed certain resource table entries not being printed to the resource mapping file. 9.0.0 DGD-2663 CORE Removed old Cordova/CrossWalk sample. 9.0.0 DGD-2683 CORE Removed bin/install_gradle_plugin.{sh,bat} scripts. 9.0.0 DGD-2244 CORE Added rules for Jacoco coverage reports to the default configuration. 9.0.0 DGD-2587 CORE Fixed IllegalArgumentException (Stack size becomes negative) in optimization class/merging/wrapper . 9.0.0 DGD-1919 CORE Added automatic injection of DexGuard runtime library when using automatic RASP injection. 9.0.0 DGD-2468 CORE Gracefully handle corrupt Signature Attributes in the input. 9.0.0 DGD-2253 CORE Added automatic generation of a Protection Report. 9.0.0 DGD-1521 GRADLE Added a new Gradle plugin that supports AGP 4.x. 9.0.0 DGD-2226 CORE Made post-processing the default mode for DexGuard. Upgrade considerations for version 9.0.21 : If your application uses a custom android.app.Application class, please refer to this page to correctly setup your application for RASP root detection (both for manual checks and automatic code injection). Upgrade considerations for version 9.0.20 : The -pack option has been deprecated and will be removed in a future DexGuard release. Please refer to finer-grained techniques such as class encryption ( -encryptclasses ) and code virtualization ( -virtualizecode ) that provide more effective protection. ThreatCast App User ID: DexGuard can retrieve extra information at runtime which will be sent along with every threat that is detected. For example, this information can be used to identify your users. You can configure DexGuard using its new option -threatcastappuseridgetter . Upgrade considerations for version 9.0.17 : In order to detect the latest versions of Magisk and Magisk Hide (21.3+): For manual root detection with the runtime library, use the asynchronous, callback-based implementation of the root detection check that was added in DexGuard version 9.0.17. For automatic root detection with injected RASP checks, use RASP injection of DexGuard version 9.0.17. No configuration or code changes are required compared to previous versions. When building an SDK, the runtime library should be packaged using the embed configuration to make a fat AAR . Upgrade considerations : We removed DexGuard from the build process, it is now supposed to be executed as a command line tool. We added a new Gradle plugin that will help you to collect certain inputs for DexGuard. This plugin has support for AGP 4+.","title":"Auto-injection of RASP libraries"},{"location":"releasenotes.html#version-87-june-2020","text":"","title":"Version 8.7 June 2020"},{"location":"releasenotes.html#automated-rasp-injection","text":"DexGuard can now automatically inject the various checks for Runtime Application Self-Protection into your application. You no longer need to manually change your source code to update the protection of your application. By simply rebuilding your app, you can let DexGuard add the latest checks, automatically and to their full extent. DexGuard provides: Automatic injection based on high-level configuration switches. Aggressiveness settings to control the impact. An optional callback mechanism enabling your app to react to threats. Optional application termination as a tamper response. Straightforward but flexible configuration options.","title":"Automated RASP injection"},{"location":"releasenotes.html#threat-reporting-capabilities","text":"Detecting and reacting to application and device threats are fundamental DexGuard features. You may also want to collect and visualize related data, in order to further improve hardening or to flag fraud. Our free ThreatCast console now adds convenient reporting capabilities. Seamless integration with the ThreatCast console. Automated threat reporting for all enabled RASP checks. Collection and reporting of additional threat information. Easy configuration through addition of a single api-key.","title":"Threat reporting capabilities"},{"location":"releasenotes.html#inconspicuous-name-obfuscation","text":"Typical name obfuscation stands out because of the unusual identifiers. In some cases this draws extra attention and helps focus reverse engineering efforts. New settings to switch between naming schemes. New naming scheme to generate realistic looking names.","title":"Inconspicuous name obfuscation"},{"location":"releasenotes.html#fat-aars","text":"DexGuard can now combine and protect multiple AAR libraries and their internal and external dependencies into a single 'fat' AAR. You can thus more easily create and distribute secure SDKs.","title":"Fat AARs"},{"location":"releasenotes.html#improved-kotlin-support","text":"The default processing of Kotlin applications has been improved. Various pieces of Kotlin-related semantic information are removed when not needed at run-time. You can still apply standard -keep rules when exceptions are needed, for example for SDK APIs. Version Issue Module Explanation 8.7.10 DGD-2734 CORE Fixed not all initialization methods being kept for Moshi Json deserialization. 8.7.09 DGD-2713 CORE Fixed parameter names in Kotlin interfaces not being kept when using -keepparameternames together with -keepkotlinmetadata. 8.7.09 DGD-2701 RUNTIME Fixed potential false negatives in EmulatorDetector . 8.7.08 DGD-2661 CORE Fixed UnsatisfiedLinkError when including DexGuard native runtime libraries with conservative default configuration. 8.7.08 DGD-2655 CORE Fixed corruption of decrypted strings on some devices. 8.7.08 DGD-2677 CORE Fixed potential issue related to increased string section length when processing native libraries. 8.7.08 DGD-2480 CORE Changed default configuration to keep native libraries with their original names in library projects. 8.7.08 DGD-2647 RUNTIME Fixed potential false positives in EmulatorDetector when running on certain Xiaomi devices. 8.7.08 DGD-2643 CORE Fixed potential NullPointerException during GSON optimization. 8.7.07 DGD-2382 CORE Fixed processing of Kotlin 1.4 metadata annotations. 8.7.07 DGD-2632 CORE Added support for localised values for fat AARs. 8.7.06 DGD-2580 CORE Fixed potential VerifyErrors on Android 4.4 and earlier when encrypting strings. 8.7.06 DGD-2539 CORE Added additional rules for Moshi GSON parser/unparser and added a sample Moshi project. 8.7.06 DGD-2498 STUDIO Added RASP configuration support in Android Studio plugin. 8.7.06 DGD-2554 CORE Fixed potential VerifyErrors on Android 4.4 and earlier when virtualizing code. 8.7.06 DGD-2540 CORE Fixed potential VerifyError: Bad type on operand stack error when injecting RASP callback. 8.7.06 DGD-2518 CORE Fixed potential corruption of RASP callback when using certain variable types. 8.7.05 DGD-2511 CORE Fixed regression in the Gradle plugin where Espresso tests contain too many classes. 8.7.05 DGD-2427 CORE Added additional configuration to keep attribute names related to in AndroidManifest.xml 8.7.05 DGD-2510 CORE Added further additional default configuration for the Firebase Crashlytics library. 8.7.04 DGD-2508 CORE Fixed NullPointerException when using native library encryption with app bundles. 8.7.04 DGD-2501 CORE Added additional default configuration for the Firebase Crashlytics library. 8.7.04 DGD-2372 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on devices running Android 11. 8.7.04 DGD-2492 CORE Prevented erroneous options in consumer rule generation for AARs. 8.7.04 DGD-2366 CORE Fixed string encryption possibly introducing private fields in interfaces. 8.7.04 DGD-2494 CORE Fixed naming conflict resolution potentially resulting in the renaming of android library members. 8.7.04 DGD-2493 CORE Fixed -keepresources being incorrectly written to consumer rules. 8.7.04 DGD-2479 CORE Fixed spuriously incorrectly decrypted strings on new thread. 8.7.04 DGD-2471 RUNTIME Fixed potential IllegalArgumentException when obfuscating/virtualizing code that has parameter type annotations. 8.7.04 DGD-2368 RUNTIME Fixed false negatives in EmulatorDetector when running on Android 11 emulator. 8.7.03 DGD-2425 GRADLE Fix Espresso test default input filter in the Gradle plugin which prevented kotlin metadata files from being included in the test apk. 8.7.03 DGD-2351 GRADLE Fix issue in the Gradle plugin where native libraries in library projects weren't picked up on a clean build. 8.7.03 DGD-2421 CORE Add default configuration for Google ML kit library. 8.7.03 DGD-2354 CORE Update the configuration to keep Gson annotations. 8.7.03 DGD-2352 CORE Fix potential NullPointerException in certain RASP injection locations. 8.7.03 DGD-2348 CORE Fix possible duplication of certain injected RASP checks. 8.7.03 DGD-2344 CORE Fix apps always crashing when a debugger is attached regardless of user configuration. 8.7.03 DGD-2329 CORE Improve potential code injection locations. 8.7.03 DGD-2299 CORE Add API method to DetectionReport for checking if the app was signed with debug keys. 8.7.03 DGD-1792 RUNTIME Fixed potential false positives when calling HookDetector.isApplicationHooked on devices with native bridge initialized. 8.7.03 RUNTIME Added integration with the Zimperium console. 8.7.03 RUNTIME Added integration with ThreatCast. 8.7.02 DGD-2288 CORE Fix potential crash when injecting code into methods with unsupported attributes. 8.7.01 DGD-2268 CORE Fix reporting of incorrect threat types when certain hooking and rooting checks are injected. 8.7.00 DGD-2205 CORE Changed default -optimizationpasses to 2. 8.7.00 DGD-2223 GRADLE Enabled -printinjectmapping by default in Gradle builds. 8.7.00 DGD-1891 CORE Fix potential NullPointerException when processing Kotlin metadata. 8.7.00 DGD-2147 CORE Added RASP configuration options. 8.7.00 DGD-2151 CORE Fixed a possible crash when the dexguard-rasp library is included without the dexguard-runtime library. 8.7.00 DGD-2166 CORE Added Kotlin reflect -keep rules to the default configuration. 8.7.00 DGD-2188 CORE Renamed -adaptkotlinmetadata configuration option to -keepkotlinmetadata. 8.7.00 DGD-2101 CORE Added exceptions and warnings for common RASP injection configuration mistakes. 8.7.00 DGD-2165 CORE Added KotlinReflection sample. 8.7.00 DGD-2170 GRADLE Fixed possible persistence problem with injection configurations when using a Gradle daemon. 8.7.00 DGD-2148 CORE Automatically encrypt strings in RASP callbacks. 8.7.00 DGD-2158 GRADLE Rename Kotlin samples: Kotlin to KotlinHelloWorld and KotlinDSL to GradleKotlinDSL. 8.7.00 DGD-1976 CORE Added dexguard-rasp.pro configuration (replacing multiple RASP/ThreatCast/Zimperium configuration files). 8.7.00 DGD-1975 CORE Added support for RASP callbacks and default crash/continue threat behaviour ( continueOn* switches). 8.7.00 DGD-1525 CORE Added new obfuscation scheme that uses kept names for name obfuscation. 8.7.00 DGD-1693 CORE Add support for injecting code that contains exception handling. 8.7.00 DGD-1969 CORE Add support for injecting code that contains switch blocks. 8.7.00 DGD-1787 CORE Strip Kotlin metadata unless explicitly kept via -keep rules. 8.7.00 DGD-2063 CORE Fixed configuration printing of members in class specification -define vars. 8.7.00 DGD-2055 CORE Ensure that code is not injected before super.onAttachBaseContext in Android applications. 8.7.00 DGD-2047 CORE Fixed possible NullPointerException if Kotlin referenced file facade does not exist. 8.7.00 DGD-1732 CORE Fixed retrace not deobfuscating certain stacktraces originating from Sentry. 8.7.00 DGD-1995 CORE Fixed constructing class hierarchy for optimization and obfuscation. 8.7.00 DGD-2001 CORE Keep INSTANCE fields in Kotlin object classes. 8.7.00 DGD-1795 CORE Prevent classes referenced from Android XMLs from being made packageless. 8.7.00 DGD-1780 CORE Removed dependency on internal sun.security API. 8.7.00 DGD-1851 GRADLE Updated Kotlin sample gradle configuration and moved from \"advanced\" to \"basic\" folder. 8.7.00 DGD-1434 CORE Improved default support for the AndroidX libraries. 8.7.00 DGD-1755 CORE Targeting Java 5 instead of Java 1.2 in generated Java class files in library projects. 8.7.00 DGD-1286 CORE Added support for PKCS11 signing through the new option -pkcs11configuration . 8.7.00 DGD-1754 WB-ADDON Fixed unsupported constants in bytecode when applying whitebox cryptography in library projects without optimization or obfuscation. 8.7.00 DGD-1240 RUNTIME Added a Cordova SystemWebViewClient that can do both SSL pinning and asset decryption. 8.7.00 DGD-123 CORE Added support for fat AAR creation. 8.7.00 RUNTIME Added integration with the Zimperium console. 8.7.00 RUNTIME Added integration with ThreatCast.","title":"Improved Kotlin support"},{"location":"releasenotes.html#version-86-february-2020","text":"Improved support for Kotlin. DexGuard is now able to process (shrink / obfuscate) information injected by the kotlin compiler ( kotlin.Metadata annotations, data classes, ...). Please refer to the Kotlin page for more information. Version Issue Module Explanation 8.6.19 DGD-2263 CORE Fixed native library name obfuscation to avoid potential conflict in library projects. 8.6.19 DGD-2332 CORE Further hardened code virtualization. 8.6.19 DGD-2356 RUNTIME Fixed potential false negative with regards to detection of new Android debug keys. 8.6.19 DGD-2354 CORE Update the configuration to keep Gson annotations. 8.6.19 DGD-2287 CORE Further hardened string encryption. 8.6.19 DGD-2340 CORE Include the required resources for Google Open Source Notices. 8.6.19 DGD-2297 CORE Fix potential post-processing VerifyError \"expected to be within a catch-all for an instruction where a monitor is held\". 8.6.18 DGD-2022 CORE Fixed issue in the Gradle plugin where classes were collected incorrectly when using Firebase performance monitoring, causing no monitoring information to be sent. 8.6.17 DGD-1513 STUDIO Added support for Android studio 4.0 to the Android studio DexGuard configuration file type plugin. 8.6.17 DGD-2174 GRADLE Fixed issue in the Gradle plugin where dynamic feature dependencies weren't collected properly when building app bundles with AGP 3.6. 8.6.17 DGD-2202 CORE Fixed invalid interface method access modifier when backporting lambdas with minSdkVersion >= 26. 8.6.16 DGD-1853 RUNTIME Fixed false negatives in EmulatorDetector when running on Nox player. 8.6.15 DGD-2179 GRADLE Fixed Crashlytics support regression with the Android Gradle plugin 3.6 in the Gradle plugin. 8.6.14 DGD-2159 GRADLE Fixed issue in the Gradle plugin where the build would crash when using Gradle 6. 8.6.14 DGD-1586 GRADLE Improved integration with the new Firebase Crashlytics SDK. Documented remaining steps for the integration. 8.6.14 DGD-2103 CORE Fixed potential crash when doing primitive castings during backporting. 8.6.14 DGD-2106 GRADLE Fixed issue in the Gradle plugin where specifying splits with both abi and density dimensions for an apk caused a crash. 8.6.13 DGD-2073 GRADLE Resolved task ordering issues between the DexGuard and Crashlytics Gradle plugins when using Android Gardle plugin version 3.6. 8.6.13 DGD-2076 GRADLE Fixed an issue in the Gradle plugin where library jars may be missing when building instrumented test APKs 8.6.13 DGD-2061 GRADLE Fixed issue in the Gradle plugin where the mapping file wasn't correctly set when using the Android Gradle plugin 3.6. This caused calls to variant.getMappingFile() to fail. 8.6.11 DGD-1792 RUNTIME Fixed potential false positives when calling HookDetector.isApplicationHooked on devices with native bridge initialized. 8.6.10 DGD-2043 CORE Fixed processing of section indices in ELF files. 8.6.10 DGD-2042 GRADLE Fixed an issue in the Gradle plugin where too many classes were included in instrumented test APKs. 8.6.10 DGD-2050 RUNTIME Fixed false negatives in RootDetector wrt detecting Magisk Manager app. 8.6.10 DGD-2018 CORE Improved analysis for necessary classes in the main dex file. 8.6.10 DGD-2046 CORE Fixed optimization leading to unexpected error \"Stack size becomes negative\". 8.6.10 DGD-1837 CORE Fixed potential IncompatibleClassChangeError when backporting lambda expressions. 8.6.09 DGD-1842 CORE Fixed possible stack overflow when many GSON classes are optimized. 8.6.09 DGD-1979 CORE Fixed transitive loading of encryption plugins when they were not explicitly loaded. 8.6.08 DGD-1897 CORE Fixed verifier error when declaring too many JNI methods. 8.6.07 DGD-1186 WB-ADDON Further fixed application of whitebox cryptography for debug builds. 8.6.07 DGD-1938 CORE Corrected file name to be uploaded to private Maven repository in manual. 8.6.06 DGD-1800 CORE Fixed obfuscation of functional interfaces with abstract Object methods. 8.6.06 DGD-1558 CORE Fix potential error caused by D8 \"expected to find a possibly throwing instruction\". 8.6.06 CORE Updated D8 tool for class conversion to version 1.6.68. 8.6.06 DGD-1883 GRADLE Updated parsing of resource tables in app bundles for Android Gradle Plugin 3.6 (\"Unsupported field number [5] in Attribute Symbol message\"). 8.6.05 DGD-1854 WB-ADDON Fixed application of whitebox cryptography for debug builds. 8.6.05 DGD-1836 GRADLE Fixed issue in the Gradle plugin where dependencies weren't collected correctly when using transforms with a limited scope. 8.6.05 DGD-1846 CORE Fixed potential IllegalArgumentException during optimization when there is only one core available. 8.6.04 DGD-1844 GRADLE Improved error message when including the DexGuard gradle plugin the wrong way. 8.6.04 DGD-1841 CORE Disabled internal debug logging and files. 8.6.03 DGD-1811 CORE Fixed threading issue causing spurious optimization problems. 8.6.03 DGD-1778 GRADLE Fixed an issue in the Gradle plugin which might cause variant selection to fail when using dynamic features. 8.6.03 DGD-1809 GRADLE Improved error message when including the DexGuard gradle plugin the wrong way. 8.6.03 DGD-1621 RUNTIME Updated the runtime library to allow integration with Unity. 8.6.03 DGD-1759 GRADLE Fixed issue in the Gradle plugin causing a FileNotFoundException when including certain dependencies using the Android Gradle plugin version 3.6. 8.6.03 DGD-1239 RUNTIME Add implementation for shouldInterceptRequest(WebView view, WebResourceRequest request) to EncryptedWebViewClient, introduced in API level 21. 8.6.03 DGD-1768 CORE Fixed potential deadlock in optimization phase. 8.6.03 DGD-1756 CORE Further avoiding Windows file naming issue of resource files in libraries. 8.6.02 DGD-1698 CORE Fixed possible NullPointerException while processing Kotlin modules. 8.6.02 DGD-1714 CORE Fixed extends not recognized in -encryptclasses rule. 8.6.02 DGD-1566 RUNTIME Added documentation for DexGuard runtime library integration in SDK projects. 8.6.01 DGD-1567 RUNTIME Fixed crashes in DexGuard runtime library on devices running Android API less than 21. 8.6.00 JSG-8 CORE Added support for JavaScript obfuscation of ECMAScript 6 code. 8.6.00 JSG-60 CORE Improved runtime performance of JavaScript string decryption. 8.6.00 DGD-1556 CORE Added default configuration for the Unity game engine. 8.6.00 JSG-4 CORE Improved integration with React Native apps. 8.6.00 JSG-31 CORE Improved error handling when parsing JavaScript configuration. 8.6.00 JSG-6 CORE Added function encryption to hide the implementation of sensitive JavaScript functions. 8.6.00 DGD-1562 CORE Fixed incomplete usage marking of Kotlin classes potentially causing NullPointerException at build time. 8.6.00 DGD-1444 CORE Improved speed of side effect marking. 8.6.00 DGD-1473 CORE Improved speed of instruction usage marking. 8.6.00 DGD-1204 CORE Added allowobfuscation modifier for resources, to allow renaming of the resource id. 8.6.00 DGD-1482 CORE Improved speed of peephole optimizer. 8.6.00 DGD-1471 CORE Improved speed of horizontal class merging. 8.6.00 DGD-1537 CORE Improved speed of partial evaluator. 8.6.00 DGD-1456 GRADLE Updated default resource input filters of the gradle plugin wrt files located in the META-INF directory. 8.6.00 DGD-1370 GRADLE Added support for the Android Gradle plugin version 3.6. 8.6.00 DGD-1219 CORE Added new option -printresourcemapping to print the mapping information for resource entries. 8.6.00 DGD-1487 CORE Fixed false positives wrt default constructors when using -addconfigurationdebugging . 8.6.00 DGD-1495 CORE Fixed false positives for missing assets and native libraries when using -addconfigurationdebugging . 8.6.00 DGD-1346 CORE Added new option -distinctclassmembernames to ensure that all matching members are distinct within a class. 8.6.00 DGD-1550 CORE Fixed potential NullPointerException when processing kotlin.Metadata annotations at build time. 8.6.00 DGD-1201 RUNTIME Added debug blocker and improved debug detection. 8.6.00 DGD-1472 CORE Improved speed of initial subclass initialization 8.6.00 DGD-1464 CORE Fixed non-determinism during apk input processing. 8.6.00 DGD-1463 CORE Ensured that printed optimization statistics are reported correctly. 8.6.00 DGD-1294 RUNTIME Added documentation to the performance of various environment checks of the DexGuard runtime library. 8.6.00 CORE Fix potential build error when obfuscating companion classes of nested Kotlin classes. 8.6.00 CORE Fix potential build error when partially keeping the kotlin.Metadata class. 8.6.00 DGD-1480 CORE Fix potential kotlin reflection runtime errors due to incorrect flags on properties. 8.6.00 DGD-1462 CORE Fixed initialization of enclosing method classes. 8.6.00 DGD-1405 CORE Fixed processing of Kotlin companion objects. 8.6.00 DGD-1455 CORE Fixed potential IllegalArgumentException in DataClassObfuscator. 8.6.00 DGD-1384 CORE Added support for Kotlin contracts. 8.6.00 DGD-1455 CORE Fixed processing of kotlin data classes. 8.6.00 CORE Fixed sample 'basic/KotlinDSL'. 8.6.00 CORE Fixed potential NullPointerException when processing kotlin.Metadata annotations at build time. 8.6.00 DGD-1094 CORE Added a cordova plugin to setup DexGuard automatically in cordova projects. 8.6.00 GRADLE Modified group Id in pom descriptors lib/gradle-plugin.xml and lib/maven-plugin.xml to com.guardsquare.dexguard to be in sync with artifacts on maven repository. 8.6.00 DGD-1382 CORE Added support to process kotlin.Metadata annotations . 8.6.00 DGD-1419 GRADLE Fixed issue in the Gradle plugin where dependency projects got compiled for all variants when this is only necessary for some of them. 8.6.00 PGD-753 CORE Fixed processing of signature attributes in constructors of inner classes and enum types. 8.6.00 PGD-756 CORE Fixed detection of functional interfaces. 8.6.00 PGD-750 CORE Fixed UnsupportedOperationException when optimizing enum types in closure arguments. 8.6.00 PGD-752 CORE Fixed preverification of initializers with inlined exception throwing code. 8.6.00 PGD-744 CORE Fixed potential ClassCastException when optimizing method handles of simple enum types. 8.6.00 PGD-741 CORE Improved incremental obfuscation. 8.6.00 PGD-740 CORE Fixed shrinking of nest member attributes. 8.6.00 PGD-739 CORE Fixed the counter for the number of inlined constant parameters. 8.6.00 PGD-188 CORE Added support for nest-based access control and dynamic constants in Java 11. 8.6.00 PGD-735 CORE Fixed processing of parameter annotations in constructors of inner classes and enum types. 8.6.00 PGD-734 CORE Fixed detection of functional interfaces with Object methods. 8.6.00 PGD-709 CORE Improved error messages for problems parsing wildcards. 8.6.00 PGD-680 CORE Fixed resolution of class members in Java 11 or higher. 8.6.00 DGD-1138 GRADLE Added support for the Android Gradle plugin version 3.5. Upgrade considerations : The DexGuard gradle plugin is now a separate jar ( lib/dexguard-gradle-plugin.jar ) and local integration in the build.gradle has slightly changed as it has now some transitive dependencies. The file lib/dexguard.jar does not include the gradle plugin anymore and should only be used for standalone processing.","title":"Version 8.6 February 2020"},{"location":"releasenotes.html#version-85-august-2019","text":"Dex conversion. Dex Conversion has been changed to use D8 by default. Multidex improvements. Support for multidexing in applications has been improved to be as compatible as possible to the standard Android gradle plugin. Improved root detection. DexGuard now more reliably detects magisk. Version Issue Module Explanation 8.5.18 DGD-1594 CORE Fixed merging of wrapper classes when processing some apk files. 8.5.18 DGD-1615 CORE Avoiding backup file naming issue of resource files in libraries. 8.5.17 DGD-1567 RUNTIME Fixed crashes in DexGuard runtime library on devices running Android API less than 21. 8.5.17 DGD-1564 CORE Fixed merging of wrapper classes when processing some apk files. 8.5.16 DGD-1552 CORE Avoiding Windows file naming issue of resource files in libraries. 8.5.15 DGD-1505 CORE Completed fix for encrypted resources which got corrupted in app bundles. 8.5.14 DGD-1539 RUNTIME Qualified Magisk as a root hider in root detection. 8.5.14 DGD-1497 RUNTIME Fixed crashes when calling HookDetector.isApplicationHooked in apps using TensorFlow libraries. 8.5.14 DGD-1486 RUNTIME Fixed crashes when calling HookDetector.isApplicationHooked in multiple threads simultaneously. 8.5.13 DGD-1507 CORE Fixed issue in Gson optimization that could cause verification errors when used on abstract classes. 8.5.12 DGD-1508 CORE Updated dictionary.txt to avoid problems on some Samsung devices. 8.5.12 DGD-1531 RUNTIME Fixed false positives when calling RootDetector.isDeviceRooted on devices running Android 9 and lower. 8.5.12 DGD-1532 GRADLE Fixed issue in the Gradle plugin where variant resolution could fail when a flavor dimension is declared but not used by any product flavor. 8.5.12 DGD-1516 CORE Added support for resource string encryption when resources are used as input to TextView.setText(int) . 8.5.12 DGD-1519 CORE Added support for new dialog destination elements introduced in navigation component v2.1.0. 8.5.12 DGD-1515 CORE Ensured that the build fails when using a minSdkLevel of 21+ and the resulting application does not fit into a single dex file but -multidex was not specified. 8.5.12 PGD-19 CORE Fixed potential issues when removing unused parameters in method descriptors (optimization method/removal/parameter ). 8.5.12 PGD-18 CORE Fixed potential case where parameterless constructors were made private during optimization. 8.5.12 CORE Fixed Windows batch script for generating keep rules for an aar file. 8.5.12 DGD-1454 CORE Adjusted defaults for dex conversion when using d8 to avoid rare build errors due to dex overflows. 8.5.12 DGD-1498 GRADLE Made gradle plugin more robust wrt gradle buildscript classpath issues and support including the plugin inside the buildSrc environment. 8.5.12 CORE Fixed configuration of advanced/KeyCzar sample wrt logging removal. 8.5.11 DGD-1474 RUNTIME Improved detection of Magisk Manager app. 8.5.11 JSG-53 CORE Fixed escaping of encrypted JavaScript strings. 8.5.11 JSG-47 CORE Fixed wrongly obfuscated JavaScript variables when obfuscation was disabled. 8.5.11 JSG-55 CORE Fixed wrong parenthesization of template call expressions in JavaScript code. 8.5.11 DGD-1503 CORE Added default filter to prevent processing of versioned class files. 8.5.11 CORE Fixed processing of app bundles that use -encryptresourcefiles in combination with bundletool. 8.5.11 DGD-1505 CORE Fixed encryption of resource strings when building app bundles. 8.5.11 DGD-1496 GRADLE Fixed issue in the Gradle plugin with missing consumer rules when using disabled variants in project dependencies. 8.5.10 DGD-1492 RUNTIME Fixed false positives when calling VirtualEnvironmentDetector.isRunningInVirtualEnvironment on Asus Zenfone 6 devices running Android 9. 8.5.10 DGD-1485 RUNTIME Fixed false positives when calling VirtualEnvironmentDetector.isRunningInVirtualEnvironment on Nvidia Shield TV devices. 8.5.10 DGD-1491 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on certain Xiaomi devices. 8.5.10 CORE Fixed parsing maxSdkVersion from the AndroidManifest.xml . 8.5.10 DGD-1477 GRADLE Fixed gradle plugin to support Android gradle plugin 3.5.2 due to missing dependencies. 8.5.10 DGD-1465 CORE Fixed potential NoSuchElementException when building projects with submodules and complex flavor setups. 8.5.10 DGD-1481 GRADLE Fixed including consumer Proguard rules from submodules when enabling on demand configuration with gradle 5.5+. 8.5.10 DGD-1489 CORE Fixed potential IllegalArgumentException with message Value \"x\" is not a reference value when optimizing code with conditional casts. 8.5.10 DGD-1483 CORE Added support for proper obfuscation of argument types (attribute argType ) when using the androidx navigation library. 8.5.10 DGD-1221 CORE Improve default configuration to support optimization of default constructors. 8.5.10 DGD-1381 GRADLE Fixed including dependent modules when building library projects with Android gradle plugin 3.5+. 8.5.10 DGD-1484 GRADLE Fixed issue in the gradle plugin where dependencies got collected wrongly in combination with the realm plugin. 8.5.10 DGD-1459 GRADLE Fixed issue in the gradle plugin where project dependencies in a composite build were included wrongly. 8.5.10 DGD-1476 CORE Fixed potential NullPointerException during processing when no -libraryjars option has been specified. 8.5.10 DGD-1424 CORE Fixed incomplete fix in case of inlining methods with type annotations. 8.5.10 CORE Added marker for dex files when using d8 as conversion mechanism. 8.5.10 DGD-1468 CORE Fixed default configuration of side effects for the java.lang.Character#toChars(int, char[], int) method which resulted in broken androidx emoji compatibility library. 8.5.09 CORE Fixed potential loading errors for encrypted native libraries when no abiFilter is defined and improved error reporting in case of problems. 8.5.09 CORE Fixed potential loading errors for encrypted native libraries on Android P+ devices in projects with targetSdkVersion >= 25 and not using the nativeloader mechanism. 8.5.08 CORE Fixed support for missingDimensionStrategy settings when including library modules that do not have any flavors. 8.5.07 DGD-1452 GRADLE Fixed issue in the gradle plugin where classes starting with an _ were not included correctly in library projects. 8.5.07 DGD-1447 CORE Added support for private resources in library projects. 8.5.07 DGD-1448 GRADLE Fixed potential infinite loop when analysing project dependencies in the gradle plugin introduced by adding support for AGP 3.5. 8.5.07 DGD-1449 CORE Fixed NoClassDefFoundError in library projects that use the Gson library. 8.5.07 DGD-1445 GRADLE Fixed support for missingDimensionStrategy settings in build.gradle when using the gradle plugin introduced by adding support for AGP 3.5. 8.5.06 CORE Fixed generation of maindexlist.txt and proguard.map in app bundles to not rely on default encoding. 8.5.06 DGD-1429 GRADLE Fixed considerable slowdown in configuration phase when using the gradle plugin with Android gradle plugin v3.5.0+. 8.5.06 DGD-1416 RUNTIME Fixed potential file descriptor leakage when calling HookDetector.isApplicationHooked on Android 7+ devices. 8.5.06 DGD-1343 CORE Ensured that lambda expressions are always backported by default even when specifying a minSdkVersion of 26+. 8.5.06 DGD-1430 RUNTIME Fixed potential exception when calling RootDetector.isDeviceRooted on some Tecno devices. 8.5.06 GRADLE Backported support for the Android Gradle plugin version 3.5. 8.5.06 DGD-1424 CORE Fixed potential build error when inlining methods into code attributes with type annotations. 8.5.06 DGD-1359 CORE Fixed removal of non-static write-only fields (optimization field/removal/writeonly ). 8.5.06 DGD-1421 GRADLE Added package-info.class files to the default input filter of the gradle plugin. 8.5.05 DGD-1406 GRADLE Removed redundant library jar input when building library projects with Android gradle plugin 3.4+. 8.5.05 CORE Fixed propagation of UnsatisfiedLinkErrors when trying to load missing native libraries with enabled native library encryption. 8.5.05 DGD-1414 CORE Improved detection of hard-coded reflection on class members. 8.5.05 DGD-1374 CORE Updated used kotlin version in sample advanced/Kotlin to 1.3.50 . 8.5.05 DGD-1378 CORE Added support for targeting jvm 1.8 ( jvmTarget = \"1.8\" ) when compiling kotlin code. 8.5.05 DGD-1378 CORE Added support to natively backport usages of the java.lang API introduced in Java 8. 8.5.04 CORE Improved deobfuscation of arbitrary lines when using the -greedy option of the retrace utility. 8.5.04 DGD-1381 CORE Fixed including dependent library projects as -libraryjar input when building library projects. 8.5.04 RUNTIME Fixed potential ANR when running the RootDetector on some Samsung devices. 8.5.04 RUNTIME Fixed crashes an potential false positives when running VirtualEnvironmentDetector on devices with API level < 17. 8.5.04 DGD-1377 CORE Fixed issue in SSLPinning(System)WebViewClient where web pages were loaded in plain text instead of being rendered. 8.5.04 CORE Ensured that the build fails when the dex file overflows and -multidex is not specified in the configuration. 8.5.03 DGD-1354 RUNTIME Fixed potential runtime exception when using the HookDetector on some Pixel 3 devices running Android Q beta 5+. 8.5.03 DGD-1361 CORE Kotlin DebugMetadata annotations are now removed by default unless the kotlin.coroutines.jvm.internal.DebugMetadata class is kept explicitly. 8.5.03 DGD-1372 CORE Correctly disable class level optimizations for classes originating from dynamic feature modules when building app bundles. 8.5.03 CORE Added support for Android Studio 3.5 in the Android Studio plugin. 8.5.03 DGD-1371 CORE Fixed partitioning of injected classes in case they are accessed from multiple dynamic feature modules. 8.5.02 DGD-1366 GRADLE Fixed issue in the Gradle plugin where file dependencies were collected incorrectly when using the Android Gradle plugin version 3.4. 8.5.02 DGD-1365 GRADLE Fixed issue in the Gradle plugin where annotation processor metadata files were not collected in library projects. 8.5.02 JSG-18 CORE Improved reporting of statistics for all processing steps of JavaScript obfuscator. 8.5.02 JSG-37 CORE Improved performance of name obfuscation of JavaScript obfuscator. 8.5.02 JSG-45 CORE Fixed possible NullPointerException in opaque predicate injection of JavaScript obfuscator. 8.5.02 JSG-44 CORE Fixed possible NullPointerException in debugger obstruction of JavaScript obfuscator. 8.5.02 DGD-1349 CORE Added option -greedy to the retrace utility in order to retrace obfuscated classnames in unrecognized lines. 8.5.02 DGD-1357 CORE Added support to retrace stacktraces printed by crashlytics including additional source line information (e.g. at o.afc.b + 45(:45) ). 8.5.01 DGD-1353 RUNTIME Fixed memory protection of executable regions in HookDetector while running on Android Q. 8.5.00 DGD-975 GRADLE Added documentation how to use the secure maven repository to easy integration into gradle. 8.5.00 JSG-2 CORE Added configuration debugging option for JavaScript obfuscator. 8.5.00 JSG-1 CORE Improve shrinking of JavaScript obfuscator by taking variable scopes into account. 8.5.00 DGD-1312 CORE Fixed duplicate execution of DexGuard when building app bundles in combination with the io.fabric plugin (requires io.fabric plugin version 1.31.0+). 8.5.00 DGD-891 CORE Improved -addconfigurationdebugging to reduce false positives. 8.5.00 DGD-1301 CORE Fixed optimization of exceptions as unused parameters. 8.5.00 CORE Fixed printing unintended warnings about constructors when using -virtualizecode . 8.5.00 CORE Updated D8 tool for class conversion to version 1.5.54. 8.5.00 DGD-1280 CORE Further improved multidex partitioning when using application classes extending other classes. 8.5.00 DGD-1280 CORE Fixed multidex partitioning to only perform recursive marking for classes referenced from the attachBaseContext and init methods instead of the whole application class. 8.5.00 CORE Added a command line tool to generate necessary rules to keep everything of an aar file. 8.5.00 DGD-1164 GRADLE Fixed potential warning about dependencies evaluated too early in the gradle plugin. 8.5.00 DGD-951 GRADLE Fixed warning about invalid task inputs in the gradle plugin. 8.5.00 DGD-1276 CORE Fixed optimization of Groovy code constructs causing Dalvik conversion errors. 8.5.00 DGD-1206 RUNTIME Fixed issue relating to the runtime library loading when both HookDetector and RootDetector are used and they encrypted too. 8.5.00 DGD-1058 CORE Take the minSdkVersion attribute into account when using d8 as conversion tool. 8.5.00 CORE Made d8 the default dex conversion mechanism which provides fixes for many device specific bugs. 8.5.00 DGD-1241 RUNTIME Fixed false positives when calling RootDetector.isDeviceRooted . 8.5.00 DGD-2018 CORE Added new option -printresourceusage to print a list of unused resources in the input APK. 8.5.00 DGD-1141 RUNTIME Improved magisk detection. 8.5.00 DGD-1180 CORE Fixed automatic generation of consumer ProGuard rules that accidentally included the inmaindex modifier. 8.5.00 CORE Updated dx tool for class conversion to build tools version 28.0.3. 8.5.00 DGD-1009 CORE Improved obfuscation of DexGuard runtime library. 8.5.00 RUNTIME Added support for inline hook detection. Tools like Frida use inline hooking. 8.5.00 RUNTIME Added a FAST flag to the HookDetector for faster hook detection. 8.5.00 RUNTIME Added a new Runtime API VirtualEnvironmentDetector.isRunningInVirtualEnvironment for virtual environment detection. 8.5.00 RUNTIME Improved security of RootDetector by removing package names. 8.5.00 RUNTIME Improved emulator detection to detect emulators, such as LDPlayer and Nox. 8.5.00 DGD-1072 GRADLE Added support for the Android Gradle plugin 3.4. 8.5.00 DGD-1137 CORE Added new option -printmaindexlist to print why classes are placed in the primary dex. 8.5.00 CORE Added modifier inmaindex to -keep rules to force classes to be put in the maindex. 8.5.00 DGD-521 GRADLE Multidex partitioning has been reworked to be as compatible as possible compared to the Android gradle plugin. 8.5.00 DGD-1093 CORE Improved handling of dynamic features and multidex. 8.5.00 DGD-1077 CORE Improved configuration of the FileChecker class. Upgrade considerations : The JavaScript obfuscator is now included in dexguard.jar instead of being packaged in a separate dexguard-javascript.jar . You should remove the line 'classpath ':dexguard-javascript:' from your build.gradle` file. Multidex partitioning has been reworked to be as compatible as possible compared to the standard Android gradle plugin. As a consequence, the allowmultidexing modifier for -keep rules is enabled by default. To force a specific class to be put in the main dex file you can either add the modifier inmaindex to any -keep rule, or specify a corresponding multiDexKeepFile or multiDexKeepProguard property in your build.gradle script. By default, d8 (default dex conversion tool from the standard Android build tools since v3.2.0), will be used to convert class files to the dex format. In order to use the old, internal conversion mechanism, specify a system property conversion.tool=internal . Alternatively, dx can be activated via conversion.tool=dx (system properties can also be specified in the gradle.properties file via systemProp.conversion.tool=xxx ). Note: in case the WhiteboxCrypto addon is used, it is advised to switch to the internal conversion for performance reasons. Various artifacts included in the distribution are now accessible via a secure maven repository.","title":"Version 8.5 August 2019"},{"location":"releasenotes.html#version-84-february-2019","text":"Support for dynamic features. DexGuard now supports the new Google Play Store app service model, called dynamic delivery. It allows to further reduce the initial application size by installing features on demand. Javascript obfuscation. DexGuard already had a plugin mechanism for third-party obfuscators. It now offers its own implementation with fundamental techniques, smoothly integrated. Improved runtime detections. Various detection mechanism for root or virtual environments and hooking frameworks have been improved. Version Issue Module Explanation 8.4.19 DGD-1345 GRADLE Fixed issue in the Gradle plugin where duplicate classes were collected when dependending on an android library project. 8.4.18 CORE Fixed system property obfuscate.applymapping.conservatively when used in combination with espresso tests. 8.4.17 CORE Added system property obfuscate.applymapping.conservatively to prevent applying new names to explicitly kept classes / members. 8.4.17 CORE Fixed potential build error when combining class encryption with apk processing in rare cases. 8.4.17 CORE Fail the build in case conversion tool d8 is chosen and there are conversion errors. 8.4.17 CORE Enabled -multidex by default when building espresso test apks. 8.4.16 DGD-1341 CORE Improved default configuration for the firebase library. 8.4.16 CORE Improved default configuration to prevent class merging for classes of the Android multidex support library. 8.4.16 DGD-1340 CORE Fixed SSLPinning and SSLPinningWebView samples by updating the used certificates. 8.4.16 DGD-1339 GRADLE Fixed processing of surrogate pairs (used by emoji characters) when using Android gradle plugin 3.3+. 8.4.16 DGD-1335 CORE Improved configuration for latest version of constraint-layout library (v 2.0.0-beta1+). 8.4.16 DGD-1326 GRADLE Added the DexGuard license file to the default input filter the Gradle plugin uses. 8.4.16 PGD-759 CORE Fixed backporting of Java 8 API types when used as parameters in private methods. 8.4.16 PGD-749 CORE Fixed merging of classes containing type annotations with empty targets. 8.4.15 DGD-1334 CORE Improved performance of name obfuscation of JavaScript obfuscator. 8.4.15 DGD-1210 CORE Improved build performance when using -useuniqueclassmembernames . 8.4.15 DGD-1332 CORE Added support for processing dex format 038 when performing apk processing. 8.4.15 DGD-1331 CORE Fixed conversion of not-int instructions when performing apk processing. 8.4.15 DGD-1328 CORE Fixed conversion of consecutive phi nodes when performing apk processing. 8.4.15 DGD-1282 CORE Fixed optimization of final fields that might be accessed before initialization. 8.4.15 DGD-1327 CORE Fixed generation of mapping information in case of class merging. 8.4.15 DGD-1253 CORE Fixed issue in JavaScript obfuscator that could cause IllegalStateException. 8.4.14 DGD-1323 CORE Fixed potential ClassCastException when virtualizing code. 8.4.14 DGD-271 CORE Worked around bug on Android 6/7 devices causing spurious EISDIR error when decrypting encrypted classes (regression introduced due to change of conversion tool). 8.4.14 DGD-1317 CORE Fixed potential build errors when optimizing methods with many parameters. 8.4.14 DGD-1322 CORE Fixed issue in JavaScript name obfuscation that could cause name collisions with undeclared global variables. 8.4.14 DGD-1321 CORE Fixed issue in control flow and arithmetic obfuscation of JavaScript code that could cause name collisions. 8.4.14 DGD-1320 CORE Fixed issue in string encryption of JavaScript obfuscator that could cause name collisions. 8.4.14 DGD-1319 CORE Fixed issue in JavaScript obfuscation of property declarations containing non-ASCII characters. 8.4.14 DGD-1311 CORE Fixed encoding of surrogate pairs contained in Android resource tables. 8.4.14 DGD-1313 CORE Fixed StackOverflowError in name obfuscation of large JavaScript files. 8.4.13 DGD-1304 CORE Fixed potential VerificationError on Android 4.4 when processing the Kotlin coroutines library. 8.4.13 DGD-1298 CORE Fixed optimization of exception handling in Kotlin runtime. 8.4.13 DGD-1301 CORE Fixed optimization of exceptions as unused parameters. 8.4.13 DGD-1276 CORE Fixed optimization of Groovy code constructs causing Dalvik conversion errors. 8.4.13 DGD-1308 CORE Fixed removal of annotation attributes from class members during Gson optimization. 8.4.13 DGD-1307 CORE Fixed potential NullPointerException when using -whyareyoukeeping . 8.4.13 DGD-901 CORE Added support to include a mainDexList.txt file when building app bundles with minSdkVersion < 21 . 8.4.13 DGD-1305 CORE Avoided unnecessary notes about descriptor classes that are not being kept. 8.4.13 DGD-1306 CORE Fixed issue in number obfuscation of JavaScript obfuscator that could cause an IllegalArgumentException . 8.4.12 DGD-1261 CORE Improved loading of applications using -pack option by adding additional fallback mechanisms. 8.4.12 DGD-1266 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked when using javascript library j2v8. 8.4.12 DGD-1275 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked when using React Native. 8.4.12 DGD-1302 CORE Fixed processing of pre-obfuscated native libraries that can not be read by DexGuard. 8.4.12 DGD-1299 CORE Improved default configuration for the wear / wearable support library. 8.4.12 DGD-1292 GRADLE Fixed severity of errors and warnings printed by the DexGuard Gradle plugin (from severity info to warn). 8.4.12 DGD-1296 CORE Fixed usage of signing certificates with DSA signature algorithm and minSdkVersion <= 21 . 8.4.12 DGD-1290 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on some Android 5.1 devices. 8.4.12 DGD-1291 GRADLE Fixed issue in the Gradle plugin where some metadata was generated incorrectly, causing issues with gradle install and Android Studio. 8.4.12 DGD-1288 CORE Improved default configuration for the Firebase Firestore library. 8.4.12 DGD-1284 CORE Improved performance of various processing steps in case many resource files are present. 8.4.12 DGD-1285 GRADLE Fixed issue in the Gradle plugin where changing the outputFile property of a VariantOutput instance could cause a FileNotFoundException . 8.4.12 DGD-1281 GRADLE Fixed issue in the Gradle plugin where building app bundles didn't get configured correctly on Windows. 8.4.12 DGD-1276 CORE Fixed bug in JavaScript obfuscator where parentheses weren't always added around expressions where they are necessary. 8.4.12 DGD-1278 CORE Added additional comments to the file generated by the tasks collectConsumerProguardFiles that state the origin of the rules below them. 8.4.12 DGD-1277 GRADLE Fixed issue in the Gradle where writing out the consumer proguard rules wouldn't be written out correctly when calling the Gradle task collectConsumerProguardFiles . 8.4.12 DGD-1273 GRADLE Fixed building some samples with gradle 4.10+. 8.4.12 DGD-1258 CORE Fixed potential VerifyError in JVM caused by inlining methods from super class. 8.4.12 CORE Improved default configuration for the Google GMS Wallet library. 8.4.11 CORE Fixed potential IllegalStateException(\"unexpected block size\") at runtime when reading encrypted data items. 8.4.11 DGD-1251 CORE Fixed unpacking and filtering of app bundles inside other archives. 8.4.11 DGD-1255 CORE Correctly take property minSdkVersion into account when using an external dex conversion tool. 8.4.11 DGD-1209 GRADLE Added support for the Android Gradle plugin version 3.4. 8.4.11 DGD-1249 CORE Added additional warnings in case obfuscation of JNI interfaces exceeds existing size of string section. 8.4.10 DGD-1242 GRADLE Fixed issue in the Gradle plugin where duplicate class warnings would be emitted when using file dependencies. 8.4.10 DGD-1124 CORE Fixed potential build error while optimizing tail recursion. 8.4.10 CORE Fixed potential NullPointerException when backporting lambda expressions that reference unknown classes. 8.4.10 CORE Fixed potential problem with class encryption on Android 6.0 devices. 8.4.10 DGD-1214 RUNTIME Fixed false positives when calling HookDetector.isApplicationHooked on some Android 7.1.1 devices. 8.4.10 DGD-1237 CORE Added default configuration for the joda-time-android library. 8.4.10 DGD-1234 CORE Fixed duplicate library jars when building app bundles with dynamic features. 8.4.10 DGD-1229 CORE Fixed NoSuchMethodException caused by Gson optimization of enum types written in Kotlin. 8.4.10 DGD-1230 RUNTIME Fixed false positives in HookDetector in case native libraries are referencing each other. 8.4.10 DGD-1248 GRADLE Fixed usage of DexGuard elements in gradle build scripts when using Kotlin DSL. 8.4.10 DGD-1213 CORE Fixed obfuscation of property names in JavaScript code that occur in property definitions. 8.4.09 DGD-1212 CORE Fixed obfuscation of property names in JavaScript code that occur in destructuring assignments. 8.4.09 DGD-1227 CORE Include information about the conversion tool being used to build the apk. 8.4.09 DGD-1226 CORE Fixed including local variable information when using d8 as conversion tool for debuggable build types. 8.4.09 DGD-1222 CORE Fixed potential problems with class encryption on API 26+ devices. 8.4.09 DGD-1077 CORE Improved configuration of the FileChecker class. 8.4.09 DGD-1211 CORE Fixed incorrect values in enabled column of configuration overview printed out by JavaScript obfuscator. 8.4.09 PGD-745 CORE Fixed IllegalArgumentException for comparison of constant arrays with NaN float/double values. 8.4.09 DGD-1207 GRADLE Fixed issue in the Gradle plugin where too many libraries were included when using the databinding library and Gradle 5+. 8.4.09 DGD-1203 GRADLE Fixed issue where DexGuard wouldn't be executed when using gradle 4.6 in combination with Android gradle plugin 3.2+. 8.4.09 DGD-1205 RUNTIME Fixed potential NullPointerException when calling HookDetector.isAppplicationHooked . 8.4.08 CORE Fixed handling of missing or inaccessible system files in DexGuard runtime. 8.4.08 DGD-1196 CORE Fixed error in Gson optimization that could cause issues during class conversion. 8.4.08 DGD-1087 CORE Added missing case to fix potential verify error on Android 4.4 and below when virtualizing code. 8.4.08 DGD-1199 GRADLE Fixed issue in the Gradle plugin where in library projects Android resources from dependencies could end up in the final aar. 8.4.08 DGD-1197 GRADLE Fixed issue in the Gradle plugin where the default assetInputFilter contained a small mistake where hidden files would be accepted if present in the assets. 8.4.08 DGD-1198 CORE Treating dex files in assets and res directories as plain resource files. 8.4.08 DGD-1168 CORE Fixed potentially printing incorrect warnings during class encryption about not encrypting inner classes. 8.4.08 DGD-1178 CORE Fixed potential build errors when optimizing enums with private instance methods. 8.4.08 DGD-1190 RUNTIME Added hook detection for the linker. 8.4.08 DGD-1181 CORE Fixed runtime library to avoid linker warnings printed to logcat. 8.4.08 DGD-710 FP-ADDON Extended device fingerprinting add-on with new flags DEVICE, SIM_CARD, ADVERTISING_ID, and APP_USER_ID. 8.4.08 DGD-1193 CORE Updated sample license for Android Things samples. 8.4.07 DGD-1049 GRADLE Fixed regression in the Gradle plugin where the DexGuard bundle task was executed when building an apk with Crashlytics (or any other service that requests the mapping file via the variant interface). 8.4.07 DGD-1136 CORE Fix potential runtime exceptions when using class encryption on specific Android 6.x devices. 8.4.07 DGD-1105 CORE Print relevant information when encountering an error during class conversion using dx. 8.4.07 DGD-1179 CORE Added printing notes when encountering unknown classes in configuration options -encryptclasses, -obfuscatecode, and -virtualizecode. 8.4.07 DGD-504 CORE Fixed potential build errors when optimizing Kotlin code that combines let and the Elvis operator ?: . 8.4.06 DGD-1140 CORE Updated version check plugin to include version information in its user-agent settings. 8.4.06 CORE Fixed default configuration dexguard-debug-shrink.pro resulting in missing resource tables. 8.4.06 DGD-1173 CORE Fixed building app bundles when using stable resource ids that exceed the number of existing resource for a given type spec. 8.4.05 DGD-1173 CORE Fixed building app bundles when requesting stable resource ids (using --stable-ids flag to aapt2). 8.4.05 DGD-1174 CORE Fixed potential build error with missing class hierarchies (regression introduced by DGD-1148). 8.4.05 DGD-1172 CORE Fixed issue introduced by DGD-1164 where DexGuard wouldn't be executed when using configure on demand. 8.4.04 DGD-1169 GRADLE Updated samples so they all build with Gradle 5. 8.4.04 DGD-1170 CORE Fixed a potential build error when building app bundles with variable native library encryption (regression introduced by DGD-1070). 8.4.04 DGD-1148 CORE Fixed potential build errors when encrypting certain Kotlin classes. 8.4.04 CORE Improved default configuration for Android Architecture Lifecycle library. 8.4.04 DGD-1164 GRADLE Fixed issue in the Gradle plugin where tasks could be resolved too early when creating dependencies. 8.4.04 DGD-1166 CORE Added the possibility to specify a class input filter for Espresso tests. 8.4.04 DGD-1165 GRADLE Fixed issue in the Gradle plugin where the setup task for an Espresso test could run before the DexGuard task of the main app. 8.4.04 DGD-1163 GRADLE Improved performance of the Gradle plugin for Android Gradle plugin 3.2 and 3.3 support. 8.4.04 CORE Updated Espresso sample to use androidx. 8.4.04 DGD-1113 CORE Added default rules for androidx to the dexguard-espresso.pro default configuration. 8.4.03 DGD-1160 CORE Bump supported bundletool version to 0.5.0 when building app bundles. 8.4.03 DGD-1157 CORE Fixed shrinking of resource values that are only referenced from resource XML files (regression introduced by DGD-1039). 8.4.03 DGD-1158 CORE Fixed retrace tool in case the source file attribute contains digits. 8.4.03 DGD-1156 GRADLE Fixed issue in the Gradle plugin where the build could fail when using build types that have a capitalized name. 8.4.02 DGD-1153 GRADLE Fixed execution of DexGuard when building on Windows platform and using Android gradle plugin 3.2+. 8.4.02 DGD-1149 CORE Fixed name of intermediate apk when using apk processing. 8.4.02 DGD-1152 GRADLE Fixed building debug builds with minSdkVersion of 21+ in the gradle plugin when using Android gradle plugin 3.3.x. 8.4.02 DGD-1150 CORE Fixed run-time API FileChecker.checkAllFiles for app bundles with code that is fused in universal apks. 8.4.02 DGD-1151 CORE Fixed using option -applymapping in combination with injected classes / members. 8.4.01 DGD-1117 CORE Fixed asset encryption compatibility issue with Ionic webview plugin (version 3.0+) 8.4.01 DGD-1118 CORE Fixed issue in JavaScript obfuscator that could prevent app from launching when property access obfuscation is enabled. 8.4.01 DGD-1124 GRADLE Fixed issue in the gradle plugin where an exception would be thrown if you configured splits that resulted in only 1 output apk. 8.4.01 CORE Correctly take plural resources with quantity zero into account when building app bundles. 8.4.01 CORE Prevent potential out-of-memory exceptions when building app bundles in combination with -multidex . 8.4.01 DGD-1070 CORE Added support for splitting encrypted native libraries in app bundles. 8.4.01 DGD-1106 GRADLE The DexGuard Gradle plugin now provides a task to build an Espresso test apk that can test your obfuscated app bundles, see espresso for more info. 8.4.01 DGD-615 GRADLE Updated dexguard-versioncheck plugin to also take beta channels into account when configured accordingly. 8.4.00 GRADLE Fixed usage of consumerRuleFilter in gradle build scripts. 8.4.00 CORE Corrected broken fix for DGD-1083. 8.4.00 DGD-1086 CORE Fixed processing of -keep rules in the presence of -multidex in combination with app bundles and dynamic features. 8.4.00 DGD-438 CORE Added alternative class obfuscation dictionary which avoids use of UTF-8 characters, see default configs . 8.4.00 DGD-438 CORE Updated class obfuscation dictionary. 8.4.00 DGD-1083 GRADLE The DexGuard Gradle plugin now takes abiFilters correctly into account again. 8.4.00 CORE Fixed generation of app bundles in case multidex is needed and dynamic features are included. 8.4.00 DGD-1039 CORE Classes referenced from resource files are now automatically kept when using -adaptresourcefilecontents. 8.4.00 DGD-1046 GRADLE Added additional check in the gradle plugin to prevent dependency chain loops. 8.4.00 DGD-966 GRADLE Added support for the Android Gradle plugin 3.3.0-rc03. 8.4.00 DGD-826 CORE Added support for Javascript obfuscation. 8.4.00 DGD-933 CORE Extended runtime FileChecker with methods to check all files. 8.4.00 CORE Fixed ConcurrentModificationException when build an app bundle with multiple dynamic features including assets for native libraries. 8.4.00 DGD-1000 CORE Fixed reading of resource XML and resource table files in protobuf format wrt to default string values. 8.4.00 DGD-992 GRADLE Added support in the gradle plugin for the option matchingFallbacks to resolve the variants of the dynamic features used when building an app bundle. 8.4.00 CORE Removed obsolete sample basic/JackToolchain . 8.4.00 CORE Added two Android Things samples. 8.4.00 DGD-938 CORE Added samples basic/DynamicFeatures to show-case support for the new Android Dynamic Delivery feature. 8.4.00 DGD-938 CORE Added support for dynamic features (see also sample basic/DynamicFeatures ). 8.4.00 DGD-580 RUNTIME Added support for GOT hook detection. Also, extended support for hook detection in all native shared libraries. 8.4.00 DGD-905 RUNTIME Added support for virtual environment detection to detect virtual plugin apps, such as VirtualXposed. 8.4.00 DGD-828 RUNTIME Enhanced Magisk detection. Upgrade considerations : Runtime method HookDetector.isApplicationHooked now requires an additional Context argument. The Javascript obfuscation plugin mechanism is now replaced with a built-in Javascript obfuscator. Although the plugin API is still available, we recommend to use the built-in obfuscator. You can switch from a custom plugin to the built-in plugin by removing the -javascriptplugin option from your DexGuard configuration. Additionally, you have to provide a proper JavaScript configuration file via the -javascriptconfiguration option. The format and options of the configuration file are documented in the JavaScript manual that is available in the docs/javascript directory of the release. The Gradle plugin has been reimplemented from scratch. This plugin will be used by default with the Android Gradle plugin 3.2 and beyond, older versions will fall back to the previous implementation. You shouldn't notice any differences unless you are using the dexguard block to configure any filters as the syntax has slightly changed. The Gradle plugin has been made more strict and will fail the build when incompatible Android gradle plugin settings are detected. This is the case for both the old and new implementations of the Gradle plugin. The Gradle plugin does not include all optional libraries by default anymore, if you encounter an error like: Can't find common super class of [com/android/volley/toolbox/HttpClientStack$HttpPatch] (with 1 known super classes) and [com/android/volley/Request] , add the following to your build.gradle file: android { useLibrary 'org.apache.http.legacy' }","title":"Version 8.4 February 2019"},{"location":"releasenotes.html#version-83-december-2018","text":"Code virtualization. This advanced obfuscation technique protects algorithms and their implementations. Improved hook detection. We continue to follow up on the latest technologies. Kotlin support. DexGuard has always supported Kotlin, but it now automatically handles corner cases and optimizes common constructs. GSON optimization. Many Android developers rely on Google's GSON library to create JSON strings. DexGuard now optimizes the convenient but inefficient usage, and improves its obfuscation. Support for app bundles. DexGuard now supports this new format to upload apps to the Google Play store. It allows Google to further optimize downloads for individual end-users, by only packaging the necessary resource files, languages, native libraries, etc. Compatibility with Google Play metadata. Google Play automatically injects metadata into all uploaded apps. This process doesn't interfere with DexGuard's tamper detection techniques. Compatibility with Google Play signing. Google Play optionally signs the apps for developers, if they provide their keys. This process is a bit more intrusive, but it is still compatible with 2 out of 3 of DexGuard's tamper detection techniques. Apk signature scheme v3. The next app signature format, supported as of Android Pie, supports key rotation (developers can switch certificates when they release updates of their apps). Support for D8. DexGuard can convert optimized and protected code with its own internal compiler, with Google's DX compiler, or with the latest D8 compiler. Support for Espresso. DexGuard now works with Android's Espresso testing framework. Version Issue Module Explanation 8.3.15 DGD-1059 CORE Updated Android Studio plugin with recently added configuration options. 8.3.15 DGD-1136 CORE Fixed potential FileNotFoundException when decrypting encrypted classes on specific devices (Android 6.0). 8.3.15 DGD-1124 GRADLE Fixed inconsistency in the gradle plugin with the directory tree when splits were configured that resulted in only 1 output. 8.3.15 DGD-1111 CORE Added check to prevent incredibly small chance of creating invalid files when encrypting native libraries. 8.3.14 DGD-1132 CORE Fixed loading of encrypted native libraries with dependencies. 8.3.14 CORE Added additional fallback locations for loading encrypted classes on API 21+ devices. 8.3.14 DGD-1131 CORE Fixed retrace utility to correctly retrace obfuscated stacktraces with omitted colon before linenumber. 8.3.13 CORE Improved mechanism to determine potential locations for loading decrypted classes. 8.3.13 DGD-1126 CORE Fixed unnecessary compression of WEBP assets. 8.3.13 DGD-1125 CORE Ensure unique resource file names when building app bundles. 8.3.13 DGD-1092 CORE Fixed regression for fonts in different configurations. 8.3.13 DGD-1123 GRADLE Fixed issue in the gradle plugin where classes processed by transform tasks with a limited scope didn't get picked up by DexGuard. 8.3.13 CORE Fixed writing of referenced attribute values in protobuf format. 8.3.12 DGD-1114 CORE Fixed issue with Gson optimization that could cause StackOverFlowError when a serialized class extends a class with many descendants. 8.3.12 DGD-1110 CORE Excluded module-info.class files by default. 8.3.12 DGD-1085 CORE Fixed regression for DGD-185 which disabled signature scheme v2. 8.3.12 DGD-1115 CORE Fixed optimization of ProcessBuilder. 8.3.12 DGD-1092 CORE Fixed name obfuscation of font resources in App Bundles. 8.3.11 DGD-968 CORE Fixed backporting of lambda expressions inside default interface methods. 8.3.10 DGD-1087 CORE Fixed potential verify error on Android 4.4 and below when virtualizing code. 8.3.10 CORE Ensure closing of file resources when using the FileChecker of the DexGuard runtime library. 8.3.10 DGD-1085 GRADLE Fixed implicit usage of apk signature scheme v3 if v2 is disabled via the gradle DSL. 8.3.09 CORE Fixed injection of unneeded decryption code for encrypted resources in included library code. 8.3.09 DGD-1081 CORE Fixed issue in Gson optimization when using custom TypeAdapters for primitive types. 8.3.09 DGD-1076 CORE Fixed NullPointerException when using -addconfigurationdebugging in library projects. 8.3.08 DGD-1073 CORE Fixed issue with class merging that could cause problems with Gson library. 8.3.08 DGD-1074 CORE Refined configuration for the Google client API. 8.3.08 DGD-1062 CORE Added verbose statistics for Gson optimization. 8.3.08 DGD-1071 GRADLE Fixed gradle plugin to take modified output filenames correctly into account. 8.3.08 DGD-1063 CORE Updated default configuration to support recent changes in the Samsung store. 8.3.08 DGD-1069 CORE Fixed generation of app bundles in combination with native library encryption. 8.3.07 DGD-1067 CORE Added support for Android Studio 3.3 in the Android Studio plugin. 8.3.07 DGD-1068 GRADLE Fixed small issue in the gradle plugin where task dependencies on tasks from different projects couldn't be resolved. 8.3.07 DGD-1066 CORE Fixed encryption of resource strings. 8.3.06 CORE Fixed espresso test support by ensuring that no additional obfuscation is performed on the test apk. 8.3.06 DGD-1029 CORE Fixed NoSuchMethodException introduced by Gson optimization when using Gson version before 2.7. 8.3.05 DGD-1057 CORE Fixed potential build errors when performing debug builds using dx as conversion mechanism. 8.3.05 DGD-1027 GRADLE Fixed issue in the gradle plugin where creating a signed app bundle via Android Studio created an unsigned app bundle. 8.3.05 DGD-1051 GRADLE Fixed issue in the gradle plugin where instant run builds would fail. 8.3.04 DGD-1054 CORE Fixed writing of consumer proguard rules in library projects having consumer proguard rules but no API keep rules. 8.3.04 DGD-1024 CORE Fixed issue in resource name obfuscation that caused problems with ConstraintLayouts. 8.3.04 DGD-1049 GRADLE Fixed issue in the gradle plugin where the DexGuard bundle task is always executed when building an apk if the Crashlytics gradle plugin is used. 8.3.04 CORE Fixed encryption of string resources which are referenced from resource XML files in case of multiple configurations. 8.3.04 DGD-1050 CORE Fixed obfuscation of enums in annotations, for conversion by dx or D8. 8.3.04 DGD-1044 CORE Fixed NullPointerException during Gson optimization when field type of a serialized class is a class that is not processed by DexGuard. 8.3.04 DGD-1021 CORE Fixed backporting of default interface methods that reference private inner classes / members. 8.3.04 DGD-1040 GRADLE Fixed issue in the gradle plugin where bundle split options weren't picked up correctly. 8.3.03 DGD-1036 CORE Avoiding unpacking archives from the assets directory. 8.3.02 GRADLE Removed check for incompatible settings in the gradle plugin when apk processing is enabled. 8.3.02 DGD-1031 CORE Fixed loading of encrypted classes when used in combination with -obfuscatecode and strength medium or high on Android devices with API 26+. 8.3.02 DGD-996 CORE Fixed conversion of classes that contain large arrays when using dx or d8. 8.3.02 DGD-1033 CORE Fixed issue in Gson optimization that could result in constructors with invalid access modifiers. 8.3.02 CORE Write local variable information in dex format when keeping the LocalVariableTableAttribute . 8.3.02 DGD-980 CORE References to color attributes inside selector drawable XML's are no longer inlined (it may break the correct rendering of the drawable). 8.3.01 CORE Disabled resource deduplication and resource compaction optimizations. You can enable them again by including 'dexguard-resource-optimizations.pro' as the first configuration file. 8.3.01 DGD-1020 GRADLE Fixed dependency issue in the gradle plugin where the DexGuard task for app bundles was also executed when building an Espresso test. 8.3.01 DGD-1019 GRADLE Fixed issue in the gradle plugin where not all compile-only dependencies were picked up correctly. 8.3.00 CORE Updated sample advanced/Realm to the latest realm version 5.8.0. 8.3.00 DGD-1008 CORE Fixed NoClassDefFoundError during Gson optimization when running DexGuard standalone. 8.3.00 CORE Default configuration for androidx ( dexguard-androidx.pro ) is now included by default. 8.3.00 CORE Fixed loading of native libraries from encrypted classes (regression due to DGD-555). 8.3.00 DGD-812 GRADLE Added support in the gradle plugin for the matchingFallbacks option when collecting consumer proguard files. 8.3.00 DGD-974 CORE Enabled dx as default dex conversion mechanism. 8.3.00 DGD-986 CORE Removed setting encrypt.classes.showlog . 8.3.00 DGD-555 CORE Improved loading of encrypted classes on API level >= 26. 8.3.00 DGD-973 CORE Added new option -randomizationseed to provide an additional value that will be taken into account when generating a seed value to randomize the obfuscation. 8.3.00 DGD-967 GRADLE Improved performance of gradle plugin by evaluating dependencies at most once. 8.3.00 DGD-976 CORE The license check will now accept certain named suffixes when added to valid package names: .test, .dev, .qa, .debug, .alpha, .beta . 8.3.00 GRADLE Fixed building of app bundles when calling gradle with an absolute task path as start parameter, e.g. :app:bundleRelease . 8.3.00 GRADLE The gradle plugin will now fail the build when encountering incompatible settings for build variant configured for DexGuard. 8.3.00 CORE The FileChecker returns now a distinct error code if the control manifest is missing. 8.3.00 DGD-937 CORE Added support to include the mapping file when creating app bundles. 8.3.00 DGD-741 CORE Added support to preserve parameter names when applying -obfuscatecode or -virtualizecode on methods. 8.3.00 DGD-913 RUNTIME Added support for multiple digest algorithms when performing file-level tamper detection using the FileChecker (supported by default SHA1 and SHA-256). 8.3.00 DGD-931 CORE Added verbose output about removed resource entries and meta-data elements. 8.3.00 DGD-924 CORE Fixed encoding of file type for raw xml resources when building app bundles. 8.3.00 DGD-929 CORE Fixed support for using the FileChecker when building app bundles. 8.3.00 DGD-908 CORE Fixed references to resource files outside of the res directory when creating app bundles. 8.3.00 DGD-923 CORE Fixed handling of resource files in combination with -keepresourcefiles rules when creating app bundles. 8.3.00 DGD-921 CORE Fixed writing of resource XML files in protobuf format when creating app bundles. 8.3.00 DGD-921 CORE Fixed encoding of attributes encountered in resource tables when creating app bundles. 8.3.00 CORE Fixed encoding of some id resources in the resource table when creating app bundles. 8.3.00 DGD-909 CORE Fixed encoding of some configuration values in the resource table when creating app bundles. 8.3.00 DGD-906 CORE Improved obfuscation of target activity names in activity aliases. 8.3.00 DGD-892 CORE Invalid use of wildcards <fields> and <methods> in member specifications will now result in a ParseException. 8.3.00 DGD-896 CORE Fixed apk processing in case of implicit conversion of boolean values to integers. 8.3.00 CORE Added manual page about upgrading from ProGuard. 8.3.00 DGD-591 CORE Improved initialization and logging of reflection calls. 8.3.00 CORE Fixed backporting of default interface methods if an interface extends another one. 8.3.00 CORE Updated D8 to version 1.2.38. 8.3.00 DGD-809 CORE Fixed potential VerifyErrors in obfuscated code attributes due to an invalid assumption about the instance variable. 8.3.00 DGD-824 GRADLE Added support for apk signature scheme configuration in SigningConfig elements of gradle buildscripts. 8.3.00 DGD-824 CORE Added new option -apksignatureschemes to control the use of apk signature schemes. 8.3.00 DGD-874 CORE Ensure deterministic results when enabling class encryption. 8.3.00 DGD-875 CORE Fixed potential NullPointerException at runtime when obfuscating attachBaseContext(Context) methods. 8.3.00 PGD-708 CORE Fixed possible JVM runtime verification error due to exception handlers in Kotlin initializers. 8.3.00 PGD-709 CORE Improved error messages for problems parsing wildcards. 8.3.00 DGD-722 CORE Fixed potential VerifyError in optimized exception handlers. 8.3.00 PGD-712 CORE Fixed NullPointerException triggered by module-info classes with requires without version. 8.3.00 DGD-353 GRADLE Added improved support for Espresso tests , see also sample advanced/Espresso . 8.3.00 DGD-727 GRADLE Added support for app bundles (requires Android gradle plugin 3.2.0+). 8.3.00 DGD-360 CORE Added code virtualization with new option -virtualizecode . 8.3.00 DGD-719 CORE Added optimization for usages of the Gson library for serializing and deserializing Json. Upgrade considerations : The additional plugin dexguard-partial which was only used as a work-around in some cases when using the Android gradle plugin 3.0.X has been removed. It is highly recommended to upgrade the Android gradle plugin to at least version 3.1.0 or later. Replaced system properties omit.signature.scheme.v2 and enable.signature.scheme.v3 with configuration option -apksignatureschemes . When using gradle to build an application, consider using the v2SignatureEnabled property from the Android Gradle DSL instead. Keep rules for Gson annotated classes have been moved from dexguard-common.pro to dexguard-gson.pro . The newly introduced Gson optimization should remove the need for explicitly keeping these classes. You should try including dexguard-gson.pro in your configuration if there is an issue with Gson after upgrading. The gradle plugin will now fail the build if it detects a build variant that is configured for DexGuard but contains incompatible settings (i.e. minifyEnabled=true , multiDexEnabled=true or shrinkResources=true ). When minifyEnabled is set to true and no default DexGuard configuration is provided, the default minification tool of the Android gradle plugin is used instead of DexGuard. By default, dx (tool from the standard Android build tools), will be used to convert class files to the dex format. In order to use the old, internal conversion mechanism, specify a system property conversion.tool=internal . Alternatively, d8 can be activated via conversion.tool=d8 (system properties can also be specified in the gradle.properties file via systemProp.conversion.tool=xxx ). Note: in case the WhiteboxCrypto addon is used, it is advised to switch to the internal conversion for performance reasons.","title":"Version 8.3 December 2018"},{"location":"releasenotes.html#version-82-may-2018","text":"File tamper detection. DexGuard already supports checking the integrity of entire apk files and react, at run-time. It can now additionally check the integrity of any specified files. Hardened native library loading. DexGuard could already encrypt native libraries. It now further hardens the decryption and loading on the device. Javascript encryption plugins. DexGuard could already encrypt Javascript code inside cross-platform apps, e.g. with Cordova. It now provides a plugin mechanism to apply sophisticated external Javascript obfuscators. Improved hook detection and SSL pinning. DexGuard evolves along with the latest technology. Automatic library configuration. DexGuard can now automatically generate ProGuard/DexGuard consumer rules for libraries, for the convenience of the developers who use them. Universal support for stream and date APIs. Recent versions of Java and Android contain new APIs to work with streams and dates. The predominance of older devices in the market practically limits their use. DexGuard now has built-in backporting support to use them across all versions of Android. Resource optimization. DexGuard now optimizes the size of resource configurations in applications. Dex optimization. Developers can now pass collected performance profiles to let DexGuard optimize the structure of dex files, to improve the startup times of applications on older devices. Automatic update checking. DexGuard now comes with an optional plugin to automatically check for available updates. Version Issue Module Explanation 8.2.25 CORE Fixed potentially wrong instructions when calling methods with modified access flags and using an alternative dex conversion tool. 8.2.25 DGD-1006 CORE Fixed issue in the nativeloader where the jvm reference cap could be reached when a large amount of native functions were resolved. 8.2.25 CORE Fixed automatic generation of consumer ProGuard rules in library projects in combination with -repackageclasses '' . 8.2.25 DGD-1017 RUNTIME Improved resilience of TamperDetector of the DexGuard runtime library. 8.2.25 DGD-1014 CORE Fixed verification errors when accessing resource strings inside constructors and using -encryptresources . 8.2.24 PGD-730 CORE Fixed infinite loop in optimization. 8.2.24 DGD-1011 CORE Consumer ProGuard rules are now always included in AAR's, even when -printlibraryconfiguration is specified; rules generated by DexGuard are still excluded from the AAR in that case. 8.2.24 DGD-1013 GRADLE Fixed issue in the gradle plugin where native libraries were included multiple times when multiple transform tasks are active. 8.2.24 DGD-1012 GRADLE Fixed issue in the gradle plugin where the incorrect class files were used when multiple transform tasks are active. 8.2.24 DGD-995 CORE Fixed invalid rule suggestions when using -addconfigurationdebugging in case of array types. 8.2.24 CORE Fixed Ionic sample (samples/advanced/Cordova/Ionic). 8.2.23 DGD-948 CORE Fixed unwanted renaming of explicitly kept class member names. 8.2.23 DGD-994 CORE Fixed issue with kept class members being potentially obfuscated / shrunk after class merging. 8.2.23 PGD-731 CORE Fixed incorrect error message about generics in wildcard expressions. 8.2.23 DGD-989 CORE Fixed -addconfigurationdebugging in case of null parameters for certain reflection methods. 8.2.23 DGD-984 CORE Fixed Android studio plugin to support the asapi modifier. 8.2.22 DGD-965 CORE Added support for navigation resources. 8.2.22 CORE Fixed backporting of default interface methods in case the method is called with Interface.super.defaultMethod() and the class does not directly implement the interface. 8.2.22 CORE Fixed SSLPinningWebViewClient and SSLPinningSystemWebViewClient when trying to request non-existent URL's. 8.2.21 CORE Fixed backporting of default interface methods in case of an extension interface. 8.2.21 DGD-971 CORE Added class SSLPinningSystemWebViewClient to the DexGuard runtime library to support SSL pinning in Cordova applications. 8.2.21 DGD-969 CORE Fixed generation of mapping files in combination with class encryption which lead to duplicate entries. 8.2.21 DGD-964 GRADLE Fixed issue where the gradle plugin would add compileOnly dependencies as injar instead of libraryjar. 8.2.21 DGD-959 GRADLE Fixed potential build error when setting minifyEnabled=true for some build variants and using the Android gradle plugin 3.2.0+. 8.2.21 DGD-960 GRADLE Fixed issue in the gradle plugin where java resources weren't picked up due to the previous change when using the Android gradle plugin version 2.3. 8.2.20 DGD-960 GRADLE Fixed issue in the gradle plugin where java resource files ended up in the root of the apk instead of in the right directory structure. 8.2.20 DGD-959 GRADLE Fixed crash in gradle when using the fabric gradle plugin version 1.26.0+ with Android gradle plugin 3.2.0+ and the DexGuard gradle plugin. 8.2.20 DGD-958 CORE Fixed native library name obfuscation in library projects. 8.2.20 DGD-955 CORE Kotlin Metadata annotations are now removed by default in Android library projects unless the kotlin.Metadata class is kept explicitly. 8.2.20 GRADLE Updated inputFilter in gradle plugin to prevent that kotlin source files end up in the output by accident. 8.2.20 CORE Fixed potential build error when using D8 as dex conversion mechanism due to aggressive optimization. 8.2.20 CORE Fixed processing of native renderscript libraries included in build tools 28.0.3. 8.2.19 CORE Added default configuration for files with .mov extension. 8.2.19 DGD-952 CORE Fixed generation of mapping files for methods whose code has been obfuscated and contain inlined methods. 8.2.19 DGD-950 CORE Fixed generation of mapping files in case of inlined methods avoiding duplicate entries. 8.2.17 DGD-927 CORE Updated filedictionary.txt to avoid characters which are no longer supported by the Google Play Store. 8.2.17 DGD-927 CORE Updated resource string encryption to avoid encoding characters in the resource table that are no longer supported by the Google Play Store. 8.2.17 GRADLE Fixed gradle plugin to include consumer Proguard files when building library projects with Android Gradle plugin 3.2.0+. 8.2.17 GRADLE Fixed build error in gradle plugin when providing an empty multiDexKeepProguard file. 8.2.17 DGD-943 CORE Fixed support for Android Studio 3.2 in the Android studio plugin. 8.2.17 PGD-720 CORE Fixed unboxed enum types being compared to null. 8.2.17 DGD-942 CORE Fixed shrinking step not always shrinking all unused metadata from AndroidManifest. 8.2.17 CORE Prevent insertion of opaque predicates in interface classes. 8.2.17 CORE Fixed potential NoClassDefFoundError when using -addconfigurationdebugging . 8.2.16 CORE Improved default configuration for Google Firebase Analytics library. 8.2.16 DGD-932 CORE Added support for encryption of asset files that are loaded using a variable name and with a access mode specified (access mode will always be ACCESS\\_STREAMING ). 8.2.16 DGD-934 CORE Fixed cordova samples using the EncryptedSystemWebViewClient from the DexGuard runtime library with Chrome v69.0.3497.86+. 8.2.16 CORE Fixed false-positive notes about unkept descriptor classes for injected classes. 8.2.16 CORE Added warning when using -dontshrink in combination with optimization which might result in verification errors at runtime. 8.2.16 DGD-928 CORE Fixed notes about unknown class java.lang.AbstractStringBuilder when using Android SDK 28+. 8.2.16 DGD-926 CORE Fixed incompatibility with older versions of the runtime certificate checker. 8.2.16 DGD-925 CORE Fixed incorrect cleanup of caches by packer on Android 8.0 and higher. 8.2.15 DGD-907 CORE Fixed conversion of checkcast instructions with large variable indices. 8.2.15 DGD-917 RUNTIME Hardened the use of FileChecker in application code; added documentation . 8.2.15 DGD-914 CORE Fixed FileChecker of the DexGuard runtime library when checking files that have been obfuscated. 8.2.15 DGD-822 CORE Fixed potential ClassFormatError due to inconsistent local variable type table in library projects. 8.2.15 RUNTIME Fixed option FAST in root detector of the DexGuard runtime library. 8.2.15 CORE Fixed issue where consumer proguard files weren't picked up when coming from modules in nested subdirectories. 8.2.15 DGD-904 CORE Fixed generation of consumer Proguard file in library projects which might contain invalid modifiers. 8.2.15 DGD-903 CORE Automatically disabled encryption for resource strings that cannot be encrypted (e.g. used as parameter to TextView#setText(int)). 8.2.15 DGD-900 CORE Fixed the DexGuard runtime library when enabling StrictMode in an application. 8.2.13 DGD-879 CORE Added additional debug information in case certain methods could not be converted to dex format. 8.2.13 DGD-888 ADDONS Fixed regression introduced in version 8.2.12 wrt to missing classes. 8.2.13 DGD-884 CORE Fixed obfuscation of unused JNI methods in native libraries. 8.2.13 DGD-853 RUNTIME Fixed false negatives wrt BlueStacks emulator for EmulatorDetector in the DexGuard runtime library. 8.2.13 DGD-718 RUNTIME Fixed false positives for EmulatorDetector in the DexGuard runtime library. 8.2.13 CORE Improved default configuration for Android Architecture Lifecycle library. 8.2.13 DGD-793 CORE Fixed printing notes during the build for generic keep rules not matching any program class. 8.2.12 DGD-852 GRADLE Updated gradle plugin to support gradle 4.9. 8.2.12 GRADLE Fixed gradle plugin to use correct paths for creating mapping files when using Android gradle plugin 2.3 together with splits. 8.2.12 DGD-849 GRADLE Improved support for transform tasks in the gradle plugin when using Android gradle plugin 2.3. 8.2.12 CORE Improved default configuration for the Android support library. 8.2.12 DGD-847 GRADLE The gradle plugin now correctly parses empty lines and comments in files passed to the multiDexKeepFile option. 8.2.12 DGD-848 CORE Fixed potential NullPointerException when using class encryption due to reflection of protected / static methods. 8.2.12 DGD-845 CORE Added default configuration for using AndroidX ( dexguard-androidx.pro ). 8.2.12 DGD-846 GRADLE Added support for the gradle build cache . 8.2.12 DGD-734 RUNTIME Improved performance of root detector, also adding FAST option. 8.2.11 GRADLE Improved Kotlin support in the gradle plugin. 8.2.11 DGD-842 CORE Fixed issue where multiDexKeepProguard files weren't read correctly. 8.2.11 DGD-843 CORE Fixed potential overflow problems due to class encryption when using an alternative dex conversion mechanism. 8.2.11 DGD-841 CORE Fixed incorrect switch-case statements with android.R resources when applying resource optimizations. 8.2.11 DGD-827 CORE Fixed retracing of obfuscated class/method names in some exception messages. 8.2.10 DGD-812 CORE Fixed issue where consumer proguard files weren't picked up when the product flavors in local project dependencies didn't match exactly. 8.2.10 DGD-821 CORE Fixed issue with duplicate resource table type names that breaks resource reflection. 8.2.10 CORE Fixed potential ClassCastException at build time when using -whyareyoukeeping . 8.2.10 DGD-490 CORE Fixed Android Studio plugin inspection to display tooltips for all flags. 8.2.10 DGD-724 RUNTIME Improved performance of HookDetector in the DexGuard runtime library. 8.2.09 CORE Apk Signature Scheme v3 is now disabled by default. You can enable it by setting the system property -Denable.signature.scheme.v3 . 8.2.08 DGD-820 CORE Resource file encryption is now automatically disabled for apps targeting Android P or higher (resource encryption is technically no longer possible on these devices). 8.2.08 DGD-819 CORE Resource table type names are now always preserved (fixes failing APK uploads in the Google Play Store). 8.2.08 DGD-802 CORE Fixed reflection of protected or static methods declared in super classes. 8.2.08 DGD-720 CORE Added support for Apk Signature Scheme v3 and certificate rotation, with a new option -certificatelineage . 8.2.07 DGD-811 CORE Generated consumer rules that are specific to DexGuard are now written to a separate file inside the AAR, 'dexguard.txt' (next to 'proguard.txt'). 8.2.07 DGD-814 CORE Updated samples to load dependent jars from maven instead of redistributing them. 8.2.07 DGD-807 CORE Fixed issue with resource optimizations when resource IDs are assigned to a long variable. 8.2.07 DGD-813 CORE Improved default configuration wrt generated R classes. 8.2.07 DGD-810 RUNTIME Added RootDetector NO_ROOT_MANAGERS flag to disable scanning for root manager apps. 8.2.07 DGD-489 CORE Added inspection descriptions for Android Studio plugin. 8.2.07 DGD-517 CORE Added inspections group display name for Android Studio plugin. 8.2.07 DGD-800 CORE Added support for ConstraintLayout (resources referenced via the 'constraint_referenced_ids' attribute are now automatically preserved). 8.2.07 DGD-789 CORE Fixed potential verification errors at runtime due to code obfuscation being applied to code attributes. 8.2.06 DGD-788 CORE Fixed Android Studio plugin compatibility with Android Studio v3.1+. 8.2.06 DGD-801 CORE Improved multidex processing including some default rules to ensure that classes matching -keep rules end up in the main dex file. 8.2.06 DGD-794 CORE Fixed injection of decryption code for non-encrypted resources when using -encryptresources . 8.2.05 DGD-765 CORE Completed fix for incorrect switch-case statements when applying resource optimizations. 8.2.05 CORE Fixed default settings of dexguard-transform plugin to be compatible with InstantRun. 8.2.05 GRADLE Updated the gradle plugin to support the Android gradle plugin version 3.2.0-beta01. 8.2.05 DGD-792 GRADLE Fixed issue in the gradle plugin where interactions with some versions of some plugins could cause missing Java resources in the resulting apk. 8.2.04 DGD-775 CORE Fixed keeping of onClick handlers defined for MenuItem elements in resource xml files 8.2.03 DGD-783 CORE Fixed apk processing when encountering methods whose code exceeds the 64k limit. 8.2.03 DGD-548 CORE Fixed option -adaptclassstrings if no additional filter is provided. 8.2.03 DGD-742 GRADLE Added support for the Android gradle plugin version 3.2.0-alpha18. 8.2.02 CORE Improved Instant App partitioning. 8.2.02 CORE Added build-time notes and suggestions on Instant App partitioning. 8.2.02 DGD-772 CORE Improved automatic handling of native Facebook libraries. 8.2.02 DGD-768 CORE Fixed NullPointerException during build when specifying -dontobfuscate and -printresourceencryption. 8.2.02 DGD-767 CORE Fixed Resources$NotFoundExceptions when applying resource optimizations. 8.2.02 DGD-765 CORE Fixed incorrect switch-case statements when applying resource optimizations (fixes support for the Android Data Binding framework). 8.2.02 DGD-697 GRADLE Updated the gradle plugin to exclude an additional libraryJar added in the Android gradle plugin version 3.1 that caused duplicate class warnings. 8.2.02 DGD-690 GRADLE Fixed warning caused by the gradle plugin due to using deprecated gradle features. 8.2.02 DGD-770 CORE Fixed processing of obfuscated native libraries. 8.2.02 DGD-769 GRADLE Fixed regression in the gradle plugin where local Java project dependencies caused a build error. 8.2.01 DGD-766 CORE Added support for encrypting strings that refer to obfuscated classes or class members (via -accessthroughreflection,encryptstrings). 8.2.00 DGD-192 CORE Introduced lib/dexguard-nativeloader.aar which if included into the project will provide a more secure way of loading encrypted native libraries. 8.2.00 CORE Added the possibility to encrypt the dependencies of encrypted native libraries without adding additional System.loadLibrary(string) calls. 8.2.00 DGD-672 CORE Updated hashing algorithm of SSLPinning and CertificateChecker from MD5 to SHA-256. 8.2.00 CORE Improved configuration for libGDX. 8.2.00 DGD-286 CORE Improved name obfuscation of encrypted native libraries. 8.2.00 DGD-592 CORE Added fallback mechanism to use D8 (version 1.1.11) from Android SDK for class conversion. 8.2.00 CORE The name of the 'extractNativeLibs' XML attribute in the AndroidManifest.xml is now kept by default (fixes the setting being ignored at runtime). 8.2.00 DGD-138 CORE Disabled optimization code/allocation/variable in the default library release configuration. 8.2.00 DGD-662 CORE Native library dependencies referenced only from other native libraries are now automatically kept. 8.2.00 DGD-541 CORE Removed class com.guardsquare.dexguard.runtime.net.SimpleSSLPinningWebViewClient from the DexGuard runtime library. 8.2.00 DGD-509 CORE Added new option -performanceprofile to optimize app startup performance, based on an hprof file. 8.2.00 DGD-352 CORE Added new option -printlibraryconfiguration for generating an output configuration for library projects requiring additional processing. 8.2.00 DGD-612 GRADLE Added gradle plugin dexguard-transform which provides various features also in non-DexGuard enabled builds (e.g. with active InstantRun). 8.2.00 DGD-197 GRADLE Added gradle plugin dexguard-versioncheck which checks if a more recent DexGuard version is available. 8.2.00 DGD-202 CORE Added support for Javascript obfuscation plugins. Included sample for Cordova and React Native under samples/advanced/Javascript . 8.2.00 DGD-137 CORE Processed native libraries are now stripped more aggressively. 8.2.00 DGD-688 CORE Added support for backporting the Java 8 time API using the threetenbp library (see also sample basic/TimeAPI). 8.2.00 DGD-165 CORE Added support for backporting the Java 8 stream API using the streamsupport library (see also sample basic/StreamSupport). 8.2.00 DGD-579 RUNTIME Improved hook detection for stripped libraries. 8.2.00 DGD-617 RUNTIME Improved hook detection to more reliably detect various known hooking frameworks. 8.2.00 DGD-281 CORE Added section explaining the various default configurations to the manual. 8.2.00 DGD-385 RUNTIME Improved SSL pinning support of the DexGuard runtime library (added hardened class SSLPinner, updated samples). 8.2.00 DGD-572 CORE Added sample 'advanced/Crashlytics' to use the Crashlytics library for Java and native crash reporting. 8.2.00 DGD-523 CORE Updated sample 'advanced/IOCipher' to use latest IOCipher release 0.4. 8.2.00 DGD-395 CORE Improved default configuration for the Facebook Conceal library v2.0+. 8.2.00 DGD-574 CORE Updated sample 'advanced/Conceal' to use latest conceal release v2.0.2. 8.2.00 DGD-569 CORE Updated dx tool as fallback mechanism for class conversion to version 27.0.3. 8.2.00 DGD-387 CORE Added new option -keepcode for keeping code attributes. 8.2.00 DGD-102 RUNTIME Added file-level tamper detection. Upgrade considerations : Additional file lib/dexguard-java8.jar has been removed as it was only needed as a workaround for Android gradle plugin versions [2.1.0, 2.2.0-alpha5]. You should remove the following line classpath ':dexguard-java8:' from your build.gradle file and update to a more recent version of the Android gradle plugin. Class com.guardsquare.dexguard.runtime.net.SimpleSSLPinningWebViewClient has been removed from the DexGuard runtime library, and should be replaced by com.guardsquare.dexguard.runtime.net.SSLPinningWebViewClient . Certificate hashes for SSL pinning and the CertificateChecker now need to be generated with SHA-256. MD5 certificate hashes are no longer valid for SSL pinning and deprecated for certificate checking. Added the lib/dexguard-nativeloader.aar which provides a more secure way to load encrypted native libraries if it is included as a dependency into your project. Due to changes in the internals of the Android OS, resource encryption is no longer supported as of Android P. Resource encryption will therefore automatically be disabled as of DexGuard 8.2.08 if the maxSdkVersion attribute is not present in the Android Manifest, or if it is set to 28 or higher.","title":"Version 8.2 May 2018"},{"location":"releasenotes.html#version-81-dec-2017","text":"Code packing. DexGuard could already encrypt specified sensitive classes. It can now also efficiently encrypt all combined bytecode as an additional layer of protection. Android Studio plugin. The DexGuard plugin for Android Studio provides syntax highlighting, auto-completion, and highlighting of potentially suboptimal or erroneous configuration. Hook detection. The DexGuard runtime SDK now also provides hook detection, for frameworks like Xposed and Substrate. Instant Instant Apps. DexGuard can now automatically create Instant Apps from traditional installed app projects, without requiring you to manually refactor your code or restructure your projects. Reduce the conversion time from weeks to minutes! Version Issue Module Explanation 8.1.23 DGD-796 CORE Reverted accidental fix for DGD-687 when processing apk files. 8.1.23 RUNTIME Fixed potential crashes when using the hook detection. 8.1.23 GRADLE Fixed regression in the gradle plugin where consumer proguard files in recursive local module dependencies weren't picked up. 8.1.22 DGD-791 SK-ADDON Fixed potential IllegalStateException when detaching the secure keyboard from a layout. 8.1.22 CORE Fixed potential IllegalAccessError when backporting static interface methods. 8.1.21 DGD-787 CORE Fixed issue where local file dependencies cause an ArrayIndexOutOfBoundsException when gathering consumer Proguard files. 8.1.20 DGD-782 GRADLE Fixed issue in the gradle plugin where trying to collect the consumer proguard files of dependencies also ended up downloading the sources of these dependencies. 8.1.20 DGD-786 GRADLE Fixed issue in the gradle plugin where the classes of submodule projects ended up in the libraryJars when building on Windows, causing them to be missing at runtime. 8.1.20 SK-ADDON Fixed processing of the SecureKeyboard addon after change DGD-744. 8.1.20 DGD-777 GRADLE Made the gradle plugin more robust with regards to collecting consumer Proguard rules. 8.1.20 DGD-713 GRADLE Fixed issue in the gradle plugin where dependencies declared as compileOnly were picked up incorrectly and ended up in the apk. 8.1.19 CORE Added default configuration for the IBM MobileFirst library. 8.1.19 DGD-760 CORE Improved default configuration for the Firebase libraries. 8.1.19 DGD-753 GRADLE Fixed issue in the gradle plugin where resources and the Android manifest weren't picked up when using multiple flavor dimensions in combination with splits. 8.1.19 DGD-708 RUNTIME Improved performance of hook detection. 8.1.19 DGD-752 GRADLE Fixed regression in the gradle plugin where the mapping file wasn't set properly when using gradle 4.1+. 8.1.18 DGD-751 WB-ADDON Improved default obfuscation of the whitebox cryptography code. 8.1.17 DGD-744 CORE Ensured that classes of the DexGuard runtime library can be properly obfuscated, regardless of user-defined rules. 8.1.17 DGD-747 GRADLE Fixed issue in the gradle plugin where consumer proguard files from transient dependencies might not be picked up. 8.1.17 DGD-730 CORE Fixed native library encryption on Android P when targetSdkVersion > 24 . 8.1.17 DGD-725 CORE Fixed potential IllegalArgumentException when simplifying null enum values. 8.1.17 PGD-701 CORE Fixed potential VerifyError in the presence of branches to instruction offset 0. 8.1.16 DGD-698 GRADLE Fixed regression in the gradle plugin where when including a local java project as a dependency an exception was thrown at build time claiming the jar could not be found. 8.1.16 DGD-687 CORE Fixed processing of apk files that perform exception handling involving class constants. 8.1.16 CORE Fixed multidex partitioning if more than 10 dex files are needed. 8.1.16 DGD-684 GRADLE Fixed regression in the gradle plugin where apk post-processing was broken. 8.1.16 DGD-681 CORE Fixed backporting of lambda functions using the alternative factory method. 8.1.15 DGD-674 CORE Fixed obfuscation of custom classnames in some resource XML files (related to PreferenceScreen configurations). 8.1.15 PGD-699 CORE Fixed obfuscation of closures that implement multiple interfaces. 8.1.15 DGD-676 GRADLE Fixed issue with the gradle plugin where resources in dependency jar files were not present in the resulting apk when using the Android gradle plugin version 3.1. 8.1.15 DGD-673 CORE Invalid use of generics in a class specification now results in a ParseException. 8.1.15 DGD-668 GRADLE Fixed regression where a warning appeared about duplicate AndroidManifest.xml files when using the Android gradle plugin version 2.3 or lower. 8.1.15 PGD-694 CORE Fixed classes prefix when writing output to directories. 8.1.14 DGD-670 CORE Duplicate resource files are now processed in a pick-first logic. 8.1.13 DGD-640 GRADLE Fixed issue when using DexGuard with the Android gradle plugin v3.1 on a library project where some files were misplaced in the aar. 8.1.12 PGD-186 CORE Added support for Java 10. 8.1.12 DGD-637 GRADLE Updated the gradle plugin to fully support the Android gradle plugin version 3.1. 8.1.12 PGD-698 CORE Fixed possible NullPointerException when parsing configuration. 8.1.12 PGD-693 CORE Fixed obfuscation of closures for functional interfaces with default methods. 8.1.12 CORE Improved default configuration for the Retrofit/RetroFit2 libraries. 8.1.12 DGD-618 CORE Fixed NullPointerException during build if -obfuscatecode was used with a field specification. 8.1.12 PGD-655 CORE Fixed access from static methods to protected methods in superclasses. 8.1.11 DGD-616 CORE Fixed potential 'VerifyError' at runtime when applying code obfuscation to methods with boolean variables. 8.1.11 DGD-609 CORE Now silently ignoring type annotations (unsupported by the Dalvik VM) instead of throwing an UnsupportedOperationException. 8.1.11 DGD-611 GRADLE The gradle plugin now throws an exception when building variants without DexGuard while using the Android gradle plugin v3.0 and Java8 instead of issuing a warning and creating an invalid apk. 8.1.11 DGD-607 CORE Fixed encryption of native libraries that are loaded via System.loadLibrary(String) with a non-constant String argument. 8.1.11 DGD-606 GRADLE Fixed gradle plugin to automatically output encryption mapping information also in library projects. 8.1.11 DGD-605 CORE Added troubleshooting entry for publishing Android applications to AirWatch . 8.1.11 DGD-604 CORE Fixed use of 'com.guardsquare.dexguard.runtime.net.SSLPinningWebViewClient' on older Android devices (< 5.0). 8.1.11 DGD-604 CORE Specify minSdkVersion of '11' for DexGuard runtime library (= Android 3.0 Honeycomb). 8.1.11 DGD-600 SK-ADDON Fixed SecureKeyboardVisibilityListener to return correct visibility on custom 'onBackPressed' event. 8.1.11 CORE Improved default configuration for the Glide library. 8.1.11 DGD-554 SK-ADDON Fixed crash for targetSdk 26 or higher caused by depecrated window types. 8.1.11 DGD-596 CORE Improved default configuration for the CrossWalk/XWalk library. 8.1.11 DGD-597 CORE Improved default configuration for classes extending 'android.view.ActionProvider'. 8.1.10 DGD-595 GRADLE Fixed issue with the gradle plugin where class input wasn't collected when a transform task with multiple class inputs was used. 8.1.10 DGD-594 CORE Added classname filter for mappings loaded via rule '-applymapping' . 8.1.10 DGD-561 CORE Prevent inlining of methods that assign final fields. 8.1.10 DGD-466 CORE Fixed conversion of invocation instructions using range parameters. 8.1.10 DGD-567 CORE Fixed enum unboxing for already obfuscated code. 8.1.09 DGD-588 RUNTIME Fixed false positives for hook detection on armeabi architecture. 8.1.09 DGD-587 CORE Fixed potential NullPointerException at runtime when encrypting strings in classes that extend 'android.content.Context'. 8.1.09 DGD-584 CORE Fixed trimming of strings with control characters in certificates. 8.1.08 DGD-568 GRADLE Fixed issue with the gradle plugin where transformed dependencies were included twice in the DexGuard input. 8.1.08 DGD-577 CORE Fixed potential ClassCastException when encrypting Strings that refer to program classes or program class members. 8.1.08 DGD-480 WB-ADDON Added support for whitebox cryptography in library projects. 8.1.08 DGD-409 WB-ADDON Fixed Android boot loop when using whitebox cryptography on old versions (< 5.0) of Android. 8.1.08 PGD-688 CORE Fixed method type annotations triggering UnsupportedOperationException in optimization pass. 8.1.08 DGD-575 CORE Fixed samples 'basic/AssetEncryptionLibrary' and 'basic/NativeLibraryInLibraryProject'. 8.1.08 DGD-576 CORE Fixed sample 'basic/InstantApp'. 8.1.08 DGD-570 CORE Fixed class conversion using the dx tool in combination with class encryption. 8.1.08 DGD-533 GRADLE Fixed disabling DexGuard for some build types when using Java8 in gradle plugin (requires Android gradle plugin v3.1.0-beta3+). 8.1.08 DGD-154 CORE Added warning when encrypting outer classes without encrypting their inner classes. 8.1.08 DGD-565 CORE Fixed reporting of reason why a class has been kept when using option -whyareyoukeeping . 8.1.08 DGD-564 CORE Fixed backporting of method references to private constructors. 8.1.07 DGD-481 CORE Fixed optimization of instructions potentially causing unexpected error while processing. 8.1.07 DGD-562 CORE Fixed conversion of invalid invoke instructions. 8.1.07 CORE Fixed preverification support for Android library projects. 8.1.07 DGD-84 CORE Fixed parsing of class specifications that contain comments in their member specification. 8.1.07 DGD-556 CORE Fixed regression where consumerProguardFiles weren't picked up from local library project dependencies. 8.1.07 DGD-559 GRADLE Fixed issue with the gradle plugin when using an older version of the Android Gradle plugin together with local file dependencies. 8.1.07 DGD-558 CORE Adding preverification information to Java classes in libraries. 8.1.06 CORE Improved default configuration for library projects that use the DexGuard runtime library. 8.1.06 PGD-662 CORE Fixed obfuscation causing clashing private and default method names. 8.1.06 PGD-654 CORE Fixed processing of MethodParameters attributes with nameless parameters. 8.1.06 DGD-552 CORE Fixed calculation of statistics for generalized field accesses during optimization. 8.1.06 RUNTIME Improved root detection. 8.1.06 DGD-551 RUNTIME Fixed false positives in hook detection. 8.1.06 DGD-160 CORE Added troubleshooting entry for using -accessthroughreflection . 8.1.06 DGD-547 CORE Fixed packaging of local file dependencies in AAR's. 8.1.06 PGD-684 CORE Fixed obfuscation of extensions of functional interfaces that are implemented with closures. 8.1.06 PGD-681 CORE Fixed potential IllegalArgumentException in simplification of tail recursion. 8.1.06 DGD-523 CORE Updated SQLCipher sample to use latest sqlcipher library for android. 8.1.06 DGD-546 CORE Fixed regression potentially causing IllegalStateException while backporting code. 8.1.06 GRADLE Added warning when the minifyEnabled true , shrinkResources true and/or multiDexEnabled true options are used in the build.gradle file. 8.1.06 DGD-544 CORE Fixed automatic handling of reflection with known names on inaccessible fields and methods. 8.1.05 DGD-531 CORE Fixed possible unexpected error (IllegalStateException: Variable too large for instruction new-array) in conversion to Dalvik code. 8.1.05 DGD-516 CORE Fixed samples basic/SSLPinning and basic/SSLPinningWebView. 8.1.05 DGD-476 CORE Fixed issue with asset encryption causing ArrayIndexOutOfBoundsException at build time. 8.1.05 DGD-540 CORE Fixed issue where building a variant with a dependency on a different variant of another project resulted in an apk without a classes.dex. 8.1.05 DGD-524 CORE Fixed sample advanced/Kotlin. 8.1.04 DGD-539 CORE Fixed regression where certain resources weren't detected when product flavors where used resulting in a NullPointerException. 8.1.04 CORE Fixed issue with code obfuscation on older Android devices which might result in crashes of the JIT compiler. 8.1.02 DGD-538 GRADLE Fixed issue with the gradle plugin where the same AndroidManifest.xml was used for all outputs when using the splits option in gradle. 8.1.02 DGD-537 CORE Fixed issue were font families defined in xml files were obfuscated incorrectly. 8.1.02 DGD-535 CORE Fixed conversion to Dalvik bytecode potentially causing VerifyError for allocated registers. 8.1.01 DGD-534 CORE Fixed code obfuscation potentially triggering infinite loop at build time. 8.1.01 CORE Improved vertical class merging. 8.1.01 DGD-530 CORE Fixed memory leak writing compressed zip entries. 8.1.00 CORE Added Android Studio plugin 8.1.00 DGD-394 CORE The names of classes that are passed as arguments to the android.content.ComponentName class are now kept. 8.1.00 DGD-181 CORE Added new encryptstrings modifier for the -accessthroughreflection option, to encrypt all strings that are created for the reflection. 8.1.00 DGD-410 RUNTIME Added hook detection to runtime SDK. 8.1.00 DGD-290 CORE Added new option -pack for packing Android apps. 8.1.00 DGD-477 CORE Added support for the font resource type. 8.1.00 DGD-411 CORE Added new option -instantappfeature for automatically creating Instant Apps. 8.1.00 CORE Added new option -if to allow conditional rules. 8.1.00 CORE Added support for wildcard references in options. 8.1.00 GRADLE Added support for multiDexKeepFile option in gradle. 8.1.00 GRADLE Added support for multiDexKeepProguard option in gradle. 8.1.00 CORE Added support for allowmultidex option in keep rules. 8.1.00 SK-ADDON Added a listener for the visibility of the secure keyboard. 8.1.00 SK-ADDON Added customization options for the secure keyboard. 8.1.00 DGD-473 CORE Fixed possible NullPointerException when backporting closures. Upgrade considerations : The options -printassetmapping , -printresourcemapping , and -printnativelibrarymapping have been combined into a new option -printresourcefilenamemapping , which writes out a single mapping file for all resource file names. Runtime method RootDetector.isDeviceRooted now requires an additional Context argument.","title":"Version 8.1 Dec 2017"},{"location":"releasenotes.html#version-80-may-2017","text":"Annotation-based configuration. You can now specify configuration directly in the source code using annotations. These configurations are complementary to the existing rules in configuration files such as dexguard-project.txt. Encryption of resource strings and metadata strings. New configuration options support the encryption of resource strings and meta-data values. Improved support for asset and native library encryption. DexGuard can now encrypt asset files and native libraries that are loaded via a variable string, dependent native libraries and native libraries loaded via JNA. Improved statistics and logging. New settings have been added to display detailed statistics on package level as well as details about encrypted content (strings, classes,...) Version Issue Module Explanation 8.0.24 DGD-536 CORE Fixed regression where the AndroidManifest.xml was incomplete for library projects. 8.0.24 DGD-529 CORE Fixed regression where the splits option wouldn't generate different apks. 8.0.23 DGD-527 GRADLE Fixed problem with Kotlin kapt plugin where the gradle plugin would throw an exception. 8.0.23 DGD-526 GRADLE Fixed regression with Android gradle plugin v2.1 and older. 8.0.22 DGD-423 CORE Extended handling of strings whose stored lengths have overflowed in resource files. 8.0.21 DGD-514 CORE Added system properties 'encode.resourcexml.utf16' and 'encode.resourcetable.utf16' as a workaround for system crashes on selected devices. 8.0.20 DGD-511 GRADLE Fixed issue with the gradle plugin where only 1 apk generated with the splits option had a classes.dex file. 8.0.20 DGD-508 CORE Fixed regression, workaround for bug in Android 4.1 and older segfaulting on null parameter annotation sets. 8.0.20 DGD-505 CORE Fixed incorrect generalization of fields with identical names in the class hierarchy. 8.0.19 DGD-486 CORE Fixed potential VerifyError when generalizing classes of method invocations that are not available on all platform versions. 8.0.18 DGD-484 CORE Fixed issue where debug dex tasks would crash due to method ID overflow even though Dexguard handles multidexing. 8.0.18 DGD-488 GRADLE Fixed issue where the AndroidManifest.xml wasn't included in Android libraries when using Android gradle plugin v3.0. 8.0.18 DGD-487 GRADLE Updated the gradle plugin to support the Android gradle plugin v3.1.0-alpha02. 8.0.18 DGD-485 WB-ADDON Fixed NullPointerException when building whitebox cryptography apps in debug mode. 8.0.18 DGD-479 CORE Whitebox encryption options are now included when printing configurations. 8.0.17 GRADLE Tuned the gradle plugin Java8 handling. 8.0.16 DGD-475 CORE Fixed class encryption performance regression. Code obfuscation is now disabled for encrypted classes by default. You can still enable it using -obfuscatecode. 8.0.15 CORE Improved class encryption performance. 8.0.15 GRADLE Added support for gradle version 4.3-rc-1. 8.0.14 DGD-469 CORE Added default keep rules for the Android animation resources support library. 8.0.14 CORE Fixed regression where dex files were missing from build output of variants not using Dexguard. 8.0.12 DGD-468 GRADLE Fixed kotlin classes not being included in resulting apk when using the DexGuard gradle plugin and the Android gradle plugin version 3.0. 8.0.12 DGD-464 GRADLE Different splits now generate different mapping files in the gradle plugin. 8.0.12 DGD-467 GRADLE Fixed setting of mapping file in gradle plugin. 8.0.11 DGD-463 CORE Fixed crash when using Java8 features in debug builds. 8.0.11 DGD-461 GRADLE Fixed apk processing feature in gradle plugin. 8.0.11 DGD-460 CORE Fixed compatibility issue with Crashlytics. 8.0.11 DGD-453 CORE Added class whitelist to the member specializer. 8.0.11 DGD-465 RUNTIME Fixed runtime exception in root detection on Galaxy Tab3 with Android 4.0.3. 8.0.11 DGD-462 CORE Fixed incorrect array optimization when processing already obfuscated code. 8.0.11 DGD-459 CORE Fixed conversion of conditional jumps. 8.0.10 DGD-412 GRADLE Updated gradle plugin for compatibility with Android gradle plugin versions 2.4 and 3.0. 8.0.10 DGD-454 CORE Injected code no longer relies on the Android Crypto provider. 8.0.10 DGD-451 CORE Fixed jar signing with certificates with distinguished names with non-ASCII characters. 8.0.09 DGD-449 CORE Fixed jar signing with certificates with distinguished names with quoted attribute values. 8.0.09 DGD-448 CORE Fixed jar signing with certificates that are not self-signed. 8.0.09 DGD-447 CORE Fixed potential IOException/IndexOutOfBoundsException when processing native libraries. 8.0.08 DGD-446 WB-ADDON Fixed configuration parsing error when using the AES whitebox encryption algorithm in CBC mode. 8.0.08 DGD-442 CORE Fixed potential build error while performing code obfuscation. 8.0.08 DGD-445 CORE Fixed IllegalAccessError when loading encrypted resources on Android 7.0. 8.0.08 DGD-443 CORE Fixed filtering of native libraries from jar files to split apk files. 8.0.07 DGD-441 CORE Reduced runtime memory usage of resource decryption. 8.0.06 DGD-438 CORE Updated dictionaries to avoid characters causing ANR's on some Samsung devices. 8.0.05 DGD-435 CORE Fixed unclosed inputstreams of non-encrypted resource XML's. 8.0.05 DGD-433 CORE Added support for adaptive icons in Android O. 8.0.05 DGD-429 CORE Fixed build error when adding configuration debugging on classes that load resources. 8.0.05 DGD-428 CORE Now ignoring classes in the default package when adapting resource filenames. 8.0.05 SK-ADDON Added an API method to detach the keyboard. 8.0.05 DGD-427 SK-ADDON Fixed issues with secure keyboard being attached to an AlertDialog. 8.0.05 DGD-426 SK-ADDON Fixed secure keyboard overriding the edit text's gravity. 8.0.05 DGD-425 SK-ADDON Added an API method to attach listeners in addition to the secure keyboard's listeners. 8.0.05 DGD-340 SK-ADDON Added an API method to get the height of the secure keyboard. 8.0.05 CORE Updated configuration for the Glide library. 8.0.04 DGD-423 CORE Now handling resource strings whose stored lengths have overflowed in the resource files. 8.0.04 DGD-422 CORE Fixed inlining of boolean metadata into code. 8.0.03 DGD-421 CORE Fixed potential IllegalStateException (variable too large) during conversion to Dalvik bytecode. 8.0.02 DGD-420 CORE Fixed potential ClassCastException in optimization step. 8.0.02 DGD-419 CORE Fixed potential VerifyError when applying encryption in classes with multiple constructors. 8.0.01 CORE Improved default configuration for the Kotlin runtime. 8.0.01 DGD-416 CORE Fixed apk signing when certificate specifies optional email address. 8.0.01 CORE Extended default regular expression of ReTrace. 8.0.00 DGD-405 CORE Fixed potential ArrayIndexOutOfBoundsException in the optimization step. 8.0.00 GRADLE Updated sample Gradle build files to recent Android tools. 8.0.00 DGD-404 CORE Added support for null chunks in resource tables. 8.0.00 DGD-403 CORE Only merging classes with equal class versions. 8.0.00 DGD-402 CORE Fixed potentially incorrect stack sizes when enabling configuration debugging. 8.0.00 DGD-401 CORE Fixed class unwrapping optimization for unusual instantiation code. 8.0.00 DGD-400 CORE Fixed parsing of unsorted styles in string pools. 8.0.00 DGD-398 CORE Improved storage of strings in resource files. 8.0.00 CORE String references are now supported as metadata key names in the Android Manifest. 8.0.00 DGD-294 CORE Added support to print extended statistics with option -printstatistics . 8.0.00 DGD-393 CORE Updated obfuscation dictionaries to avoid characters confusing the Android runtime on some devices. 8.0.00 CORE Improved default configuration for Android support libraries. 8.0.00 DGD-320 CORE Unused string constants matched by an -encryptstrings rule are not encrypted anymore. 8.0.00 DGD-320 CORE The -keep modifier includecode now also prevents string encryption from being applied on matching methods. 8.0.00 DGD-287 CORE Added support to print native library encryption details with option -printnativelibraryencryption . 8.0.00 DGD-287 CORE Added support to print resource encryption details with option -printresourceencryption . 8.0.00 DGD-287 CORE Added support to print asset encryption details with option -printassetencryption . 8.0.00 DGD-287 CORE Added support to print string encryption details with option -printstringencryption . 8.0.00 DGD-287 CORE Added support to print class encryption details with option -printclassencryption . 8.0.00 DGD-256 CORE Improved protection of encrypted classes. 8.0.00 CORE Updated Realm sample to use realm v2.3.2. 8.0.00 DGD-380 GRADLE The Gradle plugin will now automatically generate mapping files in Android Library projects. 8.0.00 DGD-382 GRADLE Improve build time for projects with many product flavors in Gradle plugin. 8.0.00 DGD-353 GRADLE Added support to backport Java 8 language features for instrumentation tests in Gradle plugin. 8.0.00 CORE Unparsed data at the end of resource table chunks are now preserved during processing. 8.0.00 DGD-374 CORE Added support for the resource table library (0x203) chunk type. 8.0.00 DGD-378 CORE Fixed utf8 encoding of resource strings with length >= 128. 8.0.00 DGD-179 CORE Added annotations for -obfuscatecode rules. 8.0.00 DGD-320 CORE The -keep modifier includecode now also prevents code obfuscation and reflection from being applied on matching methods. 8.0.00 DGD-363 CORE Added support to encrypt also dependent native libraries (see SQLCipher sample) which did not work on Android versions < 6.0. 8.0.00 DGD-341 CORE Reduced size of resource table (resources.arsc) in Android application projects. 8.0.00 CORE Added optimizations code/simplification/object for primitive boxing and other object instantiation. 8.0.00 DGD-359 CORE Updated default configuration to keep EnclosingMethod attributes by default. 8.0.00 DGD-357 CORE Fixed potential build error when obfuscating the JNI interface of native libraries (Error string: New string section exceeds the length of the original). 8.0.00 DGD-239 CORE Added sample advanced/JNA. 8.0.00 DGD-239 CORE Added support to obfuscate the file names of native libraries accessed via JNA (using Native.loadLibrary(\"name\", Class)). 8.0.00 DGD-239 CORE Improved default configuration for using the JNA library. 8.0.00 DGD-289 CORE Reduced injected code for encrypted strings that occur more than once in a method. 8.0.00 DGD-354 CORE Improved processing speed of classes containing large arrays (e.g. classes with encrypted strings). 8.0.00 DGD-253 CORE Reduced visibility of encrypted class loading. 8.0.00 DGD-322 CORE Fixed potential problem with conversion of primitive arrays when processing apk files. 8.0.00 DGD-58 CORE Added support for fall-back license files dexguard-license2.txt , etc. 8.0.00 DGD-336 CORE Fixed potential warnings about unnatural loops when processing obfuscated dex files with dex2oat . 8.0.00 RUNTIME Fixed false-positives for root detection. 8.0.00 DGD-325 GRADLE Added instructions how to upload the DexGuard Gradle plugin to a Maven repository. 8.0.00 DGD-273 CORE Random variation is now affected by additional attributes in the Android manifest (packageName, versionCode, versionName). 8.0.00 CORE Fixed null handling in string peephole optimization. 8.0.00 CORE Added sample for the NewRelic analytics library. 8.0.00 DGD-323 CORE Added support to parse url parameters provided to -include and -xxxdictionary rules. 8.0.00 DGD-321 CORE Added support for extractNativeLibs attribute in AndroidManifest.xml. 8.0.00 DGD-291 CORE Improved code obfuscation for simple methods. 8.0.00 DGD-282 GRADLE Fixed detection of configuration changes for incremental builds in Gradle plugin. 8.0.00 DGD-300 CORE Added default configuration for the Facebook Fresco library. 8.0.00 DGD-303 CORE Native libraries whose native methods are being kept are kept as well. 8.0.00 CORE Added default configuration for the OkHttp library. 8.0.00 CORE Added default configuration for the Otto library. 8.0.00 DGD-313 CORE Added optimization class/merging/wrapper to merge wrapper classes with their wrapped classes. 8.0.00 DGD-198 CORE Added optimizations field/generalization/class and method/generalization/class to generalize the classes in field accesses and member invocations. 8.0.00 DGD-285 CORE Added support for encryption of native libraries that are loaded via System.loadLibrary using a variable string argument. 8.0.00 DGD-254 CORE Added support for encryption of assets that are loaded via the AssetManager using a variable string argument. 8.0.00 DGD-193 CORE Added new option -encryptresources for encrypting resource strings. 8.0.00 DGD-312 CORE Added new option -encryptmetadata for encrypting Android Manifest metadata. 8.0.00 DGD-309 CORE Avoiding incompatible class version numbers when merging classes. 8.0.00 DGD-308 CORE Improved shrinking of interface declarations. 8.0.00 DGD-296 GRADLE Changed consumerRuleFilter in Gradle plugin to filter on artifacts (Maven coordinates) rather than file names. 8.0.00 DGD-211 GRADLE Added additional tasks in Gradle plugin to list/collect all consumer ProGuard rules. 8.0.00 CORE Added verbose statistics for inlined meta-data elements. 8.0.00 DGD-179 CORE Added sample basic/Annotations. 8.0.00 DGD-179 CORE Updated configuration to support ProGuard/DexGuard annotations. 8.0.00 DGD-179 CORE Added lib/dexguard-annotations.jar, containing annotations for -keep , -encryptclasses and -encryptstrings rules. 8.0.00 DGD-179 CORE Improved support for annotation-based configurations (annotation types don't have to be kept explicitly anymore). 8.0.00 DGD-302 CORE No longer using internal com.sun API to sign apk files. 8.0.00 DGD-229 CORE Added support for APK signature scheme v2. 8.0.00 DGD-260 CORE Changed loading of default configurations in the Ant plugin to be consistent with other plugins (see upgrade consideration below). 8.0.00 DGD-278 CORE Added fallback mechanism to use dx tool from Android SDK for class conversion. 8.0.00 DGD-111 CORE Added support to include consumer Proguard files from AAR dependencies in Maven plugin. 8.0.00 DGD-111 CORE Updated Maven plugin for Android Maven plugin version 4.4.3. 8.0.00 DGD-183 CORE Added support for custom drawable classes in XML resources. Upgrade considerations : The contents of the folder extras/annotations have migrated to the following locations: lib/annotations.jar has moved to lib/dexguard-annotations.jar lib/annotations.pro has been integrated into the default configuration examples has been replaced by samples/basic/Annotations Default configuration and dictionary files have been removed from lib folder in the DexGuard distribution. The Ant plugin will now load default configurations directly from dexguard.jar similar to other plugins (Gradle, Maven, Eclipse). The file ant/custom_rules.xml has been updated and needs to be copied to the main directory of your Android project. For stand-alone processing, default configurations should be included using their resource path, e.g.: -include /lib/dexguard-release.pro . The consumerRuleFilter extension of the Gradle Plugin has been changed to filter on Maven coordinates rather than on file names (necessary due to changes in the Android gradle plugin 2.3.0). The DexGuard Maven plugin pom descriptor file has been renamed from lib/pom.xml to lib/maven-plugin.xml . -encryptassetfiles [file_filter] now encrypts all assets that match the given file filter - it is no longer limited to files for which a matching AssetManager.openAsset(fileName) invocation is found in the application. These file filters may need to be refined, to prevent assets which are read via other mechanisms from being encrypted. -encryptnativelibraries [file_filter] now encrypts all native libraries that match the given file filter - it is no longer limited to libraries for which a matching System.loadLibrary(libraryName) invocation is found in the processed code. These file filters may need to be refined, to prevent libraries which are read via other mechanisms from being encrypted.","title":"Version 8.0 May 2017"},{"location":"releasenotes.html#version-73-oct-2016","text":"Version Issue Module Explanation 7.3.25 DGD-407 CORE Fixed potential IllegalArgumentException due to overflow when writing out library code. 7.3.24 DGD-406 CORE Fixed instrumentation for configuration debugging for System.load. 7.3.23 PGD-641 CORE Fixed possible NullPointerException due to optimized enum types. 7.3.21 DGD-393 CORE Removed some characters from obfuscation dictionaries that resulted in problems on some devices. 7.3.21 DGD-392 CORE Fixed simplification of enum types in invokedynamic calls. 7.3.21 DGD-391 CORE Fixed conversion of method references to constructors with parameters. 7.3.21 CORE Added system property to specify an alternative location to use for native library encryption (useful for system/platform applications). 7.3.20 DGD-388 CORE Fixed processing of NOBITS sections in ELF files. 7.3.19 CORE Fixed unwrapping of exceptions for reflected calls. 7.3.19 DGD-322 CORE Fixed potential problem with conversion of primitive arrays when processing apk files. 7.3.19 DGD-376 GRADLE Fixed problem with latest Android Gradle plugin (v2.3.0) in Android library projects with setting publishNonDefault=false . 7.3.18 CORE Encrypted class data can now be embedded inside classes with a build time flag. 7.3.18 CORE Improved performance of encryption plugins. 7.3.18 DGD-336 CORE Fixed potential warnings about unnatural loops when processing obfuscated dex files with dex2oat . 7.3.18 DGD-368 CORE Fixed possible invalid code when simplifying enum types that are stored in arrays. 7.3.18 CORE DexGuard now terminates when an error occurs during parallel optimization. 7.3.17 GRADLE Disabled execution of DexGuard for instrumented test variants in Gradle plugin. 7.3.17 CORE Updated default configuration to fix broken icons in some stores and devices. 7.3.17 CORE Added Cordova 6.0 sample. 7.3.16 CORE Fixed potential build problem with some encryption plugins (fixed regression in version 7.3.15). 7.3.15 DGD-350 CORE Fixed potential problem with Android library projects using class encryption when processed by standard Android tools (i.e. dx). 7.3.15 DGD-349 CORE Fixed default resource encryption plugins for Android runtimes older than API level 9. 7.3.15 DGD-348 CORE Fixed potential performance problems with certain resource encryption plugins. 7.3.15 DGD-244 CORE Fixed conversion of obfuscated exception handlers. 7.3.15 DGD-335 GRADLE Fixed execution of instrumentation tests that require Java 8 conversion in Gradle plugin. 7.3.15 CORE Improved the default configuration for the Google Play Services library. 7.3.14 DGD-344 CORE Fixed potential verification error on Android devices <= 4.4.x when using class encryption. 7.3.14 DGD-342 CORE Fixed Dex conversion of ternary operators with constructors with many arguments. 7.3.14 DGD-343 CORE Fixed VerifyError triggered by merging classes with shrinking disabled. 7.3.13 CORE Fixed NullPointerException during build when applying class encryption. 7.3.13 DGD-332 CORE Fixed invalid class merging for classes referenced from native libraries. 7.3.13 DGD-330 CORE Android Resources instances now always return an up-to-date Configuration object when resources are encrypted. 7.3.12 CORE Reduced injected code size when applying class encryption in library projects. 7.3.12 CORE For library projects, encrypted class data is now stored in the directory matching the package name of the encrypted class. 7.3.12 CORE Fixed conversion of lambda expressions that access protected methods. 7.3.11 CORE Reduced injected code size when applying encryption in library projects. 7.3.11 DGD-324 CORE Fixed handling of CR characters in dictionary files. 7.3.11 SK-ADDON Fixed a bug in the secure keyboard when moving between fields using the 'Next' button. 7.3.11 DGD-315 SK-ADDON Fixed potential NullPointerException in the secure keyboard. 7.3.11 CORE Fixed conversion of lambda expressions with array type parameters. 7.3.10 DGD-318 CORE Fixed conversion of exception handlers in highly obfuscated code. 7.3.10 DGD-317 CORE Fixed problem with string encryption in code with subroutines. 7.3.10 CORE Reduced injected code size for certain string encryption plugins. 7.3.10 DGD-314 RUNTIME Fixed false positives for root detection. 7.3.10 CORE Fixed conversion of method references to private methods. 7.3.09 CORE Added default configuration for the Glide image loading library. 7.3.09 DGD-279 GRADLE Fixed problem with latest Android Gradle plugin (v2.3.0-beta1+). 7.3.09 DGD-311 CORE Fixed possible access error for obfuscated internal classes on Android 4.4. 7.3.09 DGD-310 CORE Fixed native library encryption for declared target API level 25 or higher. 7.3.09 CORE Updated configuration for the Greenrobot EventBus library. 7.3.08 DGD-306 CORE Fixed NullPointerException when applying both String and Class encryption. 7.3.08 DGD-305 CORE Fixed merging of classes sometimes resulting in final methods being overridden. 7.3.08 DGD-304 CORE Fixed potential bug in class encryption when applying code obfuscation. 7.3.08 CORE Fixed adding reflection during apk processing. 7.3.08 DGD-301 FP-ADDON Fixed uniqueness of hardware-based fingerprints in case of a factory reset. 7.3.07 DGD-297 CORE Fixed native library encryption for Android 2.2 and older. 7.3.07 DGD-298 CORE Reduced injected code size when applying String encryption. 7.3.07 DGD-292 RUNTIME Fixed RootDetector: flag ALLOW\\_CYANOGENMOD implicitly enabled NO\\_CIRCUMSTANTIAL as well. 7.3.07 DGD-295 CORE Fixed default encryption plugins for Android runtimes older than API level 9. 7.3.06 DGD-284 CORE Fixed default assumption for StringBuilder.append(Object). 7.3.06 RUNTIME Restored public constants in RootDetector and EmulatorDetector of the runtime library. 7.3.06 GRADLE Fixed duplicate task names in Gradle plugin when using Android Gradle plugin v2.2.0+. 7.3.06 CORE Added debugging output in case a class cannot be written to the output, e.g. due to overflows. 7.3.06 GRADLE Fixed filtering of consumer ProGuard rules in Gradle plugin on Windows platforms. 7.3.05 DGD-283 CORE Fixed potential method size overflow when applying string encryption on classes with many strings. 7.3.05 DGD-280 CORE Fixed too many false-positive notes about classes/methods/fields potentially being used from native code. 7.3.05 DGD-279 GRADLE Fixed problem with latest Android Gradle plugin (v2.3.0-alpha1+). 7.3.05 GRADLE Fixed problem with missing classes whose names are prefixed by '_' when using Android Gradle plugin v2.2.0+. 7.3.05 GRADLE Reverted previous change for packagingOptions in Gradle plugin, they are now applied again as input filter. 7.3.04 CORE Fixed invalid conversion of float arrays when processing apk files. 7.3.04 DGD-263 GRADLE Fixed support for asset files with zip extension in Gradle plugin in combination with Android Gradle plugin v2.2.0+. 7.3.03 DGD-277 CORE Fixed build error when using a string encryption plugin with a try-catch block in its decryptString method. 7.3.03 GRADLE Fixed backporting of Java 8 language features for Android library projects in Gradle plugin. 7.3.03 DGD-236 GRADLE Fixed resolution of AAR dependencies for Android library projects in Gradle plugin. 7.3.03 DGD-274 CORE Ensure fully deterministic generation of dex files. 7.3.02 DGD-275 CORE Reduced number of injected methods and fields when applying encryption. 7.3.02 DGD-276 CORE Fixed missing obfuscation of injected classes due to custom -keep rules. 7.3.01 CORE Improved performance of pluggable String encryption. 7.3.01 DGD-272 GRADLE Fixed problems with external native builds in Gradle plugin (available since Android gradle plugin v2.2.0). 7.3.01 CORE Fixed support for -dontshrink when using encryption. 7.3.00 DGD-271 CORE Worked around bug in Android 6.0 causing spurious EISDIR error when decrypting encrypted classes. 7.3.00 DGD-220 CORE Added sample for Google Play Services SafetyNet library. 7.3.00 CORE Improve performance of internal pattern matching implementation by avoiding unneeded data copying. 7.3.00 DGD-250 GRADLE Packaging options are now applied as output filter in the Gradle plugin. 7.3.00 DGD-101 FP-ADDON Added device fingerprinting SDK. 7.3.00 DGD-261 CORE Added support for Dex format 037 (Android 7+). 7.3.00 DGD-231 SK-ADDON Added secure keyboard SDK. 7.3.00 CORE Added support for class encryption plugins. 7.3.00 WB-ADDON Added whitebox cryptography SDK for encryption/decryption of dynamic data at runtime. 7.3.00 DGD-242 CORE Added support for resource encryption on Android 7.0+ devices. 7.3.00 CORE Improved debugger detection. 7.3.00 DGD-241 CORE Improved emulator detection. 7.3.00 DGD-33 GRADLE Improved input filters for Gradle, Ant and Maven plugins to avoid including DexGuard related configuration files by mistake. Known issues: License files located in the same directory as dexguard.jar can not be found anymore when using Gradle 3.1+. Use a different mechanism to setup your license file as described here .","title":"Version 7.3 Oct 2016"},{"location":"releasenotes.html#version-72-jun-2016","text":"Version Issue Module Explanation 7.2.17 DGD-268 Added system property allow.incomplete.class.hierarchy to avoid warnings \"Can't find common super class\". 7.2.17 Fixed removal of constant value attributes from encrypted string fields that are kept via -keep rules. 7.2.16 DGD-267 Locale script, locale variant and extra screen configuration information in the resource tables are now preserved during processing. 7.2.16 Fixed error when applying encryption with the Eclipse plugin. 7.2.15 DGD-264 Fixed attribute strings of inlined string resources in XML resources. 7.2.15 Fixed conversion of stateless method references that require explicit casting. 7.2.14 Fixed conversion of interface method references. 7.2.14 DGD-262 Added support for AppDynamics instrumentation in Gradle plugin. 7.2.13 DGD-259 Fixed conversion of lambda expressions that access private methods. 7.2.13 DGD-258 Fixed conversion of lambda expressions that might shadow lambda expressions in super classes. 7.2.13 DGD-246 Fixed certificate pinning when used in combination with okhttp3 library. 7.2.12 DGD-237 Fixed pluggable encryption when using -dontshrink. 7.2.12 Added configuration for Facebook SoLoader library. 7.2.12 DGD-235 Fixed conversion of methods that re-use a cat1 parameter for cat2 values. 7.2.11 DGD-230 Fixed problem when encrypting string constants that were not inlined by the Java compiler. 7.2.11 Added default configuration for the Firebase library. 7.2.11 DGD-219 Fixed Dalvik variable allocation for large numbers of variables. 7.2.11 Fixed potential error when trying to export an apk with the Eclipse plugin. 7.2.11 Improved error message when building an Android application without including a default DexGuard configuration. 7.2.10 DGD-213 Added default configuration for the RetroFit2 library. 7.2.10 DGD-213 Added default configuration for the Okhttp3 library. 7.2.10 Added default configuration for the Video Experts Group MediaPlayer SDK. 7.2.10 DGD-212 Fixed backporting of lambda expressions with array types as parameter. 7.2.09 DGD-210 Fixed infinite loop in dexopt for classes with many encrypted strings in Android 4.4 and earlier versions. 7.2.08 DGD-208 Fixed processing of apk files that contain already obfuscated code (Google mobile services). 7.2.08 Updated configuration for the Droidsonroids Gif library. 7.2.08 Fixed too many warnings when checking class encryption configuration. 7.2.08 Added support to select the used default configuration in Eclipse plugin. 7.2.08 DGD-38 Fixed potential duplicate constructors when using -encryptclasses . 7.2.08 Updated license agreement. 7.2.07 Improved SSL Pinning: mitigated CVE-2016-2402 and added option to specify custom trust store or trust manager. 7.2.07 Added configuration for the ZBar library. 7.2.06 Output filters are now also applied to classes / resources injected by DexGuard. 7.2.06 DGD-167 Added support to print native library file mappings with option -printnativelibrarymapping . 7.2.06 DGD-167 Added support to print resource file mappings with option -printresourcemapping . 7.2.06 DGD-167 Added support to print asset file mappings with option -printassetmapping . 7.2.06 Fixed wrong removal of interfaces from inner classes in rare cases. 7.2.06 Fixed potential race condition during parallel optimization. 7.2.04 DGD-190 Fixed order of input in Gradle plugin. 7.2.04 Fixed reading of archives in nested directory structures. 7.2.04 DGD-188 Improved initialization of encrypted string data for Android library projects. 7.2.04 DGD-186 Updated Gradle plugin to improve support for integrated ndk builds (avoiding duplicate jar entry warnings). 7.2.04 Fixed hash_certificate tool when retrieving certificates from virtual hosts while using Java 8. 7.2.04 DGD-185 Fixed bug when building library projects with -addconfigurationdebugging enabled. 7.2.04 Updated default configuration for Android library projects to improve compatibility with Android gradle plugin 2.1.0+. 7.2.02 Updated class obfuscation dictionary due to problems on some Samsung devices. 7.2.02 DGD-184 Fixed incorrect parsing of Strings in resources that exceed 32767 characters. 7.2.02 DGD-169 Added support to filter consumer proguard rules from dependencies to Gradle plugin. 7.2.02 DGD-178 Updated Gradle plugin for Android Gradle plugin version 2.2.0-alpha2+. 7.2.02 DGD-182 Fixed reading of zip archives with extraneous bytes. 7.2.02 Improved compatibility of Java 8 support with recent versions of the Android gradle plugin (2.1.0+). 7.2.01 Refined default configuration for runtime invisible annotations (not kept anymore in application projects). 7.2.01 DGD-143 Added support to use class specifications with option -encryptclasses . 7.2.01 Added configuration for @Keep annotation from android support-annotations library. 7.2.00 Added support for configuration debugging with option -addconfigurationdebugging . 7.2.00 DGD-83 Added support for Java 8 language features (lambda expressions, method references, default and static interface methods). 7.2.00 Added support for the Jack&Jill toolchain in the Gradle plugin. 7.2.00 DGD-80 Added support for processing apk files directly.","title":"Version 7.2 Jun 2016"},{"location":"releasenotes.html#version-71-jan-2016","text":"Version Issue Module Explanation 7.1.34 DGD-135 Fixed potential dex overflow when keeping EnclosingMethod attributes and using option -multidex . 7.1.34 Added missing -addconfigurationdebugging option when writing out configuration with -printconfiguration . 7.1.33 DGD-174 Fixed obfuscation of injected members in case of asset and native library obfuscation. 7.1.33 DGD-173 Added variation when applying obfuscated names. 7.1.33 DGD-172 Fixed obfuscation of injected members due to custom -keep rules. 7.1.33 Fixed removal of method invocations that have been marked with -assumenoexternalsideeffects . 7.1.32 Added alternative mechanism to store encrypted classes. 7.1.32 Fixed removal of constant pool entries for encrypted classes in unencrypted classes. 7.1.32 Fixed conversion of code with special stack obfuscation. 7.1.32 DGD-170 Fixed potential invalid casts when adding reflection to obfuscated code attributes. 7.1.32 Added configuration for the MorphoSmart library. 7.1.31 Fixed shrinking of nameless parameters attribute. 7.1.31 Added configuration for the Greenrobot EventBus library. 7.1.31 Refined configuration for the Crashlytics library. 7.1.31 Fixed ClassCastException when combining Class encryption with dex splitting. 7.1.31 Fixed repackaging of classes in the default package. 7.1.31 Fixed removal of string constants that have been encrypted in case -dontshrink is enabled. 7.1.31 DGD-155 Fixed potentially missing classes when combining asset, native library or string encryption with class merging. 7.1.31 Class names of encrypted classes are now also encrypted. 7.1.31 Added support to keep the source file attribute for kept classes with system property obfuscate.keptclasses.dontrenamesourcefileattribute . 7.1.30 DGD-162 Fixed adding of native library files outside of the regular lib directory. 7.1.30 Added flag 'enableJava8' to gradle plugin to enable support for Java 8 language features. 7.1.30 DGD-161 Fixed conversion of multi-dimensional boolean arrays. 7.1.29 Added sample basic/Java8. 7.1.29 DGD-83 Added support for backporting of Java 8 language features (lambda expressions, method references, default and static interface methods). 7.1.29 DGD-46 Fixed potential problem \"New string section exceeds the length of the original\". 7.1.28 DGD-158 Fixed potential ClassNotFoundException when applying both class encryption and optimization. 7.1.28 DGD-156 Unsupported use of generics in the configuration will now result in a parsing exception. 7.1.28 Updated Gradle plugin for Android Gradle plugin version 2.2.0-alpha1+. 7.1.28 DGD-115 Gradle plugin will now disable DexGuard if InstantRun is activated. 7.1.27 Fixed support of plugins using Transform API in gradle builds on Windows platforms. 7.1.27 Samsung-specific metadata are now preserved in the default configuration. 7.1.27 DGD-157 Components that have both an intent filter and the exported flag set to false are now name obfuscated. 7.1.27 Added support for the Cordova CrossWalk plugin. 7.1.27 Improved configuration debugging support for loading of classes and native libraries. 7.1.26 Fixed configuration for sample projects NetCipher and SecurePreferences. 7.1.26 DGD-60 Added -keep modifier includecode . This modifier will prevent optimization of code attributes for matching methods. 7.1.26 Added sample advanced/Realm. 7.1.26 Fixed support for latest Realm plugin (0.88+). 7.1.25 Removed restriction on native libraries to be in the 'lib/' folder to get encrypted. 7.1.25 Classes containing attributes that can not be copied will not be considered for merging anymore. 7.1.25 DGD-153 Fixed potential ClassCastException with primitive arrays when obfuscating code. 7.1.25 Improved optimization of already obfuscated bytecode when 'optimize.conservatively' is enabled. 7.1.25 Conversion to Dalvik bytecode will now keep all instructions that might have side-effects. 7.1.24 DGD-152 Fixed NullPointerException while processing native libraries. 7.1.24 DGD-151 Fixed potential IllegalAccessError when applying asset encryption in library projects. 7.1.24 DGD-150 Fixed potential NullPointerException when combining class encryption with multidex. 7.1.24 DGD-149 Fixed incorrect application of negative -keep rules during class encryption. 7.1.24 Fixed potential NullPointerException during DexGuard processing of encrypted resources in case integer resource values are included as type string. 7.1.24 Reduced increase of code size due to automatic code obfuscation applied to classes containing encrypted strings. 7.1.23 DGD-148 Fixed IllegalArgumentException when creating arrays with more than 5 dimensions. 7.1.23 DGD-147 Fixed potential VerifyError when running multidexed applications on Android 4.x devices. 7.1.23 DGD-146 Refined the configuration lib/dexguard-release-aggressive.pro for Dagger 2. 7.1.23 Java classes referenced from native code by name are now excluded from shrinking and obfuscation. 7.1.23 Added warnings for shrunk or obfuscated class members whose names are still present in native code. 7.1.22 Fixed potential VerifyError when combining class encryption with multidex. 7.1.21 Fixed potential VerifyError when running multidexed applications on Android 4.x devices. 7.1.21 Improved shrinking of native libraries. 7.1.21 DGD-142 Fixed potential VerifyError when encrypting classes. 7.1.21 DGD-142 Classes being referred to from XML's are now excluded from class encryption (fixes potential NoClassDefFoundErrors). 7.1.20 Google Play Services version metadata are now preserved in the default configuration, fixing a potential runtime issue with the Play library. 7.1.20 Dependent jars in Android library projects will now be bundled into a single classes.jar, unless -dontobfuscate is specified. 7.1.19 DGD-133 Code obfuscation of methods will now retain source line information. 7.1.19 Fixed potential 'Can't remap constant index [..]' error during DexGuard processing with enabled -obfuscatecode option. 7.1.19 DGD-136 Classes referenced from XML resources (e.g., activities in the Android Manifest) are now excluded again from encryption. 7.1.19 DGD-62 Classes referenced from XML resources are now preserved in the primary dex file, when splitting dex files. 7.1.19 Gradle plugin will throw FileNotFoundException when trying to load a non-existing configuration file using getDefaultDexGuardFile(...). 7.1.19 Include generated class BuildConfig in aar file of Android library projects. 7.1.19 Fixed configuration for vector drawables in Android 4.4 and earlier versions. 7.1.19 Filename extensions are now preserved for application icons. 7.1.18 DGD-128 Fixed duplicate class definition warnings in Android library projects with file-based dependencies. 7.1.18 Added parallel processing of optimization step (Use -Dparallel.threads=XX to override default). 7.1.18 DGD-132 Fixed variable allocation in conversion step. 7.1.18 DGD-131 Fixed build exception when adding asset encryption to classes having a constructor throwing exceptions. 7.1.17 DGD-127 Fixed reflection on inherited protected fields. 7.1.17 DGD-124 Fixed potential verify error in conversion of exception handlers. 7.1.16 Fixed processing of native library files in Android library projects. 7.1.16 Added sample basic/NativeLibraryInLibraryProject to demonstrate the use of native libraries in Android library projects. 7.1.16 Fixed potential duplicate fields when applying code obfuscation. 7.1.14 Fixed NullPointerException when processing library projects. 7.1.14 Fixed incorrect encryption of fonts. 7.1.14 Fixed asset name obfuscation not being applied in some cases. 7.1.14 Added a warning for native libraries that can't be processed and will be copied instead. 7.1.13 Updated configuration for Apache Cordova: missing CordovaWebViewEngine does not create a note message anymore. 7.1.13 DGD-121 Disabled code obfuscation of methods containing monitor instructions. 7.1.13 DGD-117 Fixed incorrect inlining of resource id's referring to resources outside the processed application. 7.1.12 Refined configuration for Google Play Services library. 7.1.12 DGD-114 Fixed possible Verification errors for android applications when using string encryption in combination with method inlining. 7.1.12 Added verbose statistics for created dex files. 7.1.12 DGD-118 Fixed potential ArrayIndexOutOfBoundsException when merging classes with parameter annotations. 7.1.12 Improved shrinking of assets: assets referred to from XML and resource tables are now preserved, asset detection in bytecode has been improved. 7.1.12 DGD-113 Fixed potential IllegalArgumentException during optimization in case of missing super-classes. 7.1.10 DGD-112 The fileSize parameter of the ResourceEncryptionPlugin.encryptResource() method was not always correct and has been removed. You can use the length of the byte\\] parameter instead. 7.1.10 DGD-112 The NativeLibraryEncryptionPlugin.createNativeLibraryEncryptionKey() method now takes an additional approximate fileSize parameter. 7.1.09 Fixed possible IllegalArgumentException when encrypting strings in combination with tail-recursion optimization. 7.1.09 Fixed gradle builds with aar dependencies. 7.1.09 Fixed evaluation order of configuration files in gradle builds. 7.1.08 DGD-109 Fixed possible NoSuchMethodError when applying encryption in combination with -dontshrink. 7.1.08 Updated configuration for libGDX. 7.1.08 Added sample for libGDX: advanced/SuperJumperDemo. 7.1.08 DGD-105 Updated configuration for embedded Android wear apps. 7.1.08 DGD-107 Fixed updating of resource xml files due to obfuscated classes in android library projects. 7.1.08 DGD-106 Updated configuration for applications using JNA. 7.1.07 Improved loading of encrypted native libraries. 7.1.07 Added support for latest retrolambda plugin (3.3.0-beta4+). 7.1.07 Resources with identical values for all device configurations are now inlined. 7.1.06 DGD-99 Added default configuration for Google Maps API key. 7.1.06 Fixed possible NullPointerException when trying to encrypt missing asset files. 7.1.06 Fixed possible IllegalAccessError when accessing annotations at runtime in combination with option -multidex . 7.1.05 DGD-73 Updated configuration for Google Play Services. 7.1.05 DGD-98 Added shrinking and obfuscation of font assets. 7.1.05 DGD-71 Added inlining of Resources#getIdentifier, keeping resource names if inlining is disabled. 7.1.04 Fixed possible NullPointerException during optimization when encrypting strings. 7.1.03 Default configuration file dexguard-library-release-aggressive.pro now allows/requires to specify which API classes to keep. 7.1.03 DGD-86 Now treating ConstantValue attributes as optional for non-static fields. 7.1.03 DGD-96 Added optional attribute filter support for -keepresourcexmlelements option. 7.1.03 Fixed building wear applications with Gradle plugin. 7.1.02 DGD-95 Fixed packaging of the string encryption plugin API. 7.1.02 Fixed configuration of native library encryption in samples. 7.1.01 Added support for Cordova 5.1. 7.1.01 DGD-93 Fixed loading of native libraries from encrypted classes. 7.1.01 DGD-48 Fixed loading of native libraries from split classes. 7.1.01 DGD-91 Fixed inlining of mixed-type metadata. 7.1.01 DGD-94 Fixed certificate checking of the application certificate. 7.1.00 Added obfuscation of code, with new option -obfuscatecode . 7.1.00 Added plugin APIs for custom encryption of strings, assets, resources, and native libraries, with new option -pluginjars . 7.1.00 Added shrinking of native library files. 7.1.00 Added obfuscation of native library file names. 7.1.00 Added shrinking of assets. 7.1.00 Added obfuscation of asset file names. 7.1.00 Added encryption of resources, with new option -encryptresourcefiles . 7.1.00 Added inlining of Android manifest metadata in code. 7.1.00 DGD-68 Updated Android-specific math optimizations. 7.1.00 DGD-82 Keeping Relocation Read-Only (RELRO) information of native libraries in shrinking step. 7.1.00 Renamed dexguard_util.jar to dexguard-runtime.jar and updated package names for its contents. 7.1.00 Updated documentation and examples. Upgrade considerations: DexGuard now removes unused native libraries and asset files, and renames the remaining files. If this causes problems like UnsatisfiedLinkError or FileNotFoundException , you may need to preserve them with their original names, with -keepresourcefiles . DexGuard now offers a few alternative default configuration files, for convenience: the original dexguard-release.pro and the new dexguard-release-conservative.pro (disabling name obfuscation of native methods) and dexguard-release-aggressive.pro (enabling shrinking and name obfuscation of asset files).","title":"Version 7.1 Jan 2016"},{"location":"releasenotes.html#version-701-dec-2015","text":"Added new option -multidex as an alternative to -splitdexfiles , for convenience and for compatibility. Added support to encrypt native libraries and assets in Gradle library projects. Added configuration for Android Wear. Added configuration for RxJava. Added configuration for JNA. Allowing .so files in res/raw and in assets . Refined filter for runtime classes in org.w3c.dom . Improved license error reporting in Eclipse. Added configuration for the android-gif-drawable library. Improved configuration for the Google Play Services library. Improved configuration for the Realm library. Updated configuration for the ButterKnife 7 library. Fixed configuration for the Cordova library. Refined default configuration for animation holder classes. Added default configuration for design support library. Fixed optimization of complex entries in the resource table. Fixed handling of duplicate keys in the resource table. Fixed spurious incomplete packaging of native libraries. Fixed encoding of section indices in native libraries (DGD-57). Worked around initialized array size bug in Android 4.4 and older. Added support for animator, interpolator, and transition resources. Added support for styled strings. Added support to explicitly keep specified resources from being inlined. Added conversion of Exceptions attributes to Throws annotations. Reduced code size for decrypting encrypted assets. Fixed root detection. Fixed merging of classes with package visible fields. Fixed optimization of non-string resources in Resources#getString. Fixed optimization of resource references in custom styleable attributes. Fixed optimization of resource references in Android manifest. Fixed optimization of references to resource files in XML resources. Fixed optimization of non-string resources in Resources#getString. Fixed optimization of drawable resource references in selectors, etc. Fixed optimization of chained resource references. Fixed optimization of string resources with both styled and unstyled representations. Fixed possible invalid code when simplifying enum types. Fixed NegativeArraySizeException optimizing obfuscated code. Fixed possible type verification error in encrypted classes. Fixed StringIndexOutOfBoundsException obfuscating overlapping native function names. Fixed obfuscation of class names in resource files for DexGuard Standard. Fixed obfuscation of icon drawables in the resource table. Fixed handling of -dontcompress option for obfuscated resource files (DGD-69). Fixed NullPointerException obfuscating native libraries. Fixed ClassCastException while writing native libraries. Fixed loading of native libraries when using -splitdexfile or -multidex option (DGD-48). Fixed ArrayIndexOutOfBoundsException while writing native libraries (DGD-52). Fixed reflection on clone method for arrays. Fixed variable allocation in conversion of obfuscated code. Fixed IllegalStateException in conversion of long method invocations. Fixed conversion of dup/checkcast instruction sequences. Fixed conversion of put/store instructions in complex methods (DGD-70). Fixed NullPointerException in absence of -keepresourcefiles option. Fixed obfuscation of .xml resource file name extensions. Fixed conversion of complex methods with more than 256 local variables. Fixed IllegalStateException converting unusual Kotlin code. Fixed inclusion of application classes in main dex file. Fixed NullPointerException when not specifying expected class members. Fixed UTF-8 encoding for META-INF files. Fixed parsing of license file for Eclipse plugin in path with spaces. Fixed handling of multiDexEnabled and disablePreDex in Gradle plugin. Fixed missing native libraries from library jars in Gradle plugin. Fixed compatibility with Google Services Gradle plugin. Fixed compatibility with io.fabric Gradle plugin. Fixed stand-alone use of the Gradle task. Fixed multi-project builds with Gradle (DGD-85). Fixed backward compatibility of Ant task. Fixed incorrect styling for string resources with identical string values (DGD-64). Fixed market billing sample. Fixed market licensing sample. Creating intermediate classes jar for unit tests in Maven plugin. Updated Gradle plugin for Android Gradle plugin version 1.5.0. Updated Maven plugin for Android Maven plugin version 4.3.0. Fixed market billing sample. Fixed market licensing sample. Fixed signing config for debug builds in samples. Updated documentation and examples.","title":"Version 7.0.1 Dec 2015"},{"location":"releasenotes.html#version-70-may-2015","text":"Added optimization and obfuscation of resources, with new options -keepresources and -keepresourcefiles . Added obfuscation of JNI function names in native libraries. Added samples for various common security-related libraries. Added optimized configuration for the Realm library. Added multi-threading for conversion to Dalvik bytecode. Added support for includeLibsJarsFromAar option in Maven plugin. Added support for immediate Android runtime jar in Maven plugin. Skipping DexGuard if no configuration files in Gradle plugin. Improved obfuscation of Application names and ContentProvider names. Improved compatibility with Crashlytics. Refined configuration for possible external org.json library. Changed conversion of multiply instructions, to work around bug in ART 4.4. Changed conversion of switch instructions, to work around bug in ART 4.4. Fixed certificate checking method with string parameter and ok parameter. Fixed configuration for Thread.interrupted(). Fixed possible exceptions while processing generic signatures. Fixed accounting for dependencies with dex splitting. Fixed possible NullPointerException when combining class encryption and dex splitting. Fixed conversion of empty switch instructions. Fixed conversion of NaN constants. Fixed conversion of NoClassDefFoundError handlers for .class constructs. Fixed conversion of obfuscated overlapping catch handlers. Fixed conversion of code with control flow obfuscation. Fixed inclusion of .aar files in Maven plugin. Fixed processing of libraries with library dependencies in Gradle. Fixed late binding of output file name in Gradle plugin. Fixed copying of .a files in Eclipse plugin. Updated Gradle plugin for Android Gradle plugin version 1.2.0. Updated Maven plugin for Android Maven plugin version 4.1.0. Updated documentation and examples. Upgrade considerations: DexGuard now requires a personal license file. You should copy the license file that you receive to your home directory or one of the other supported locations. DexGuard may now optimize and remove Android resources and resource files. If your application accesses some resources in a non-standard way, that is, not using their resource IDs, you may need to preserve them with the new options -keepresources or possibly -keepresourcefiles . You may need to change any references in your Gradle scripts from com.saikoa to our new name com.guardsquare .","title":"Version 7.0 May 2015"},{"location":"releasenotes.html#version-61-dec-2014","text":"Added optimized configuration for the Paypal card.io library. Fixed IllegalArgumentException during optimization. Fixed escape analysis for desynchronization of methods. Fixed escape analysis with double or long method arguments. Fixed IllegalStateException when combining class encryption and dex splitting. Fixed conversion of monitor exit instructions in try blocks. Fixed conversion of obfuscated overlapping catch handlers. Fixed conversion of unreachable code in obfuscated exception handlers. Fixed conversion of catch handlers without named exceptions. Fixed conversion of scrambled code with temporary registers. Fixed conversion of synchronization code. Fixed handling of encrypted or split exception classes. Worked around bug in ART causing crash. Updated Gradle plugin for Android Gradle plugin version 1.0.0-rc1. Updated documentation and examples.","title":"Version 6.1 Dec 2014"},{"location":"releasenotes.html#version-60-sep-2014","text":"Added best practices to the documentation. Added new option -splitdexfile to automatically partition large dex files. Added sample for debug detection, emulator detection, and root detection. Extended sample for tamper detection. Added sample for SSL pinning. Added sample for a web view with asset encryption. Added sample for Apache Cordova with asset encryption. Added optimized configuration for new AdMob library. Added optimized configuration for the Amazon Ads library. Added optimized configuration for the Facebook Conceal library. Added optimized configuration for the OrmLite library. Added optimized configuration for the Retrofit library. Added optimized configuration for the Tapjoy library. Added optimized configuration for the libGDX library. Added optimized configuration for the Java mail library. Added optimized configuration for the LogBack library. Added optimized configuration for the Google Cloud Messaging library. Added configuration for attributes in libraries. Improved configuration for the ButterKnife library. Added support for signing applications with Maven plugin. Added missing support for intent with targetClass in preferences XML. Improved robustness of native library encryption. Worked around bug in ART causing crash. Fixed possible ClassCastException when simplifying enum types. Fixed possible IllegalArgumentException when simplifying enum types with encrypted constant names. Fixed overly optimistic optimization of some Class methods. Fixed possible ClassCastException due to class encryption. Fixed conversion of duplicate annotations. Fixed conversion of overflowing branch instructions. Fixed conversion of overflowing negation instructions. Fixed conversion of empty try blocks. Fixed conversion of parameter names for ART. Fixed class encryption causing verification error. Fixed processing of class names in meta-data elements. Fixed processing of custom classes in res/xml-*/*.xml files. Fixed keeping of onClick handlers with extensions of MenuItem as parameters. Fixed inclusion of libraries in library projects in custom Ant rules. Fixed inclusion of native libraries in Maven plugin. Fixed lazy resolution of input and output files in Gradle plugin. Fixed inclusion of Renderscript support library in Gradle plugin. Fixed finding default configuration files in Gradle plugin in Windows. Fixed keeping of package names in Gradle library plugin. Updated Gradle plugin for Android Gradle plugin version 0.11.1. Updated Eclipse plugin for Android Eclipse plugin version 22.6.3. Updated Maven plugin for Android Maven plugin version 3.9.0-rc.3. Fixed unsuitable builder in library projects in Eclipse plugin. Fixed support for dependencies on aar files in Maven plugin. Updated documentation and examples.","title":"Version 6.0 Sep 2014"},{"location":"releasenotes.html#version-55-mar-2014","text":"Added optimized configuration for the Guava library. Added optimized configuration for the SQLCipher library. Added optimized configuration for the Couchbase Lite library. Added optimized configuration for the Ektorp library. Added optimized configuration for the Jackson library. Added optimized configuration for the Nuance Vocalizer library. Added support for lazily specified credentials in Gradle plugin. Fixed encryption of native libraries when not optimizing. Fixed optimization causing NullPointerException during processing. Fixed reflection causing exceptions during processing and execution. Fixed interference between reflection, class encryption, and string encryption. Fixed obfuscation of reference values in custom XML attributes. Fixed handling of library jars in library projects in Gradle plugin. Fixed variable allocation in conversion step. Fixed index overflow for strings in conversion step. Fixed parsing of some unusual characters in ReTrace. Fixed lint checking with Gradle. Fixed instrumentation testing with Gradle. Fixed packaging of resource files from source directory in Ant task. Refined filter for files in META-INF/services in plugins. Refined filter for duplicate Apache http libraries. Added support for 'jniLibs' directive in Gradle plugin. Updated Gradle plugin for Android Gradle plugin version 0.9.0. Updated documentation and examples.","title":"Version 5.5 Mar 2014"},{"location":"releasenotes.html#version-54-dec-2013","text":"Added encryption of native libraries. Added preferences in Eclipse plugin to enable or disable processing steps for debug builds and export builds. Sending Eclipse export logs to console panel. Added 'dexguard-library' plugin for Gradle. Updated Gradle plugin for Android Gradle plugin version 0.6.3. Adapted Gradle plugin to work with Android Studio. Updated Maven plugin for Android Maven plugin version 3.8.0. Added support for provided libraries in Maven plugin. Added support for properties in keystore options. Added default filter in Maven plugin to clean up input. Added optimized configuration for the v7 compatibility library. Added optimized configuration for the Apache logging library. Added optimized configuration for the Google Play Services library. Added optimized configuration for the Dagger/ButterKnife libraries. Refined filtering of duplicated Apache http libraries from input. Reduced processing time for string/class/asset encryption. Fixed string encryption and class encryption for Android 1.5. Fixed spuriously incorrect string encryption and asset encryption. Fixed interfering string encryption and asset encryption. Fixed verification error caused by class encryption. Fixed conversion of optimized chained assignments to fields. Fixed conversion of some method invocations with many arguments. Fixed conversion of unused exception handlers. Fixed constructor flag for static initializers. Fixed simplification of redundant boolean variables. Fixed removal of unused parameters from methods with more than 64 arguments. Fixed optimization of caught exceptions passed as parameters. Fixed optimization of throwing exceptions received as parameters. Fixed processing of view elements in layout XML files. Fixed processing of parentActivityName attribute in manifest files. Fixed parsing of additional jar options in Eclipse plugin. Fixed Gradle builds with dependencies on library projects. Fixed releasing of resources in tamper detection. Fixed configuration of Amazon IAP sample. Fixed market detection sample. Updated documentation and examples.","title":"Version 5.4 Dec 2013"},{"location":"releasenotes.html#version-53-jul-2013","text":"Improved string encryption. Improved asset encryption. Added Gradle plugin for Android Gradle plugin version 0.5.1. Updated Maven plugin for Android Maven plugin version 3.6.0. Updated Eclipse plugin for ADT release 22. Added configuration for compatibility library. Added configuration for annotated Javascript interface methods. Added configuration for AdMob library. Filtering copies of runtime classes from third-party libraries. Always reading and writing resource files using UTF-8 for Android. Fixed processing of raw resource XML files. Fixed check for numeric resource XML attribute ID. Fixed encoding problem of encrypted assets. Fixed initialization of settings in Eclipse. Fixed version numbers in Maven plugin. Fixed configuration of standard android-maven-plugin goals. Fixed conversion of unusual obfuscated code. Fixed string encryption for JME. Updated documentation and examples.","title":"Version 5.3 Jul 2013"},{"location":"releasenotes.html#version-52-mar-2013","text":"Added asset encryption. Extended obfuscation of binary resource XML files. Added Maven plugin. Added alternative ways to configure string encryption. Only preserving v4 fragments when necessary. Fixed class encryption for Android 1.5. Improved class encryption for Android 4.0 and higher. Now including dependent libraries when building library project. Fixed optimization of instanceof test on interface. Fixed exception when adding reflection in large classes. Fixed exception handling of reflected method invocations. Fixed exception when referencing encrypted interfaces. Fixed spurious and rare NullPointerException in encrypted classes. Fixed encryption of empty strings. Fixed encryption of strings in static initializers of interfaces. Fixed handling of non-reachable code in optimization step. Fixed handling of dynamically accessed class members with identical names. Fixed conversion of code invoking methods with many arguments. Fixed conversion of unusual exception handlers. Fixed conversion of enclosing method attributes without methods. Fixed exception converting subtractions with nearly short constants. Fixed exception converting overflowing branch instructions. Fixed automatic recompilation in Eclipse plugin. Fixed use of newly created key store when exporting in Eclipse. Added sample for Amazon In-App Purchasing library. Added sample for automatically removing logging statements. Improved hardening configuration of License Verification Library sample. Updated Ant script and Eclipse plugin for Android SDK Tools r21. Updated documentation and examples.","title":"Version 5.2 Mar 2013"},{"location":"releasenotes.html#version-51-oct-2012","text":"Added support for processing Android library projects. Added obfuscation of binary resource XML files. Adapted Eclipse plugin for Android Development Tools revision 20. Adapted Ant rules for compatibility with standard build process. Adapted class encryption for Android 4.1. Fixed class encryption for Android 2.2 and older. Extended automatic detection of reflective access to class members. Improved removal of unused code in optimization step. Improved string encryption for very long strings. Fixed specialization of class member descriptors. Fixed type mismatch of reflected method invocations. Fixed access problems for reflected class member access. Fixed potential overflow of branch offsets in conversion to dex bytecode. Fixed handling of primitive array types in conversion to dex bytecode. Added support for parameter annotations. Fixed conversion of default annotation values to dex bytecode. Fixed conversion of repeated arguments to dex bytecode. Fixed conversion of optimized exception handlers to dex bytecode. Fixed conversion of optimized synchronized methods to dex bytecode. Working around bug in Dalvik VM causing spurious crashes. Added source name debug information for stack traces to dex bytecode. Fixed shrinking of local variable debug information. Fixed handling of duplicate classes in dex files. Fixed handling of merged manifest files. Detecting dynamic method invocations with longer method signatures. Updated documentation and examples.","title":"Version 5.1 Oct 2012"},{"location":"releasenotes.html#version-50-may-2012","text":"First release of DexGuard. Added support for signing jars, with new options -keystore , -keystorepassword , -keyalias , and -keypassword . Added new archiving options -dontcompress and -zipalign . Added Java to Dalvik bytecode conversion. Added support for apk archives. Added parameter escape analysis. Added parameter modification analysis. Added specialization of field and method descriptors. Added method desynchronization. Added more peephole optimizations. Added Android-specific optimizations. Added obfuscation through introspection. Added string obfuscation. Added detection of WebView.addJavascriptInterface. Now always using UTF-8 encoding for all input and output. Updated documentation and examples.","title":"Version 5.0 May 2012"},{"location":"reportingissues.html","text":"When you cannot find the solution to a problem after experimenting with the suggestions in the Troubleshooting section, please reach out to Guardsquare support . In order for our support team to efficiently process your support request, please describe in detail explanation the context of your issue. In general, the following data is especially relevant to send along when contacting us: A description of which features you have disabled or which keep rules you have tried out. The used DexGuard configuration file(s), like e.g. dexguard-configuration.pro . In case of a crash, the verbose stacktrace of the crash (build-time or runtime). In case of a crash, the crashing apk, aar or aab file. The full contents of the build/outputs/dexguard/configs directory, containing the used libraryjars and consumer rules for each build variant. In case of build issues, the generated DexGuard build log. It can be obtained by executing following command: Linux/macOS ./gradlew assembleRelease > log.txt --stacktrace Windows gradlew assembleRelease > log.txt --stacktrace The unobfuscated apk, aar, or aab file for comparison.","title":"Reporting Issues"},{"location":"runtime.html","text":"Runtime Library \u00b6 DexGuard's runtime library provides the following functionality: Tamper detection for the application. Environment checks for the Android runtime. Asset encryption for Cordova and for WebView clients. SSL pinning for secure network communication. The sections below outline the general use of the different parts of the runtime library. Please refer to the runtime Javadoc for more details. Dependencies for the runtime library \u00b6 The runtime library is a stand-alone Android library which you can find in the DexGuard distribution at lib/dexguard-runtime.aar or included from the secure maven repository: Groovy dependencies { implementation 'com.guardsquare:dexguard-runtime:9.2+' } Kotlin dependencies { implementation ( \"com.guardsquare:dexguard-runtime:9.2+\" ) } It is self-contained, and does not depend on any libraries, other than the Java Standard Library. The AAR file must be added to your application project in order to use the API. Tamper detection \u00b6 The runtime library provides three detector classes that check whether the application has been modified in some way (in package com.guardsquare.dexguard.runtime.detection ): Detector Description TamperDetector Checks if the apk file has been modified. CertificateChecker Checks if the application has been signed with the build certificate. FileChecker Checks if one or more individual files have been modified. For example, you can use the TamperDetector to check the apk file: // We need a context for most methods. final Context context = ...; // Expected return value. You can pick any number, // to make the code less predictable. final int OK = 1 ; // Let the DexGuard runtime library detect whether the apk has // been modified or repackaged in any way. if ( TamperDetector . checkApk ( context , OK ) != OK ) { // The application has been modified. // ... } The check returns the value of the optional integer argument OK (default=0) if the application is unchanged. You should implement a suitable reaction in case the application has been modified, for example stop it or reduce its functionality in a more subtle way. The FileChecker can be used to check if individual files inside the apk have been tampered with. This can be used if the application is modified after being processed by DexGuard (e.g. to resign the application, see Limitations below): // ... int primaryDexChanged = new FileChecker ( context ). checkFile ( \"classes.dex\" , OK ); // Let the DexGuard runtime library detect whether the apk has // been modified or repackaged in any way. if ( primaryDexChanged != OK ) { // The classes.dex file has been modified. // ... } Limitations \u00b6 The tamper detection is very reliable. However, some stores, including the Amazon App Store and the Google Play Store when using the optional Google Play App Signing , re-sign the application when you upload your app to the store. This will set off the tamper detection, as the application will be modified and signed with a different certificate than the one specified at build time. However, file-level tamper detection is unaffected by the re-signing with certain exceptions, e.g., the AndroidManifest.xml file which is modified during the re-signing. Using the Certificate Checker with Google Play signing \u00b6 When using app signing by Google Play , Google manages and protects your app's signing key for you and signs your APKs on your behalf. In this case DexGuard does not know which signing key will be used and thus does not know which certificate hash should be used to detect resigning of your app. To circumvent this issue, our certificate checker can take the expected certificate hash as an argument when called. You can find the certificate hash of the signing key used by Google on your Google Play console under the \"App Signing\" section. Note The use of MD5 hashes has been deprecated. Use SHA-256 hashes for the best security guarantees. Environment checks \u00b6 The runtime library also provides detector classes that check whether the application is currently running in a specific environment (in package com.guardsquare.dexguard.runtime.detection ): Detector Description HookDetector Checks if the application is being hooked with a specialized framework like Xposed or Substrate. RootDetector Checks if the application is running on a rooted device. DebugDetector Checks if the application can be debugged or if it is being debugged. EmulatorDetector Checks if the application is running on an emulator. For example, you can use the HookDetector to check if the user is explicitly hooking the application with a specialized tool: // Expected return value. You can pick any number, // to make the code less predictable. final int OK = 1 ; // Let the DexGuard runtime library detect whether the application is being // hooked. if ( HookDetector . isApplicationHooked ( OK ) != OK ) { // The application is being hooked. // ... } The check returns the value of the optional integer argument OK (default=0) if the application is not being hooked. You should implement a suitable reaction in case the application is being hooked, for example send back a warning to your server or stop the application. Root detector \u00b6 The original root detection method RootDetector.isDeviceRooted() , which returns an integer value as described above, has been deprecated. The preferred way to manually perform root detection is by using RootDetector.checkDeviceRooted() instead, as presented in the following code: Java 8 import com.guardsquare.dexguard.runtime.detection.RootDetector ; import com.guardsquare.dexguard.runtime.report.RootDetectorReport ; public class Foo { public void bar () { // This is the location where you want to manually check for rooted devices. // context is the android.content.Context used to perform root detection. RootDetector . checkDeviceRooted ( context , Foo :: rootDetectionCallback ); } /** * The callback to execute when the root check completes. The device * is rooted when okValue != returnValue. * * @param okValue the OK value provided to checkDeviceRooted(). * @param returnValue the value computed by the root detector. */ private static void rootDetectionCallback ( int okValue , int returnValue ) { if ( okValue != returnValue ) { // Device is rooted, execute specific code. ... } } } The callback will be called as soon as root detection has completed. The device has been detected rooted when the okValue is different from the returnValue . Warning For compatibility reasons with automatic RASP injection, the callback method should be defined as static. Kotlin import com.guardsquare.dexguard.runtime.detection.RootDetector import com.guardsquare.dexguard.runtime.report.RootDetectorReport class Foo { fun bar () { // This is the location where you want to manually check for rooted devices. // context is the android.content.Context used to perform root detection. RootDetector . checkDeviceRooted ( context ) { okValue , returnValue -> callback ( okValue , returnValue ) } } companion object { @JvmStatic fun callback ( okValue : Int , returnValue : Int ) { if ( okValue != returnValue ) { // Device is rooted, execute specific code. ... } } } } The callback will be called as soon as root detection has completed. The device has been detected rooted when the okValue is different from the returnValue . Warning For compatibility reasons with automatic RASP injection, the callback function should be defined in the companion object , and marked as @JvmStatic . Java 7 and earlier import com.guardsquare.dexguard.runtime.detection.RootDetector ; import com.guardsquare.dexguard.runtime.report.RootDetectorReport ; public class Foo { public void bar () { // This is the location where you want to manually check for rooted devices. // context is the android.content.Context used to perform root detection. RootDetector . checkDeviceRooted ( context , new RootDetector . Callback () { @Override public void onRootDetectionResultReceived ( int okValue , int returnValue ) { rootDetectionCallback ( okValue , returnValue ); } }); } /** * The callback to execute when the root check completes. The device * is rooted when okValue != returnValue. * * @param okValue the OK value provided to checkDeviceRooted(). * @param returnValue the value computed by the root detector. */ private static void rootDetectionCallback ( int okValue , int returnValue ) { if ( okValue != returnValue ) { // Device is rooted, execute specific code. ... } } } The callback will be called as soon as root detection has completed. The device has been detected rooted when the okValue is different from the returnValue . Warning For compatibility reasons with automatic RASP injection, the code in the anonymous class used as callback should only call a static method which performs the actions when the device is detected as rooted. Limitations \u00b6 Notably the root detector may return false positives , wrongly indicating that a device is rooted, for example. This sometimes happens if vendors install files on their factory images that are generally only present on rooted devices. The root detector may also return false negatives , missing rooted devices. This may happen if users have installed recent, unknown root-hiding frameworks. We update detectors on a regular basis to account for new developments and to improve the detection results. If you encounter a case where the runtime library wrongly flags a device as being rooted, or did not correctly detect a device as being rooted, please contact our technical support with any available details. Environment Checks Performance \u00b6 The following table provides an impression of the overhead of the environment checks. It shows the execution times in milliseconds for the API calls on a number of common devices. Some of the runtime checks are one-time checks. You should use these checks once at the start of the application. However, other runtime checks need to be called multiple times at appropriate places. You should use these checks at multiple places in the code, specifically before performing a security sensitive activity (cfr. column \"One-time\" in the following table). API One-time Samsung S8+ Pixel 2 Nexus 6P Samsung S8 Nubia NX591J Google Nexus 5X - - Android 9 Android Q Android 8 Android 8 Android 7.1.1 Android 6.0.1 isDebuggable Yes 51 32 106 60 50 51 isDebuggerConnected No 1 1 15 2 3 2 isSignedWithDebugKey Yes <1 2 10 5 7 6 isRunningInEmulator Yes 5 2 23 2 2 <1 isDeviceRooted Yes 170 95 13 (Root) 2 (Root) 900 1 (Root) isApplicationHooked No 500 316 690 335 140 125 isApplicationHooked - FAST No 132 91 257 98 80 82 isRunningInVirtualEnvironment Yes 1139 121 523 1500 510 230 You can see that the HookDetector.isApplicationHooked is considerably faster with the FAST flag. The HookDetector does not skip any checks with the FAST flag. However, for faster hook detection, it only considers hooking mechanisms found in known hooking tools. Debugger blocking \u00b6 The runtime library provides an API DebugBlocker.blockDebugger (in package com.guardsquare.dexguard.runtime.detection ) to block native debuggers (not traditional Java debuggers, which are based on a different mechanism). You can implement its interface OnAttackListener and method onAttack() as a callback method in case the debug blocker is attacked. You need to provide an instance of your listener to the DebugBlocker.blockDebugger API. Follow the two step process to use debug blocker: Create a class that implements the DebugBlocker.OnAttackListener interface to provide a callback method. class AttackHandlerExample implements DebugBlocker . OnAttackListener { public void onAttack () { // Here you should implement the expected app behavior in case of an attack on the DebugBlocker. // ... } } Provide an instance of the AttackHandlerExample class to DebugBlocker.blockDebugger . int isDebuggerBlocked = DebugBlocker . blockDebugger ( new AttackHandlerExample ()); if ( isDebuggerBlocked != 0 ) { // Debug blocker wasn't successful. You can further check the reason of failure. if (( isDebuggerBlocked & DebugBlocker . DEBUGGER_CONNECTED ) != 0 ) { // A debugger is already connected to the application. The application should exit. // ... } } Please refer to the sample project in the directory sample/basic/DebugBlocker for an example implementation of the debug blocker. Asset encryption for WebView clients \u00b6 You can encrypt the asset files (javascript, html, css,...) that are included in Cordova applications or applications with a WebView. Please refer to the package com.guardsquare.dexguard.runtime.encryption and to the sample projects in the directories samples/basic/Cordova and samples/basic/WebView . SSL pinning \u00b6 Several modern network libraries like OkHttp already support SSL pinning. The DexGuard runtime library provides some support classes to implement SSL pinning techniques with some older commonly used libraries: org.apache.http.client (certificate pinning), javax.net.ssl (certificate pinning), javax.net.ssl (public key pinning). Additionally, the support classes are hardened against commonly known hooking attacks, making SSL pinning solutions more robust. You can find the support classes in package com.guardsquare.dexguard.runtime.net . The distribution also includes a command line tool to extract the public key hashes from a server certificate ( bin/hash_certificate.[sh,bat] ). For example, you can enable public key pinning for an HttpsURLConnection : // Create a TrustManager that only accepts servers with the specified public key hashes. // This code snippet can be generated by the hash_certificate tool for a given url. // In this example we use the Wikipedia certificate for illustration purposes. com . guardsquare . dexguard . runtime . net . PublicKeyTrustManager trustManager = new com . guardsquare . dexguard . runtime . net . PublicKeyTrustManager ( new String [] { // CN=*.wikipedia.org, O=\"Wikimedia Foundation, Inc.\", L=San Francisco, ST=California, C=US \"8FCF8FD90E88D6E35BA8CB6D8836A2BF\" , } ); SSLPinner sslPinner = new SSLPinner ( trustManager ); // ... // Create the URL connection. URL url = new URL ( urlString ); HttpsURLConnection urlConnection = ( HttpsURLConnection ) url . openConnection (); sslPinner . pinHttpsURLConnection ( urlConnection ); Please refer to the additional examples in the directories samples/basic/SSLPinning and samples/basic/SSLPinningWebView . These projects also illustrate how to harden the SSL pinning code further with DexGuard.","title":"Runtime Library"},{"location":"runtime.html#runtime-library","text":"DexGuard's runtime library provides the following functionality: Tamper detection for the application. Environment checks for the Android runtime. Asset encryption for Cordova and for WebView clients. SSL pinning for secure network communication. The sections below outline the general use of the different parts of the runtime library. Please refer to the runtime Javadoc for more details.","title":"Runtime Library"},{"location":"runtime.html#dependencies","text":"The runtime library is a stand-alone Android library which you can find in the DexGuard distribution at lib/dexguard-runtime.aar or included from the secure maven repository: Groovy dependencies { implementation 'com.guardsquare:dexguard-runtime:9.2+' } Kotlin dependencies { implementation ( \"com.guardsquare:dexguard-runtime:9.2+\" ) } It is self-contained, and does not depend on any libraries, other than the Java Standard Library. The AAR file must be added to your application project in order to use the API.","title":"Dependencies for the runtime library"},{"location":"runtime.html#tamper-detection","text":"The runtime library provides three detector classes that check whether the application has been modified in some way (in package com.guardsquare.dexguard.runtime.detection ): Detector Description TamperDetector Checks if the apk file has been modified. CertificateChecker Checks if the application has been signed with the build certificate. FileChecker Checks if one or more individual files have been modified. For example, you can use the TamperDetector to check the apk file: // We need a context for most methods. final Context context = ...; // Expected return value. You can pick any number, // to make the code less predictable. final int OK = 1 ; // Let the DexGuard runtime library detect whether the apk has // been modified or repackaged in any way. if ( TamperDetector . checkApk ( context , OK ) != OK ) { // The application has been modified. // ... } The check returns the value of the optional integer argument OK (default=0) if the application is unchanged. You should implement a suitable reaction in case the application has been modified, for example stop it or reduce its functionality in a more subtle way. The FileChecker can be used to check if individual files inside the apk have been tampered with. This can be used if the application is modified after being processed by DexGuard (e.g. to resign the application, see Limitations below): // ... int primaryDexChanged = new FileChecker ( context ). checkFile ( \"classes.dex\" , OK ); // Let the DexGuard runtime library detect whether the apk has // been modified or repackaged in any way. if ( primaryDexChanged != OK ) { // The classes.dex file has been modified. // ... }","title":"Tamper detection"},{"location":"runtime.html#limitations","text":"The tamper detection is very reliable. However, some stores, including the Amazon App Store and the Google Play Store when using the optional Google Play App Signing , re-sign the application when you upload your app to the store. This will set off the tamper detection, as the application will be modified and signed with a different certificate than the one specified at build time. However, file-level tamper detection is unaffected by the re-signing with certain exceptions, e.g., the AndroidManifest.xml file which is modified during the re-signing.","title":"Limitations"},{"location":"runtime.html#using-the-certificate-checker-with-google-play-signing","text":"When using app signing by Google Play , Google manages and protects your app's signing key for you and signs your APKs on your behalf. In this case DexGuard does not know which signing key will be used and thus does not know which certificate hash should be used to detect resigning of your app. To circumvent this issue, our certificate checker can take the expected certificate hash as an argument when called. You can find the certificate hash of the signing key used by Google on your Google Play console under the \"App Signing\" section. Note The use of MD5 hashes has been deprecated. Use SHA-256 hashes for the best security guarantees.","title":"Using the Certificate Checker with Google Play signing"},{"location":"runtime.html#environment-checks","text":"The runtime library also provides detector classes that check whether the application is currently running in a specific environment (in package com.guardsquare.dexguard.runtime.detection ): Detector Description HookDetector Checks if the application is being hooked with a specialized framework like Xposed or Substrate. RootDetector Checks if the application is running on a rooted device. DebugDetector Checks if the application can be debugged or if it is being debugged. EmulatorDetector Checks if the application is running on an emulator. For example, you can use the HookDetector to check if the user is explicitly hooking the application with a specialized tool: // Expected return value. You can pick any number, // to make the code less predictable. final int OK = 1 ; // Let the DexGuard runtime library detect whether the application is being // hooked. if ( HookDetector . isApplicationHooked ( OK ) != OK ) { // The application is being hooked. // ... } The check returns the value of the optional integer argument OK (default=0) if the application is not being hooked. You should implement a suitable reaction in case the application is being hooked, for example send back a warning to your server or stop the application.","title":"Environment checks"},{"location":"runtime.html#root-detector","text":"The original root detection method RootDetector.isDeviceRooted() , which returns an integer value as described above, has been deprecated. The preferred way to manually perform root detection is by using RootDetector.checkDeviceRooted() instead, as presented in the following code: Java 8 import com.guardsquare.dexguard.runtime.detection.RootDetector ; import com.guardsquare.dexguard.runtime.report.RootDetectorReport ; public class Foo { public void bar () { // This is the location where you want to manually check for rooted devices. // context is the android.content.Context used to perform root detection. RootDetector . checkDeviceRooted ( context , Foo :: rootDetectionCallback ); } /** * The callback to execute when the root check completes. The device * is rooted when okValue != returnValue. * * @param okValue the OK value provided to checkDeviceRooted(). * @param returnValue the value computed by the root detector. */ private static void rootDetectionCallback ( int okValue , int returnValue ) { if ( okValue != returnValue ) { // Device is rooted, execute specific code. ... } } } The callback will be called as soon as root detection has completed. The device has been detected rooted when the okValue is different from the returnValue . Warning For compatibility reasons with automatic RASP injection, the callback method should be defined as static. Kotlin import com.guardsquare.dexguard.runtime.detection.RootDetector import com.guardsquare.dexguard.runtime.report.RootDetectorReport class Foo { fun bar () { // This is the location where you want to manually check for rooted devices. // context is the android.content.Context used to perform root detection. RootDetector . checkDeviceRooted ( context ) { okValue , returnValue -> callback ( okValue , returnValue ) } } companion object { @JvmStatic fun callback ( okValue : Int , returnValue : Int ) { if ( okValue != returnValue ) { // Device is rooted, execute specific code. ... } } } } The callback will be called as soon as root detection has completed. The device has been detected rooted when the okValue is different from the returnValue . Warning For compatibility reasons with automatic RASP injection, the callback function should be defined in the companion object , and marked as @JvmStatic . Java 7 and earlier import com.guardsquare.dexguard.runtime.detection.RootDetector ; import com.guardsquare.dexguard.runtime.report.RootDetectorReport ; public class Foo { public void bar () { // This is the location where you want to manually check for rooted devices. // context is the android.content.Context used to perform root detection. RootDetector . checkDeviceRooted ( context , new RootDetector . Callback () { @Override public void onRootDetectionResultReceived ( int okValue , int returnValue ) { rootDetectionCallback ( okValue , returnValue ); } }); } /** * The callback to execute when the root check completes. The device * is rooted when okValue != returnValue. * * @param okValue the OK value provided to checkDeviceRooted(). * @param returnValue the value computed by the root detector. */ private static void rootDetectionCallback ( int okValue , int returnValue ) { if ( okValue != returnValue ) { // Device is rooted, execute specific code. ... } } } The callback will be called as soon as root detection has completed. The device has been detected rooted when the okValue is different from the returnValue . Warning For compatibility reasons with automatic RASP injection, the code in the anonymous class used as callback should only call a static method which performs the actions when the device is detected as rooted.","title":"Root detector"},{"location":"runtime.html#limitations_1","text":"Notably the root detector may return false positives , wrongly indicating that a device is rooted, for example. This sometimes happens if vendors install files on their factory images that are generally only present on rooted devices. The root detector may also return false negatives , missing rooted devices. This may happen if users have installed recent, unknown root-hiding frameworks. We update detectors on a regular basis to account for new developments and to improve the detection results. If you encounter a case where the runtime library wrongly flags a device as being rooted, or did not correctly detect a device as being rooted, please contact our technical support with any available details.","title":"Limitations"},{"location":"runtime.html#environment-checks-performance","text":"The following table provides an impression of the overhead of the environment checks. It shows the execution times in milliseconds for the API calls on a number of common devices. Some of the runtime checks are one-time checks. You should use these checks once at the start of the application. However, other runtime checks need to be called multiple times at appropriate places. You should use these checks at multiple places in the code, specifically before performing a security sensitive activity (cfr. column \"One-time\" in the following table). API One-time Samsung S8+ Pixel 2 Nexus 6P Samsung S8 Nubia NX591J Google Nexus 5X - - Android 9 Android Q Android 8 Android 8 Android 7.1.1 Android 6.0.1 isDebuggable Yes 51 32 106 60 50 51 isDebuggerConnected No 1 1 15 2 3 2 isSignedWithDebugKey Yes <1 2 10 5 7 6 isRunningInEmulator Yes 5 2 23 2 2 <1 isDeviceRooted Yes 170 95 13 (Root) 2 (Root) 900 1 (Root) isApplicationHooked No 500 316 690 335 140 125 isApplicationHooked - FAST No 132 91 257 98 80 82 isRunningInVirtualEnvironment Yes 1139 121 523 1500 510 230 You can see that the HookDetector.isApplicationHooked is considerably faster with the FAST flag. The HookDetector does not skip any checks with the FAST flag. However, for faster hook detection, it only considers hooking mechanisms found in known hooking tools.","title":"Environment Checks Performance"},{"location":"runtime.html#debugger-blocking","text":"The runtime library provides an API DebugBlocker.blockDebugger (in package com.guardsquare.dexguard.runtime.detection ) to block native debuggers (not traditional Java debuggers, which are based on a different mechanism). You can implement its interface OnAttackListener and method onAttack() as a callback method in case the debug blocker is attacked. You need to provide an instance of your listener to the DebugBlocker.blockDebugger API. Follow the two step process to use debug blocker: Create a class that implements the DebugBlocker.OnAttackListener interface to provide a callback method. class AttackHandlerExample implements DebugBlocker . OnAttackListener { public void onAttack () { // Here you should implement the expected app behavior in case of an attack on the DebugBlocker. // ... } } Provide an instance of the AttackHandlerExample class to DebugBlocker.blockDebugger . int isDebuggerBlocked = DebugBlocker . blockDebugger ( new AttackHandlerExample ()); if ( isDebuggerBlocked != 0 ) { // Debug blocker wasn't successful. You can further check the reason of failure. if (( isDebuggerBlocked & DebugBlocker . DEBUGGER_CONNECTED ) != 0 ) { // A debugger is already connected to the application. The application should exit. // ... } } Please refer to the sample project in the directory sample/basic/DebugBlocker for an example implementation of the debug blocker.","title":"Debugger blocking"},{"location":"runtime.html#webview-asset-encryption","text":"You can encrypt the asset files (javascript, html, css,...) that are included in Cordova applications or applications with a WebView. Please refer to the package com.guardsquare.dexguard.runtime.encryption and to the sample projects in the directories samples/basic/Cordova and samples/basic/WebView .","title":"Asset encryption for WebView clients"},{"location":"runtime.html#ssl-pinning","text":"Several modern network libraries like OkHttp already support SSL pinning. The DexGuard runtime library provides some support classes to implement SSL pinning techniques with some older commonly used libraries: org.apache.http.client (certificate pinning), javax.net.ssl (certificate pinning), javax.net.ssl (public key pinning). Additionally, the support classes are hardened against commonly known hooking attacks, making SSL pinning solutions more robust. You can find the support classes in package com.guardsquare.dexguard.runtime.net . The distribution also includes a command line tool to extract the public key hashes from a server certificate ( bin/hash_certificate.[sh,bat] ). For example, you can enable public key pinning for an HttpsURLConnection : // Create a TrustManager that only accepts servers with the specified public key hashes. // This code snippet can be generated by the hash_certificate tool for a given url. // In this example we use the Wikipedia certificate for illustration purposes. com . guardsquare . dexguard . runtime . net . PublicKeyTrustManager trustManager = new com . guardsquare . dexguard . runtime . net . PublicKeyTrustManager ( new String [] { // CN=*.wikipedia.org, O=\"Wikimedia Foundation, Inc.\", L=San Francisco, ST=California, C=US \"8FCF8FD90E88D6E35BA8CB6D8836A2BF\" , } ); SSLPinner sslPinner = new SSLPinner ( trustManager ); // ... // Create the URL connection. URL url = new URL ( urlString ); HttpsURLConnection urlConnection = ( HttpsURLConnection ) url . openConnection (); sslPinner . pinHttpsURLConnection ( urlConnection ); Please refer to the additional examples in the directories samples/basic/SSLPinning and samples/basic/SSLPinningWebView . These projects also illustrate how to harden the SSL pinning code further with DexGuard.","title":"SSL pinning"},{"location":"securekeyboard.html","text":"DexGuard\u2019s optional secure keyboard addon offers a small API with a secure keyboard implementation that is hardened against snooping, e.g. for entering passwords and pin codes. The keyboard prevents malicious software from overlaying it with fake or transparent keyboards that may intercept input events. It additionally provides numeric keypads with randomly positioned numbers, making it hard to deduce pin codes from finger movements or touch coordinates. Limitations \u00b6 The secure keyboard has a basic look and feel that is different from the customized look and feel of the keyboards on most devices. It is only customizable to some extent. The secure keyboard offers fixed sets of basic numeric and alphanumeric keys. This excludes characters such as emojis. While it is visible, the secure keyboard blocks overlays, for example notifications from social apps. It does this to avoid overlay attacks, in which another app might present a fake keyboard. The secure keyboard is not compatible with applications built with the Cordova development framework. Dependencies \u00b6 The addon contains a small Java API providing a secure keyboard manager. You can find the library in the DexGuard distribution at lib/securekeyboard-runtime.aar You should add this AAR as a dependency to your application project. It is self-contained and does not depend on any libraries, other than the standard Java/Android runtime library. Integrating the secure keyboard \u00b6 The main class of the secure keyboard API is the SecureKeyboardManager . You can activate the secure keyboard by creating a SecureKeyboardManager instance and registering all the input fields requiring secure input on it. The onCreate() method of an Activity is typically a good place to do this: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); SecureKeyboardManager skm = new SecureKeyboardManager ( this , true , true , true , true ); // Register all EditText fields in myLayout to the secure keyboard manager. skm . attachTo (( ViewGroup ) findViewById ( R . id . myLayout )); } For the keyboard to behave correctly, you also need to propagate some events from the activity to the keyboard, such as onBackPressed , onPaused , ... Please refer to the Secure Keyboard sample ( samples/addons/SecureKeyboard ) for a complete overview. The secure keyboard API also provides a SecureKeyboardVisibilityListener that allows you to listen to the visibility of the secure keyboard. You can create a listener to execute custom actions based on the secure keyboard being shown or hidden. Customizing the secure keyboard behavior \u00b6 You can control the behavior of the keyboard via flags in the SecureKeyBoardManager constructor: public SecureKeyboardManager ( Activity activity , boolean randomizeNumberPad , boolean randomizeNumberPadOnEveryInput , boolean enableActivityPinning , boolean makeEditTextVisible ); randomizeNumberPad indicates whether or not to randomize the number pad numbers. randomizeNumberPadOnEveryInput indicates whether or not to randomize the number pad numbers again each time an input field is edited. If false, it will only be randomized once per application. enableActivityPinning indicates whether the current activity should be pinned. If true, no other (malicious) activities can be started while the input is edited. This is only available on devices having build version greater than Lollipop (5.0). makeEditTextVisible indicates whether the input field should be repositioned, when blocked by the keyboard. Customizing the secure keyboard style \u00b6 You can control the appearance of the keyboard by overriding various XML attributes. Change keyboard color You can change the secure keyboard color by overriding the attributes \"normalSecureKeyboardColor\" and \"popUpSecureKeyboardColor\" in your res/values/colors.xml file. \"normalSecureKeyboardColor\" defines the color for the normal secure keyboard layout. \"popUpSecureKeyboardColor\" defines the color for the pop-up keyboard that appears when you press and hold a key. Change key text color You can change the key text color of the secure keyboard by overriding the attributes \"normalSecureKeyboardTextColor\" and \"popUpSecureKeyboardTextColor\" in your res/values/colors.xml file. The \"normalSecureKeyboardTextColor\" attribute defines the key text color for the normal secure keyboard. The \"popUpSecureKeyboardTextColor\" attribute defines the key text color for the pop-up secure keyboard that appears when you press and hold a key. Change key text size There is a customized style that defines the key text size of the secure keyboard. <style name= \"secureKeyboardKeyTextStyle\" parent= \"@android:style/Widget.KeyboardView\" > <item name= \"android:keyTextSize\" > 22sp </item> <item name= \"android:labelTextSize\" > 20sp </item> </style> You can create an xml file (with an arbitrary name) and override the Android attributes \"keyTextSize\" and \"labelTextSize\" in the SecureKeyboard's default style, \"secureKeyboardKeyTextSize\". The \"keyTextSize\" attribute defines the text size for keys labeled with individual characters. The \"labelTextSize\" attribute defines the text size for keys that are labeled with more than one character. Customize special Unicode characters The following Unicode characters can be customized by overriding the values of their respective string names in res/values/strings.xml. String name Unicode symbol secure_keyboard_backspace \u232b secure_keyboard_return \u23ce secure_keyboard_shift \u21e7 secure_keyboard_back_button \u25bc Note: Versions of Android below API level 21 do not render some Unicode characters correctly, therefore two different versions of the strings.xml file are defined. The file res/values/strings.xml defines the values for versions of Android below API level 21. The file res/values-v21/strings.xml defines the values for versions of Android using API level 21 and above. Please refer to the API Javadoc and the sample samples/addons/SecureKeyboard for more information.","title":"Secure Keyboard"},{"location":"securekeyboard.html#limitations","text":"The secure keyboard has a basic look and feel that is different from the customized look and feel of the keyboards on most devices. It is only customizable to some extent. The secure keyboard offers fixed sets of basic numeric and alphanumeric keys. This excludes characters such as emojis. While it is visible, the secure keyboard blocks overlays, for example notifications from social apps. It does this to avoid overlay attacks, in which another app might present a fake keyboard. The secure keyboard is not compatible with applications built with the Cordova development framework.","title":"Limitations"},{"location":"securekeyboard.html#dependencies","text":"The addon contains a small Java API providing a secure keyboard manager. You can find the library in the DexGuard distribution at lib/securekeyboard-runtime.aar You should add this AAR as a dependency to your application project. It is self-contained and does not depend on any libraries, other than the standard Java/Android runtime library.","title":"Dependencies"},{"location":"securekeyboard.html#integrating-the-secure-keyboard","text":"The main class of the secure keyboard API is the SecureKeyboardManager . You can activate the secure keyboard by creating a SecureKeyboardManager instance and registering all the input fields requiring secure input on it. The onCreate() method of an Activity is typically a good place to do this: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); SecureKeyboardManager skm = new SecureKeyboardManager ( this , true , true , true , true ); // Register all EditText fields in myLayout to the secure keyboard manager. skm . attachTo (( ViewGroup ) findViewById ( R . id . myLayout )); } For the keyboard to behave correctly, you also need to propagate some events from the activity to the keyboard, such as onBackPressed , onPaused , ... Please refer to the Secure Keyboard sample ( samples/addons/SecureKeyboard ) for a complete overview. The secure keyboard API also provides a SecureKeyboardVisibilityListener that allows you to listen to the visibility of the secure keyboard. You can create a listener to execute custom actions based on the secure keyboard being shown or hidden.","title":"Integrating the secure keyboard"},{"location":"securekeyboard.html#customizing-the-secure-keyboard-behavior","text":"You can control the behavior of the keyboard via flags in the SecureKeyBoardManager constructor: public SecureKeyboardManager ( Activity activity , boolean randomizeNumberPad , boolean randomizeNumberPadOnEveryInput , boolean enableActivityPinning , boolean makeEditTextVisible ); randomizeNumberPad indicates whether or not to randomize the number pad numbers. randomizeNumberPadOnEveryInput indicates whether or not to randomize the number pad numbers again each time an input field is edited. If false, it will only be randomized once per application. enableActivityPinning indicates whether the current activity should be pinned. If true, no other (malicious) activities can be started while the input is edited. This is only available on devices having build version greater than Lollipop (5.0). makeEditTextVisible indicates whether the input field should be repositioned, when blocked by the keyboard.","title":"Customizing the secure keyboard behavior"},{"location":"securekeyboard.html#customizing-the-secure-keyboard-style","text":"You can control the appearance of the keyboard by overriding various XML attributes. Change keyboard color You can change the secure keyboard color by overriding the attributes \"normalSecureKeyboardColor\" and \"popUpSecureKeyboardColor\" in your res/values/colors.xml file. \"normalSecureKeyboardColor\" defines the color for the normal secure keyboard layout. \"popUpSecureKeyboardColor\" defines the color for the pop-up keyboard that appears when you press and hold a key. Change key text color You can change the key text color of the secure keyboard by overriding the attributes \"normalSecureKeyboardTextColor\" and \"popUpSecureKeyboardTextColor\" in your res/values/colors.xml file. The \"normalSecureKeyboardTextColor\" attribute defines the key text color for the normal secure keyboard. The \"popUpSecureKeyboardTextColor\" attribute defines the key text color for the pop-up secure keyboard that appears when you press and hold a key. Change key text size There is a customized style that defines the key text size of the secure keyboard. <style name= \"secureKeyboardKeyTextStyle\" parent= \"@android:style/Widget.KeyboardView\" > <item name= \"android:keyTextSize\" > 22sp </item> <item name= \"android:labelTextSize\" > 20sp </item> </style> You can create an xml file (with an arbitrary name) and override the Android attributes \"keyTextSize\" and \"labelTextSize\" in the SecureKeyboard's default style, \"secureKeyboardKeyTextSize\". The \"keyTextSize\" attribute defines the text size for keys labeled with individual characters. The \"labelTextSize\" attribute defines the text size for keys that are labeled with more than one character. Customize special Unicode characters The following Unicode characters can be customized by overriding the values of their respective string names in res/values/strings.xml. String name Unicode symbol secure_keyboard_backspace \u232b secure_keyboard_return \u23ce secure_keyboard_shift \u21e7 secure_keyboard_back_button \u25bc Note: Versions of Android below API level 21 do not render some Unicode characters correctly, therefore two different versions of the strings.xml file are defined. The file res/values/strings.xml defines the values for versions of Android below API level 21. The file res/values-v21/strings.xml defines the values for versions of Android using API level 21 and above. Please refer to the API Javadoc and the sample samples/addons/SecureKeyboard for more information.","title":"Customizing the secure keyboard style"},{"location":"threatcast.html","text":"Guardsquare's ThreatCast is a mobile app security console that allows real-time threat monitoring of applications protected with DexGuard or iXGuard. It displays detected runtime threats and provides insight into application usage. Tip ThreatCast comes as a Freemium SaaS solution, check out its product page . Before you start \u00b6 First configure the automatic injection of RASP checks for your application. Without this step, no threats will be reported to ThreatCast. Quickstart \u00b6 Enabling support for ThreatCast requires at least: Adding your ThreatCast API key Adding the necessary dependencies to your project. Optionally uploading your ThreatCast mapping file to ThreatCast. A sample application demonstrating the ThreatCast integration can be found under samples/basic/ThreatCastTamperDetection in the DexGuard release zip archive. Configuration \u00b6 Add your ThreatCast API key to your DexGuard configuration as follows: -threatcastapikey YOUR_API_KEY Alternatively, you can put your ThreatCast API key in a system property called \"dexguard.threatcastApiKey\". Dependencies \u00b6 You must include the ThreatCast client library along with the default RASP configuration included for the automatic injection of RASP checks . Both release and debug versions of the ThreatCast client library are available. The debug version contains additional logging to verify your setup and should never be used in the release version of your application . You can find these dependencies in DexGuard release zip or add them through the secure maven repo . Manual Download (Groovy) repositories { flatDir { dirs 'libs' } // For the DexGuard libraries. google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... releaseImplementation ( name: 'dexguard-threatcast-client' , ext: 'aar' ) debugImplementation ( name: 'dexguard-threatcast-client-debug' , ext: 'aar' ) } dexguard { path = '/path/to/dexguard' configurations { release { defaultConfiguration 'dexguard-release-aggressive.pro' defaultConfiguration 'dexguard-rasp.pro' configuration 'dexguard-project.txt' } } } You can find the dependencies at the following locations: Dependency Location ThreatCast debug library ${DexGuardInstallPath}/lib/dexguard-threatcast-client-debug.aar ThreatCast release library ${DexGuardInstallPath}/lib/dexguard-threatcast-client.aar Manual Download (Kotlin) repositories { flatDir { dirs ( \"libs\" ) } // For the DexGuard libraries. google () // For the Android support libraries. () // For any other libraries. } dependencies { // ... releaseImplementation ( mapOf ( \"name\" to \"dexguard-threatcast-client\" , \"ext\" to \"aar\" ) debugImplementation ( mapOf ( \"name\" to \"dexguard-threatcast-client-debug\" , \"ext\" to \"aar\" ) } dexguard { path = \"/path/to/dexguard\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release-aggressive.pro\" ) defaultConfiguration ( \"dexguard-rasp.pro\" ) configuration ( \"dexguard-project.txt\" ) } } } You can find the dependencies at the following locations: Dependency Location ThreatCast debug library ${DexGuardInstallPath}/lib/dexguard-threatcast-client-debug.aar ThreatCast release library ${DexGuardInstallPath}/lib/dexguard-threatcast-client.aar Maven repositories { maven { // For the DexGuard libraries. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" authentication { basic ( BasicAuthentication ) } } google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... releaseImplementation 'com.guardsquare:dexguard-threatcast-client:9.2.7' debugImplementation 'com.guardsquare:dexguard-threatcast-client:9.2.7:debug@aar' } dexguard { version = '9.2.+' configurations { release { defaultConfiguration 'dexguard-release-aggressive.pro' defaultConfiguration 'dexguard-rasp.pro' configuration 'dexguard-project.txt' } } } App User ID \u00b6 In order to make ThreatCast events meaningful and actionable you can provide an app user ID (AUID) that can be used to map events to users. For example, it could be used to take actions related to specific users such as blocking their access. It will also help in identifying cases with positive RASP reports and allow you to, for example, request a user to uninstall a certain suspicious app. Warning Sending the AUID from an app creates the risk of AUID spoofing. A malicious app user could potentially send fake threat data with a spoofed AUID corresponding to another user who is the target of an attack. You should keep in mind that the security of AUIDs cannot be provided by DexGuard/ThreatCast alone. To provide an AUID, you need to implement a method that DexGuard can call to retrieve it and configure the method in your DexGuard config. It will be called every time a threat is detected. A method such as the following getAuid method can be added to the application: Java public class HelloWorldActivity extends Activity { // ... /** * This is an optional DexGuard ThreatCast AUID getter method. This signature must match. * * Any strings used in the getAuid will be automatically encrypted. * * @return A String representing the App User ID (AUID). */ public static String getAuid () { // Implementation of how the AUID is generated and retrieved is left to the app developer. return appUserId ; } } Kotlin class HelloWorldActivity : Activity () { // ... companion object { /** * This is an optional DexGuard ThreatCast AUID getter method. This signature must match. * * Any strings used in the getAuid will be automatically encrypted. * * @return A String representing the App User ID (AUID). */ @JvmStatic fun getAuid (): String { // Implementation of how the AUID is generated and retrieved is left to the app developer. return appUserId } } } along with the following DexGuard configuration to set getAuid as the AUID getter method: - threatcastappuseridgetter class com.example.HelloWorldActivity { public static java.lang.String getAuid (); } Note The method must be static, public and must not contain any wildcard characters. You don't need a -keep rule for the method. Threat location reporting \u00b6 ThreatCast sends check location identifiers along with each threat it reports. To display additional detail information about the location in your code where the threat was detected you can upload a ThreatCast mapping file to your ThreatCast account. Whenever the -printthreatcastmapping <path> option is set, the mapping file is printed to the path <path> , with every DexGuard build. When using our DexGuard Gradle plugin, the file will be automatically named threatcast-mapping.yml and generated in your default mapping output folder. Since the generated file is build specific, you'll need to upload your ThreatCast mapping file with every released app version. Log in to your ThreatCast account, select Options / Manage Apps, select the correct app, and go to the Mappings tab, and upload your mapping file.","title":"Configuration"},{"location":"threatcast.html#before-you-start","text":"First configure the automatic injection of RASP checks for your application. Without this step, no threats will be reported to ThreatCast.","title":"Before you start"},{"location":"threatcast.html#quickstart","text":"Enabling support for ThreatCast requires at least: Adding your ThreatCast API key Adding the necessary dependencies to your project. Optionally uploading your ThreatCast mapping file to ThreatCast. A sample application demonstrating the ThreatCast integration can be found under samples/basic/ThreatCastTamperDetection in the DexGuard release zip archive.","title":"Quickstart"},{"location":"threatcast.html#configuration","text":"Add your ThreatCast API key to your DexGuard configuration as follows: -threatcastapikey YOUR_API_KEY Alternatively, you can put your ThreatCast API key in a system property called \"dexguard.threatcastApiKey\".","title":"Configuration"},{"location":"threatcast.html#dependencies","text":"You must include the ThreatCast client library along with the default RASP configuration included for the automatic injection of RASP checks . Both release and debug versions of the ThreatCast client library are available. The debug version contains additional logging to verify your setup and should never be used in the release version of your application . You can find these dependencies in DexGuard release zip or add them through the secure maven repo . Manual Download (Groovy) repositories { flatDir { dirs 'libs' } // For the DexGuard libraries. google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... releaseImplementation ( name: 'dexguard-threatcast-client' , ext: 'aar' ) debugImplementation ( name: 'dexguard-threatcast-client-debug' , ext: 'aar' ) } dexguard { path = '/path/to/dexguard' configurations { release { defaultConfiguration 'dexguard-release-aggressive.pro' defaultConfiguration 'dexguard-rasp.pro' configuration 'dexguard-project.txt' } } } You can find the dependencies at the following locations: Dependency Location ThreatCast debug library ${DexGuardInstallPath}/lib/dexguard-threatcast-client-debug.aar ThreatCast release library ${DexGuardInstallPath}/lib/dexguard-threatcast-client.aar Manual Download (Kotlin) repositories { flatDir { dirs ( \"libs\" ) } // For the DexGuard libraries. google () // For the Android support libraries. () // For any other libraries. } dependencies { // ... releaseImplementation ( mapOf ( \"name\" to \"dexguard-threatcast-client\" , \"ext\" to \"aar\" ) debugImplementation ( mapOf ( \"name\" to \"dexguard-threatcast-client-debug\" , \"ext\" to \"aar\" ) } dexguard { path = \"/path/to/dexguard\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release-aggressive.pro\" ) defaultConfiguration ( \"dexguard-rasp.pro\" ) configuration ( \"dexguard-project.txt\" ) } } } You can find the dependencies at the following locations: Dependency Location ThreatCast debug library ${DexGuardInstallPath}/lib/dexguard-threatcast-client-debug.aar ThreatCast release library ${DexGuardInstallPath}/lib/dexguard-threatcast-client.aar Maven repositories { maven { // For the DexGuard libraries. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" authentication { basic ( BasicAuthentication ) } } google () // For the Android support libraries. mavenCentral () // For any other libraries. } dependencies { // ... releaseImplementation 'com.guardsquare:dexguard-threatcast-client:9.2.7' debugImplementation 'com.guardsquare:dexguard-threatcast-client:9.2.7:debug@aar' } dexguard { version = '9.2.+' configurations { release { defaultConfiguration 'dexguard-release-aggressive.pro' defaultConfiguration 'dexguard-rasp.pro' configuration 'dexguard-project.txt' } } }","title":"Dependencies"},{"location":"threatcast.html#app-user-id","text":"In order to make ThreatCast events meaningful and actionable you can provide an app user ID (AUID) that can be used to map events to users. For example, it could be used to take actions related to specific users such as blocking their access. It will also help in identifying cases with positive RASP reports and allow you to, for example, request a user to uninstall a certain suspicious app. Warning Sending the AUID from an app creates the risk of AUID spoofing. A malicious app user could potentially send fake threat data with a spoofed AUID corresponding to another user who is the target of an attack. You should keep in mind that the security of AUIDs cannot be provided by DexGuard/ThreatCast alone. To provide an AUID, you need to implement a method that DexGuard can call to retrieve it and configure the method in your DexGuard config. It will be called every time a threat is detected. A method such as the following getAuid method can be added to the application: Java public class HelloWorldActivity extends Activity { // ... /** * This is an optional DexGuard ThreatCast AUID getter method. This signature must match. * * Any strings used in the getAuid will be automatically encrypted. * * @return A String representing the App User ID (AUID). */ public static String getAuid () { // Implementation of how the AUID is generated and retrieved is left to the app developer. return appUserId ; } } Kotlin class HelloWorldActivity : Activity () { // ... companion object { /** * This is an optional DexGuard ThreatCast AUID getter method. This signature must match. * * Any strings used in the getAuid will be automatically encrypted. * * @return A String representing the App User ID (AUID). */ @JvmStatic fun getAuid (): String { // Implementation of how the AUID is generated and retrieved is left to the app developer. return appUserId } } } along with the following DexGuard configuration to set getAuid as the AUID getter method: - threatcastappuseridgetter class com.example.HelloWorldActivity { public static java.lang.String getAuid (); } Note The method must be static, public and must not contain any wildcard characters. You don't need a -keep rule for the method.","title":"App User ID"},{"location":"threatcast.html#threat-location-reporting","text":"ThreatCast sends check location identifiers along with each threat it reports. To display additional detail information about the location in your code where the threat was detected you can upload a ThreatCast mapping file to your ThreatCast account. Whenever the -printthreatcastmapping <path> option is set, the mapping file is printed to the path <path> , with every DexGuard build. When using our DexGuard Gradle plugin, the file will be automatically named threatcast-mapping.yml and generated in your default mapping output folder. Since the generated file is build specific, you'll need to upload your ThreatCast mapping file with every released app version. Log in to your ThreatCast account, select Options / Manage Apps, select the correct app, and go to the Mappings tab, and upload your mapping file.","title":"Threat location reporting"},{"location":"troubleshooting.html","text":"While preparing a configuration for processing your code, you may bump into a few problems. The following sections discuss some common issues and solutions: Quick troubleshooting \u00b6 If you have problems setting up your project: Check if you can build and run a sample, to verify that your environment is set up properly: Linux/macOS ./gradlew assembleRelease adb install build/outputs/apk/release/HelloWorld-release-protected.apk Windows gradlew assembleRelease adb install build\\outputs\\apk\\release\\HelloWorld-release-protected.apk Info By default, the target in the samples is \"android-28\", so you should have the target API for Android 9.0 installed. If the obfuscated application crashes at runtime, you may have to add some custom configuration to dexguard-project.txt . The most common issues you will encounter are: 1. ClassNotFoundException : The application tries to access a class by means of reflection, but DexGuard has removed or obfuscated it. You should explicitly preserve the class. -keep class mypackage.MyClass 2. NoSuchMethodException : The application tries to access a method by means of reflection (for a WebView, for instance), but DexGuard has removed or obfuscated it. You should explicitly preserve the method. -keepclassmembers class mypackage.MyClass { void myMethod ( java.lang.String ); } 3. Resources$NotFoundException : The application tries to access a resource by its name (typically with Resources#getIdentifier ) instead of its numeric identifier, but DexGuard has removed or obfuscated the resource or its name. You should explicitly preserve the resource. -keepresources drawable/my_icon You can look at the generated files bin/proguard/seeds.txt and bin/proguard/usage.txt to check which classes and class members DexGuard has explicitly kept (due to the configuration), or removed (because they appeared unused). Problems while processing \u00b6 Notes and non-fatal warnings \u00b6 DexGuard may print out some notes and non-fatal warnings. You can switch off these notes by specifying the -dontnote option. Note: can't find dynamically referenced class '...' DexGuard can't find a class or interface that your code is accessing by means of introspection. You should consider adding the jar that contains this class. Note: '...' calls '(...)Class.forName(variable).newInstance()' Your code uses reflection to dynamically create class instances, with a construct like (MyClass)Class.forName(variable).newInstance() . Depending on your application, you may need to keep the mentioned classes with an option like -keep class MyClass , or their implementations with an option like -keep class * implements MyClass . Note: '...' accesses a field/method '...' dynamically Your code uses reflection to find a field or a method, with a construct like .getField(\"myField\") . Depending on your application, you may need to figure out where the mentioned class members are defined and keep them with an option like -keep class MyClass { MyFieldType myField; } . Otherwise, DexGuard might remove or obfuscate them. You can switch off these notes by specifying the -dontnote option. Note: '...' calls 'Class.get...' , '...' calls 'Field.get...' , or '...' calls 'Method.get...' Your code uses reflection to access metadata from the code, with an invocation like class.getAnnotations() . You then generally need to preserve optional class file attributes , which DexGuard removes by default. These attributes contain information about annotations, enclosing classes, enclosing methods, etc. In a summary in the log, DexGuard provides a suggested configuration, like -keepattributes *Annotation* . You should only switch off these notes if you're certain the attributes are not necessary. You can switch off these notes by specifying the -dontnote option. Note: '...' calls 'WebView.addJavascriptInterface' for '...' DexGuard lists a number of constructs like webView.addJavascriptInterface(new MyInterfaceClass(), \"myInterfaceName\") . Such a construct means that the Javascript code in the WebView can invoke methods in MyInterfaceClass . You should therefore let DexGuard know not to remove or rename those methods. If the methods have been annotated with @JavascriptInterface (as required as of Android SDK 17), the default configuration for Android will take care of it. Otherwise, you have to keep the methods with an option like -keepclassmembers class MyInterfaceClass { public <methods>; } . You can switch off these notes by specifying the -dontnote option. Note: the configuration refers to the unknown class '...' Your configuration refers to the name of a class that is not present in the program jars or library jars. You should check whether the name is correct. Notably, you should make sure that you always specify fully-qualified names, not forgetting the package names. Note: the configuration keeps the entry point '...', but not the descriptor class '...' Your configuration contains a -keep option to preserve the given method (or field), but no -keep option for the given class that is an argument type or return type in the method's descriptor. You may then want to keep the class too. Otherwise, DexGuard will obfuscate its name, thus changing the method's signature. The method might then become unfindable as an entry point, e.g. if it is part of a public API. You can automatically keep such descriptor classes with the -keep option modifier includedescriptorclasses ( -keep,includedescriptorclasses ...). You can switch off these notes by specifying the -dontnote option. Note: the configuration explicitly specifies '...' to keep library class '...' Your configuration contains a -keep option to preserve the given library class. However, you don't need to keep any library classes. DexGuard always leaves underlying libraries unchanged. You can switch off these notes by specifying the -dontnote option. Note: the configuration doesn't specify which class members to keep for class '...' Your configuration contains a -keepclassmembers / -keepclasseswithmembers option to preserve fields or methods in the given class, but it doesn't specify which fields or methods. This way, the option simply won't have any effect. You probably want to specify one or more fields or methods, as usual between curly braces. You can specify all fields or methods with a wildcard *; . You should also consider whether you just need the more common -keep option, which preserves all specified classes and class members. The overview of all keep options can help. Note: the configuration specifies that none of the methods of class '...' have any side effects Your configuration contains an option -assumenosideeffects to indicate that the specified methods don't have any side effects. However, the configuration tries to match all methods, by using a wildcard like \" *; \". This includes methods from java.lang.Object , such as wait() and notify() . Removing invocations of those methods will most likely break your application. You should list the methods without side effects more conservatively. You can switch off these notes by specifying the -dontnote option. Note: duplicate definition of program/library class Your program jars or library jars contain multiple definitions of the listed classes. DexGuard continues processing as usual, only considering the first definitions. The note may be an indication of some problem though, so it's advisable to remove the duplicates. A convenient way to do so is by specifying filters on the input jars or library jars. The standard Android and DexGuard build processes automatically specify the input jars for you. There may not be an easy way to filter them to remove these notes. You could remove the duplicate classes manually from your libraries. You should also not add libraries to your application that are already part of the Android runtime (notably org.apache.commons.logging.Log , org.w3c.dom , org.xml.sax , org.xmlpull.v1 , org.apache.http , and org.json ). They are possibly inconsistent, and the runtime libraries would get precedence over these anyway. Warning: can't write resource '...' duplicate zip entry Your input jars contain multiple resource files with the same name. DexGuard continues copying the resource files as usual, skipping any files with previously used names. Once more, the warning may be an indication of some problem, so it's advisable to remove the duplicates. A convenient way to do so is by specifying filters on the input jars. There is no option to switch off these warnings. The standard Android and DexGuard build processes automatically specify the input jars for you. There may not be an easy way to filter them to remove these warnings. You could remove the duplicate resource files manually from the input and the libraries. Serious warnings and I/O errors \u00b6 DexGuard may terminate when it encounters parsing errors or I/O errors, or some more serious warnings: Warning: can't find superclass or interface or Warning: can't find referenced class A class in one of your program jars or library jars references a class or interface that is missing from the input. The warning lists both the referencing class(es), and the missing referenced class(es). There can be a few causes, each with their own solutions: If the missing class is referenced from your own code, you may have forgotten to specify an essential library. Just like when compiling all code from scratch, you must specify all libraries that the code is referencing, directly or indirectly. If the library should be processed and included in the output, you should specify it with -injars , otherwise you should specify it with -libraryjars . For example, if DexGuard complains that it can't find a java.lang class, you have to make sure that you are specifying the runtime library of your platform. For Android, it is typically packaged in android.jar . If the missing class is referenced from a pre-compiled third-party library, and your original code runs fine without it, then the missing dependency doesn't seem to hurt. The cleanest solution is to filter out the referencing class or classes from the input, with a filter like -injars myapplication.jar(!somepackage/SomeUnusedReferencingClass.class) \". DexGuard will then skip this class entirely in the input, and it will not bump into the problem of its missing reference. However, you may then have to filter out other classes that are in turn referencing the removed class. In practice, this works best if you can filter out entire unused packages at once, with a wildcard filter like -libraryjars mylibrary.jar(!someunusedpackage/**) . Instead of filtering out the problematic classes, the -ignorewarnings or -dontwarn options can be used to let DexGuard accept that there are classes missing. You should only use these options if you are certain that your application works without them. For example, if you're developing for Android, and DexGuard complains that it can't find a java.awt class, then some library that you are using is referencing java.awt . Android does not have this package, so your application may not be using any java.awt classes anyway. In this case, it's not an issue that they are missing, and you can let DexGuard accept this with \" -dontwarn java.awt.** \". If the missing class is an Android runtime class, you should make sure that you are building against an Android runtime that is sufficiently recent. Error: can't find any super classes of '...' (not even immediate super class '...') Error: can't find common super class of '...' and '...' It seems like you tried to avoid the warnings from the previous paragraph by specifying -ignorewarnings or -dontwarn , but it didn't work out. DexGuard's optimization step and preverification step really need the missing classes to make sense of the code. Preferably, you would solve the problem by adding the missing library, as discussed in the previous paragraph. If you're sure the class that references the missing class isn't used either, you could also try filtering it out from the input, by adding a filter to the corresponding -injars option: -injars myapplication.jar(!somepackage/SomeUnusedClass.class) . As a final solution, you could switch off optimization ( -dontoptimize ) and preverification ( -dontpreverify ). Warning: can't find referenced field/method '...' in program class '...' A program class is referencing a field or method that is missing from another program class. The warning lists both the referencing class, and the missing referenced class member. Your compiled class files are most likely inconsistent. Possibly, some class file didn't get recompiled properly, or some class file was left behind after its source file was removed. Try removing all compiled class files and rebuilding your project. Warning: can't find referenced field/method '...' in library class '...' A program class is referencing a field or method that is missing from a library class. The warning lists both the referencing class, and the missing referenced class member. Your compiled class files are inconsistent with the libraries. You may need to recompile the class files, or otherwise upgrade the libraries to consistent versions. Alternatively, you may get away with ignoring the inconsistency with the options -ignorewarnings or even -dontwarn . For instance if the code contains a class to optionally support recent versions of Android, you can specify \" -dontwarn mypackage.MySupportClass \". Warning: can't find enclosing class/method If there are unresolved references to classes that are defined inside methods in your input, once more, your compiled class files are likely inconsistent. Possibly, some class file didn't get recompiled properly, or some class file was left behind after its source file was removed. Try removing all compiled class files and rebuilding your project. Warning: there were checked files in an Instant App build One or more program classes of an Instant App attempts to perform file-level tamper detection, which is currently unsupported. Warning: library class '...' depends on program class '...' If any of your library classes depend on your program classes, by extending, implementing or just referencing them, your processed code will generally be unusable. Program classes can depend on library classes, but not the other way around. Program classes are processed, while library classes always remain unchanged. It is therefore impossible to adapt references from library classes to program classes, for instance if the program classes are renamed. You should define a clean separation between program code (specified with -injars ) and library code (specified with -libraryjars ). Warning: class file '...' unexpectedly contains class '...' The given class file contains a definition for the given class, but the directory name of the file doesn't correspond to the package name of the class. DexGuard will accept the class definition, but will not write out the processed version. Please make sure to package your input classes correctly. Notably, class files that are in the WEB-INF/classes directory in a WAR should be packaged in a jar and put in the WEB-INF/lib directory. If you don't mind these classes not being written to the output, you can specify the -ignorewarnings option, or even the -dontwarn option. Warning: '...' is not being kept as '...', but remapped to '...' There is a conflict between a -keep option and the mapping file specified with an -applymapping option, in the obfuscation step. The given class name or class member name can't be kept by its original name, as specified in the configuration, but it has to be mapped to the other given name, as specified in the mapping file. You should adapt your configuration, or your mapping file to remove the conflict. Alternatively, if you're sure the renaming won't hurt, you can specify the -ignorewarnings option, or even the -dontwarn option. Warning: field/method '...' can't be mapped to '...' There is a conflict between some new program code and the mapping file specified with an -applymapping option, in the obfuscation step. The given class member can't be mapped to the given name, because it would conflict with another class member that is already being mapped to the same name. This can happen if you are performing incremental obfuscation, and applying an obfuscation mapping file from an initial obfuscation step. For instance, some new class may have been added that extends two existing classes, introducing a conflict in the name space of its class members. If you're sure the class member receiving another name than the one specified won't hurt, you can specify the -ignorewarnings option, or even the -dontwarn option. Note that you should always use the -useuniqueclassmembernames option in the initial obfuscation step, in order to reduce the risk of conflicts. Warning: not encrypting kept class '...' Your configuration contains options -keep and -encryptclasses to keep and to encrypt the given class. This would most likely result in broken code, since an encrypted class is no longer a valid entry point. To avoid problems, the class won't be encrypted. You can suppress this warning by specifying the -dontwarn option. Warning: not encrypting class '...', referenced from a resource file Your configuration contains the option -encryptclasses to encrypt the given class, which is also referenced from a resource file. This would most likely result in broken code, since an encrypted class is no longer a valid entry point. To avoid problems, the class won't be encrypted. You can suppress this warning by specifying the -dontwarn option. Warning: not encrypting class '...', extended by the unencrypted class '...' Your configuration contains the option -encryptclasses to encrypt the given class, but the class is extended from by another, unencrypted class. The former class can't be encrypted either, for technical reasons. You can suppress this warning by specifying the -dontwarn option. Warning: not encrypting class '...', referenced in a method descriptor Your configuration contains the option -encryptclasses to encrypt the given class, but the class is referenced in the descriptor (argument types) of a method that occurs in encrypted and in unencrypted classes. Such a descriptor class can't be encrypted, for technical reasons. You can suppress this warning by specifying the -dontwarn option. Note: not splitting kept class '...' Your configuration contains the -keep and -splitdexfile options to keep and split the given class. This would most likely result in broken code, since a split class is no longer a valid entry point. To avoid problems,the class is not split. You can suppress this note by specifying the -dontnote option. Note: not splitting class '...', referenced from a resource file Your configuration contains the option -splitdexfile to split the given class, which is however also referenced from a resource file. This would most likely result in broken code, since a split class is no longer a valid entry point. To avoid problems, the class is not split. You can suppress this note by specifying the -dontnote option. Note: not splitting class '...', extended by the unsplit class '...' Your configuration contains the option -splitdexfile to split the given class, but the class is extended by another class that is not split. The former class can't be split either, for technical reasons. You can suppress this note by specifying the -dontnote option. Note: not splitting class '...', referenced in a method descriptor Your configuration contains the option -splitdexfile to split the given class, but the class is referenced in the descriptor (argument types) of a method that occurs in split and in unsplit classes. Such a descriptor class can't be split, for technical reasons. You can suppress this note by specifying the -dontnote option. Error: Unsupported class version number You are trying to process class files compiled for a recent version of Java that your copy of DexGuard doesn't support yet. You should check if a new release of DexGuard is available that solves the compatibility issues. IOException: Can't process resource XML file '...' (Not a binary Android resource XML file) You are probably processing an Android library project, while specifying a configuration for an Android application project. Library projects contain Android resource XML files in text form, while application projects contain them in compiled binary form. Mixing up the project type causes parsing problems. For example, in your build.gradle file, you should point to the default configuration dexguard-library-release.pro instead of dexguard-release.pro . Technically, the former contains the option -android (intended for Android libraries), while the latter contains the option -dalvik (intended for Android applications). IOException: Can't write resource ['...'.so]: New string section exceeds the length of the original This is a rare problem, where the combined obfuscated native function names are longer than the original native function names. You can generally work around it by reducing the obfuscation of the JNI methods: -keepclassmembernames class * { native <methods> ; } If this isn't sufficient, you can disable the obfuscation of the JNI methods entirely: -keepclasseswithmembernames , includedescriptorclasses class * { native <methods> ; } If ever necessary, you can leave native libraries untouched with the following configuration, before the default configuration: -adaptresourcefilecontents !lib/**.so The default configurations dexguard-release-conservative.pro and dexguard-library-release-conservative.pro contain these settings. Error: You have to specify -keep options You either forgot to specify -keep options, or you mistyped the class names. DexGuard has to know exactly what you want to keep: an application, an applet, a servlet, a midlet,..., or any combination of these. Without the proper seed specifications, DexGuard will shrink, optimize, or obfuscate all class files away. Error: Expecting class path separator ';' before 'Files\\Java\\ ... ' (in Windows) If the path of your runtime jar contains spaces, like in \"Program Files\", you have to enclose it with single or double quotes, as explained in the section on file names . This is true for all file names containing special characters, on all platforms. Error: Can't read '...' DexGuard can't read the specified file or directory. Double-check that the name is correct in your configuration, that the file is readable, and that it is not corrupt. An additional message \"Unexpected end of ZLIB input stream\" suggests that the file is truncated. You should make sure that the file is complete on disk when DexGuard starts, and that it is not somehow overwritten by DexGuard's own output. Error: Can't write '...' DexGuard can't write the specified file or directory. Double-check that the name is correct in your configuration and that the file is writable. No such property: '...' The DexGuard plugin can't find a property in Gradle or in the Android plugin. You should verify if the versions of the plugins are compatible. If you are using an older version of the Android plugin than the documented version, you should upgrade. If you are using a more recent version, you should check if a new release of DexGuard is available that solves the compatibility issues. Other errors \u00b6 OutOfMemoryError You can try increasing the heap size of the Java virtual machine, with the usual -Xmx options. In Java, specify the option as an argument to the JVM: java -Xmx1024m In Gradle, you can pass this option to DexGuard using the jvmArgs property of the DexGuard Gradle block. You can also reduce the amount of memory that DexGuard needs by removing unnecessary library jars from your configuration, or by filtering out unused library packages and classes. StackOverflowError This error might occur when processing a large code base. In theory, increasing the stack size of the Java virtual machine (with the usual -Xss option) should help. In practice however, the -Xss setting doesn't have any effect on the main thread, due to Sun Bug #4362291 . As a result, this solution will only work when running DexGuard in a different thread. Unexpected error DexGuard has encountered an unexpected condition, typically in the optimization step. It may or may not recover. You should be able to avoid it using the -dontoptimize option. In any case, please report the problem, preferably with the simplest example that causes DexGuard to crash. Otherwise... Maybe your class files are corrupt. See if recompiling them and trying again helps. If not, please report the problem, preferably with the simplest example that causes DexGuard to crash. Unexpected observations after processing \u00b6 If DexGuard seems to run fine, but your processed code doesn't look right, there might be a couple of reasons: Disappearing classes If you are working on Windows and it looks like some classes have disappeared from your output, you should make sure you're not writing your output class files to a directory (or unpacking the output jar). On platforms with case-insensitive file systems, such as Windows, unpacking tools often let class files with similar lower-case and upper-case names overwrite each other. If you really can't switch to a different operating system, you could consider using DexGuard's -dontusemixedcaseclassnames option. You should make sure your class files are in directories that correspond to their package names. DexGuard will read misplaced class files, but it will not write their processed versions. Notably, class files that are in the WEB-INF/classes directory in a WAR should be packaged in a jar and put in the WEB-INF/lib directory. Classes or class members not being kept If DexGuard is not keeping the right classes or class members, make sure you are using fully qualified class names. If the package name of some class is missing, DexGuard won't match the elements that you might be expecting. It may help to double-check for typos too. You can use the -printseeds option to see which elements are being kept. If you are using marker interfaces to keep other classes, the marker interfaces themselves are probably being removed in the shrinking step. You should therefore always explicitly keep any marker interfaces, with an option like -keep interface MyMarkerInterface . Similarly, if you are keeping classes based on annotations, you may have to avoid that the annotation classes themselves are removed in the shrinking step. You should package the annotation classes as a library, or explicitly keep them in your program code with an option like \" -keep @interface * \". Please note that for DexGuard to see runtime-invisible annotations, you currently have to implement the workaround for runtime-invisible annotations . Class names not being obfuscated If the names of some classes in your obfuscated code aren't obfuscated, you should first check all your configuration files. Chances are that some -keep option is preserving the original names. These options may be hiding in your own configuration files or in configuration files from libraries. Furthermore, some class names mentioned in the Android manifest must always be preserved, to avoid compatibility issues when upgrading versions of the app. More specifically, DexGuard automatically keeps the names of exported activities, broadcast receivers and services. You can find the underlying reasons in the Google blog \"Things that cannot change\" . Field names not being obfuscated If the names of some fields in your obfuscated code aren't obfuscated, this may be due to -keep options preserving the original names, for the sake of libraries like GSON. Such libraries perform reflection on the fields. If the names were obfuscated, the resulting JSON strings would come out obfuscated as well, which generally breaks persistence of the data or communication with servers. Method names not being obfuscated If the names of some methods in your obfuscated code aren't obfuscated, this is most likely because they extend or implement method names in the underlying runtime libraries. Since the runtime libraries are not obfuscated, any corresponding names in the application code can't be obfuscated either, since they must remain consistent. Variable names not being obfuscated If the names of the local variables and parameters in your obfuscated code don't look obfuscated, because they suspiciously resemble the names of their types, it's probably because the decompiler that you are using is coming up with those names. DexGuard's obfuscation step does remove the original names entirely, unless you explicitly keep the LocalVariableTable or LocalVariableTypeTable attributes. Strings not being encrypted If you have applied -encryptstrings , but the specified strings are still readable when you disassemble the code, you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. With the -verbose option, DexGuard reports how many strings it has encrypted in the build log. Furthermore, you should check how you have specified the strings: string literals, all the strings in specified classes, all the strings in specified methods, or all the uses of specified string constants. Note that the Java compiler inlines string constants wherever they are used. If you explicitly keep a final string field with -keep , its uses may be encrypted, but its definition is preserved without encryption. Classes not being encrypted If you have applied -encryptclasses , but the specified classes are still readable when you disassemble the code, you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. With the -verbose option, DexGuard reports how many classes it has encrypted in the build log. Due to technical constraints, classes that are created by reflection can't be encrypted. This can be reflection in your application (e.g. for deserialization) or in the Android runtime (e.g. activities, layouts, etc.). DexGuard will avoid encrypting such classes and print out warnings about it. The recommended solution is to move sensitive code to separate (inner) classes and encrypt those. Native libraries not being encrypted If you have applied -encryptnativelibraries , but the specified native libraries are not encrypted (for instance, they still clearly start with \"ELF\"), you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. Furthermore, you should make sure that your code loads each native library with System.loadLibrary(\"mylibrary\") , with the library name specified as a string literal or constant. With the -verbose option, DexGuard then reports in the build log how many native libraries it has encrypted. Assets not being encrypted If you have applied -encryptassetfiles , but the specified assets remain readable inside the processed application, you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. Furthermore, you should make sure that your code loads each asset file with AssetManager#open(\"myfile\") , with the file name specified as a string literal or constant. With the -verbose option, DexGuard then reports in the build log how many asset files it has encrypted. Access to wrong classes reflected If you have applied -accessthroughreflection , using a wildcard class specification together with a member specification, DexGuard will reflect the access to any class matching the class specification, regardless if the member specification matches or not (contrary to other configuration directives). Additionally, all access to matching members is reflected. You should make sure that the class specification only matches classes that need to be accessed through reflection. Library project is not obfuscated when consumed by app If you have applied DexGuard to a library module that is consumed by an application module in the same project, the library module may seem unaffected by DexGuard. This is not the case. What happened is that since the Android gradle plugin v3.0, the library module's aar file is no longer exploded. Instead, the intermediate files are used. Since DexGuard outputs an obfuscated aar, the files the Android gradle plugin uses are not processed by DexGuard. In order to work around this issue, refer to the setup of the AssetEncryptionLibrary and NativeLibraryInLibraryProject samples provided with your DexGuard download. Problems while installing an Android application \u00b6 If DexGuard runs fine, but adb install refuses to install your processed application, it should print out one of the following error messages: Failure [INSTALL_PARSE_FAILED_MANIFEST_MALFORMED] In a custom build process, you need to specify some attribute names that the obfuscation step needs to preserve in the Android manifest file, with the option -keepresourcexmlattributenames . Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES] On Android 2.2 or older, if you also see \"Package ... has no certificates at entry ...; ignoring!\" in the logcat output, your application may contain file names with special UTF-8 characters. You then need to avoid file name dictionaries with such characters (including the default file name dictionary). You can specify or override it with the option -resourcefilenameobfuscationdictionary with your own text file. You can specify an empty file, so DexGuard just continues with a, b, c, etc. File upload has failed for the Samsung app market If you get \"File upload has failed. There is no application ID(PackageName) or Version information(VersionName) in the Android Manifest.xml file you have registered.\" while publishing your Android application on the Samsung app market, then you need to preserve additional XML attribute names . File upload has failed for AirWatch If you get \"System.IndexOutOfRangeException: Index was outside the bounds of the array.\" while publishing your Android application to AirWatch, then you need to preserve additional XML attribute names: -keepresourcexmlattributenames manifest/package,manifest/versionName and add the following to your gradle.properties in the root project folder: android.enableAapt2 = false systemProp.encode.resourcexml.utf16 = true Problems at runtime \u00b6 If DexGuard runs fine, but your processed application doesn't work, there might be several reasons: Stack traces without class names or line numbers If your stack traces don't contain any class names or lines numbers, even though you are keeping the proper attributes, make sure this debugging information is present in your compiled code to start with. Notably the Ant javac task has debugging information switched off by default. NoClassDefFoundError Your class path is probably incorrect. It should at least contain all library jars, and your processed program jar. ClassNotFoundException Your code is probably calling Class.forName , trying to create the missing class dynamically. DexGuard can only detect constant name arguments, like Class.forName(\"com.example.MyClass\") . For variable name arguments like Class.forName(someClass) , you have to keep all possible classes using the appropriate -keep option, e.g. -keep class com.example.MyClass or -keep class * implements com.example.MyInterface . While setting up your configuration, you can specify the option -addconfigurationdebugging to help track down these cases at runtime and let the instrumented code suggest settings for them. NoSuchFieldException Your code is probably calling something like myClass.getField , trying to find some field dynamically. Since DexGuard can't always detect this automatically, you have to keep the missing field using the appropriate -keep option, e.g. \" -keepclassmembers class mypackage.MyClass { int myField; } \". While setting up your configuration, you can specify the option -addconfigurationdebugging to help track down these cases at run-time and let the instrumented code suggest settings for them. NoSuchMethodException Your code is probably calling something like myClass.getMethod , trying to find some method dynamically. Since DexGuard can't always detect this automatically, you have to keep the missing method using the appropriate -keep option, e.g. -keepclassmembers class com.example.MyClass { void myMethod(); } . While setting up your configuration, you can specify the option -addconfigurationdebugging to help track down these cases at run-time and let the instrumented code suggest settings for them. UnsatisfiedLinkError: Couldn't load '...': findLibrary returned null Your code is failing to load or find a native library from bytecode. DexGuard may have shrunk the native library, since it can't always detect all usages automatically. You have to keep the native library using the appropriate -keepresourcefiles option, e.g. -keepresourcefiles lib/*/libexample.so . Failed registering methods for '...' A native library in your application is calling RegisterNatives , trying to link JNI methods (in bytecode) with JNI functions (in native code). The call generally uses hard-coded method names. However, DexGuard can't detect and handle such calls automatically, so it may have obfuscated these method names in the bytecode. The call then fails. Like with any reflection, you need to preserve the referenced method names using the appropriate -keep option, e.g. -keep class package.MyJniClass { native <methods>; } . MissingResourceException or NullPointerException Your processed code may be unable to find some resource files. DexGuard simply copies resource files over from the input jars to the output jars. Their names and contents remain unchanged, unless you specify the options -adaptresourcefilenames and/or -adaptresourcefilecontents . Furthermore, directory entries in jar files aren't copied, unless you specify the option -keepdirectories . Note that Sun advises against calling Class.getResource() for directories (Sun Bug #4761949]( http://bugs.sun.com/view_bug.do?bug_id=4761949 )). Resources$NotFoundException: Resource ID #0x0 Your Android application is probably calling resources.getIdentifier , resources.getValue , resources.getDrawable , or a similar method that retrieves a resource by its name and type. Just like with reflection on class names, you have to keep this resource with its original name, using the appropriate -keepresources option, e.g. -keepresources drawable/my_icon or -keepresources layout/* . Whenever possible in your code, you should reference resources by their more efficient numeric identifiers from the R classes, which don't require any configuration. Fragment$InstantiationException You may be encrypting a Fragment class in your Android application. When DexGuard encrypts classes, it makes sure that they are decrypted the first time they are instantiated or accessed. This is not possible for classes that are instantiated through reflection, such as Fragment classes. A workaround may be to access the class early on in the application, e.g. Class c = MyFragment.class; This should let the application decrypt and load the class before the Android support classes try to access it. FileNotFoundException Your Android application may be calling assetManager.open , assetManager.openFd , or a similar method that retrieves an asset file. DexGuard can't always detect this automatically. Just like with reflection on resources, you then have to keep this asset with its original name, using the appropriate -keepresourcefiles option, e.g. -keepresourcefiles assets/my_icon.png . ArrayStoreException: sun.reflect.annotation.EnumConstantNotPresentExceptionProxy You are probably running code that has been processed for Android on a Java virtual machine. If the code contains annotations with obfuscated enum values, the Java VM and the Android VM behave differently in a subtle way. If you do want to test such processed code on a Java VM, you should preserve the names of the enum types: -keepnames enum * . Disappearing annotations By default, the obfuscation step removes all annotations. If your application relies on annotations to function properly, you should explicitly keep them with -keepattributes *Annotation* . Preserving runtime-invisible annotations By default, D8/R8 strips runtime-invisible annotations when building a release configuration. As a consequence, these annotations will not be visible to DexGuard when post-processing. This may be a problem when using annotation based DexGuard configuration or when using DexGuard with Espresso testing . In such cases, you can instruct D8/R8 to not strip the annotations by making the following changes to your build.gradle file: Groovy buildTypes { release { ... // Enable R8 for the build type. minifyEnabled true // Supply the configuration detailed below. proguardFile \"r8-rules.pro\" } ... } Kotlin buildTypes { getByName ( \"release\" ) { ... // Enable R8 for the build type. isMinifyEnabled = true // Supply the configuration detailed below. proguardFile ( \"r8-rules.pro\" ) } ... } The configuration that is supplied to R8 this way instructs it to do nothing and causes the runtime-invisible annotations to not be stripped. # r8-rules.pro -dontobfuscate -dontoptimize -dontshrink Please note that this workaround is the only exception where minifyEnabled should be set to true on a DexGuard-enabled build type. For all other DexGuard-enabled build types, make sure to set minifyEnabled to false. Invalid or corrupt jarfile You are probably starting your application with the java option -jar instead of the option -classpath . The java virtual machine returns with this error message if your jar doesn't contain a manifest file ( META-INF/MANIFEST.MF ), if the manifest file doesn't specify a main class ( Main-Class: ...), or if the jar doesn't contain this main class. You should then make sure that the input jar contains a valid manifest file to start with, that this manifest file is the one that is copied (the first manifest file that is encountered), and that the main class is kept in your configuration, InvalidJarIndexException: Invalid index At least one of your processed jar files contains an index file META-INF/INDEX.LIST , listing all class files in the jar. DexGuard by default copies files like these unchanged. DexGuard may however remove or rename classes, thus invalidating the file. You should filter the index file out of the input ( -injars in.jar(!META-INF/INDEX.LIST) ) or update the file after having applied DexGuard ( jar -i out.jar ). Disappearing loops If your code contains empty busy-waiting loops, DexGuard's optimization step may remove them. More specifically, this happens if a loop continuously checks the value of a non-volatile field that is changed in a different thread. The specifications of the Java Virtual Machine require that you always mark fields that are accessed across different threads without further synchronization as volatile . If this is not possible for some reason, you'll have to switch off optimization using the -dontoptimize option. SecurityException: SHA1 digest error You may have forgotten to sign your program jar after having processed it with DexGuard. ClassCastException: class not an enum IllegalArgumentException: class not an enum type You should make sure you're preserving the special methods of enumeration types, which the runtime environment calls by introspection. The required options are shown in the examples . ArrayStoreException: sun.reflect.annotation.EnumConstantNotPresentExceptionProxy You are probably processing annotations involving enumerations. You should make sure you're preserving the special methods of the enumeration type, as shown in the examples. IllegalArgumentException: methods with same signature but incompatible return types You are probably running some code that has been obfuscated with the -overloadaggressively option. The class java.lang.reflect.Proxy can't handle classes that contain methods with the same names and signatures, but different return types. Its method newProxyInstance then throws this exception. You can avoid the problem by not using the option. CompilerError: duplicate addition You are probably compiling or running some code that has been obfuscated with the -overloadaggressively option. This option triggers a bug in sun.tools.java.MethodSet.add in Sun's JDK 1.2.2, which is used for (dynamic) compilation. You should avoid this option. ClassFormatError: repetitive field name/signature You are probably processing some code that has been obfuscated before with the -overloadaggressively option. You should use the same option again in the second processing round. ClassFormatError: Invalid index in LocalVariableTable in class file If you are keeping the LocalVariableTable or LocalVariableTypeTable attributes, DexGuard's optimizing step is sometimes unable to update them consistently. You should let the obfuscation step remove these attributes or disable the optimization step. NullPointerException: create returned null (Dagger) IllegalStateException: Module adapter for class ... could not be loaded. Please ensure that code generation was run for this module. IllegalStateException: Could not load class ... needed for binding members/... Dagger 1 relies on reflection to combine annotated base classes and their corresponding generated classes. DexGuard's default configuration already preserves the generated classes, but you still preserve the annotated base classes in your project-specific configuration. This is explained in some more detail in the Dagger example . VerifyError Verification errors when executing a program are almost certainly the result of a bug in the optimization step of DexGuard. Make sure you are using the latest version. You should be able to work around the problem by using the -dontoptimize option. Problems with Espresso tests \u00b6 This is a collection of the most common errors that occur when applying DexGuard to your Espresso test and how you can fix them. Please make sure your tests work without DexGuard first and that you have read the best practices section on applying DexGuard to your Espresso tests before you read any further. No tests found. This usually means that your test classes are not in the form that your test runner expects (e.g. don't inherit from TestCase or lack @Test annotations). This is caused by the fact that DexGuard's shrinking has removed a part of the standard library from your application which Espresso depends on. Including the dexguard-espresso.pro default configuration should prevent this from happening. NoClassDefFoundError , NoSuchFieldError or NoSuchMethodError These errors usually mean that you use functionality from the application under test in your Espresso test. Avoiding this is the preferred solution, but if that's not possible adding the appropriate keep rules to the application being tested will solve your problem. Resources$NotFoundException This exception usually means that a resource you reference in your Espresso test has been optimized by DexGuard and can no longer be found as a result. Ideally, you avoid this situation entirely, but if you cannot, using the dexguard-espresso-no-resource-optimizations.pro will likely resolve the issue. AmbiguousViewMatcherException , NoMatchingViewException or DefaultFailureHandler$AssertionFailedWithCauseError: 'with string from resource id: ...' doesn't match the selected view These messages mean Espresso is unable to get the right view for the current test. This is likely caused by the resource optimizations DexGuard performs on them. Including the dexguard-espresso-no-resource-optimizations.pro default configuration should solve the problem. IncompatibleClassChangeError When you get this error it means DexGuard optimized a part of the code in your application that you are trying to access in your test. This is discouraged, but can be solved by including the dexguard-espresso-aggressive-optimizations.pro default configuration which will disable the specific optimization causing this error. Failed to find the generated JsonAdapter class for class This error occurs when using Moshi codegen which tries to access generated classes through reflection. Include /lib/dexguard-moshi.pro in your configuration file to fix this issue.","title":"Overview"},{"location":"troubleshooting.html#quick-troubleshooting","text":"If you have problems setting up your project: Check if you can build and run a sample, to verify that your environment is set up properly: Linux/macOS ./gradlew assembleRelease adb install build/outputs/apk/release/HelloWorld-release-protected.apk Windows gradlew assembleRelease adb install build\\outputs\\apk\\release\\HelloWorld-release-protected.apk Info By default, the target in the samples is \"android-28\", so you should have the target API for Android 9.0 installed. If the obfuscated application crashes at runtime, you may have to add some custom configuration to dexguard-project.txt . The most common issues you will encounter are: 1. ClassNotFoundException : The application tries to access a class by means of reflection, but DexGuard has removed or obfuscated it. You should explicitly preserve the class. -keep class mypackage.MyClass 2. NoSuchMethodException : The application tries to access a method by means of reflection (for a WebView, for instance), but DexGuard has removed or obfuscated it. You should explicitly preserve the method. -keepclassmembers class mypackage.MyClass { void myMethod ( java.lang.String ); } 3. Resources$NotFoundException : The application tries to access a resource by its name (typically with Resources#getIdentifier ) instead of its numeric identifier, but DexGuard has removed or obfuscated the resource or its name. You should explicitly preserve the resource. -keepresources drawable/my_icon You can look at the generated files bin/proguard/seeds.txt and bin/proguard/usage.txt to check which classes and class members DexGuard has explicitly kept (due to the configuration), or removed (because they appeared unused).","title":"Quick troubleshooting"},{"location":"troubleshooting.html#processing","text":"","title":"Problems while processing"},{"location":"troubleshooting.html#notes","text":"DexGuard may print out some notes and non-fatal warnings. You can switch off these notes by specifying the -dontnote option. Note: can't find dynamically referenced class '...' DexGuard can't find a class or interface that your code is accessing by means of introspection. You should consider adding the jar that contains this class. Note: '...' calls '(...)Class.forName(variable).newInstance()' Your code uses reflection to dynamically create class instances, with a construct like (MyClass)Class.forName(variable).newInstance() . Depending on your application, you may need to keep the mentioned classes with an option like -keep class MyClass , or their implementations with an option like -keep class * implements MyClass . Note: '...' accesses a field/method '...' dynamically Your code uses reflection to find a field or a method, with a construct like .getField(\"myField\") . Depending on your application, you may need to figure out where the mentioned class members are defined and keep them with an option like -keep class MyClass { MyFieldType myField; } . Otherwise, DexGuard might remove or obfuscate them. You can switch off these notes by specifying the -dontnote option. Note: '...' calls 'Class.get...' , '...' calls 'Field.get...' , or '...' calls 'Method.get...' Your code uses reflection to access metadata from the code, with an invocation like class.getAnnotations() . You then generally need to preserve optional class file attributes , which DexGuard removes by default. These attributes contain information about annotations, enclosing classes, enclosing methods, etc. In a summary in the log, DexGuard provides a suggested configuration, like -keepattributes *Annotation* . You should only switch off these notes if you're certain the attributes are not necessary. You can switch off these notes by specifying the -dontnote option. Note: '...' calls 'WebView.addJavascriptInterface' for '...' DexGuard lists a number of constructs like webView.addJavascriptInterface(new MyInterfaceClass(), \"myInterfaceName\") . Such a construct means that the Javascript code in the WebView can invoke methods in MyInterfaceClass . You should therefore let DexGuard know not to remove or rename those methods. If the methods have been annotated with @JavascriptInterface (as required as of Android SDK 17), the default configuration for Android will take care of it. Otherwise, you have to keep the methods with an option like -keepclassmembers class MyInterfaceClass { public <methods>; } . You can switch off these notes by specifying the -dontnote option. Note: the configuration refers to the unknown class '...' Your configuration refers to the name of a class that is not present in the program jars or library jars. You should check whether the name is correct. Notably, you should make sure that you always specify fully-qualified names, not forgetting the package names. Note: the configuration keeps the entry point '...', but not the descriptor class '...' Your configuration contains a -keep option to preserve the given method (or field), but no -keep option for the given class that is an argument type or return type in the method's descriptor. You may then want to keep the class too. Otherwise, DexGuard will obfuscate its name, thus changing the method's signature. The method might then become unfindable as an entry point, e.g. if it is part of a public API. You can automatically keep such descriptor classes with the -keep option modifier includedescriptorclasses ( -keep,includedescriptorclasses ...). You can switch off these notes by specifying the -dontnote option. Note: the configuration explicitly specifies '...' to keep library class '...' Your configuration contains a -keep option to preserve the given library class. However, you don't need to keep any library classes. DexGuard always leaves underlying libraries unchanged. You can switch off these notes by specifying the -dontnote option. Note: the configuration doesn't specify which class members to keep for class '...' Your configuration contains a -keepclassmembers / -keepclasseswithmembers option to preserve fields or methods in the given class, but it doesn't specify which fields or methods. This way, the option simply won't have any effect. You probably want to specify one or more fields or methods, as usual between curly braces. You can specify all fields or methods with a wildcard *; . You should also consider whether you just need the more common -keep option, which preserves all specified classes and class members. The overview of all keep options can help. Note: the configuration specifies that none of the methods of class '...' have any side effects Your configuration contains an option -assumenosideeffects to indicate that the specified methods don't have any side effects. However, the configuration tries to match all methods, by using a wildcard like \" *; \". This includes methods from java.lang.Object , such as wait() and notify() . Removing invocations of those methods will most likely break your application. You should list the methods without side effects more conservatively. You can switch off these notes by specifying the -dontnote option. Note: duplicate definition of program/library class Your program jars or library jars contain multiple definitions of the listed classes. DexGuard continues processing as usual, only considering the first definitions. The note may be an indication of some problem though, so it's advisable to remove the duplicates. A convenient way to do so is by specifying filters on the input jars or library jars. The standard Android and DexGuard build processes automatically specify the input jars for you. There may not be an easy way to filter them to remove these notes. You could remove the duplicate classes manually from your libraries. You should also not add libraries to your application that are already part of the Android runtime (notably org.apache.commons.logging.Log , org.w3c.dom , org.xml.sax , org.xmlpull.v1 , org.apache.http , and org.json ). They are possibly inconsistent, and the runtime libraries would get precedence over these anyway. Warning: can't write resource '...' duplicate zip entry Your input jars contain multiple resource files with the same name. DexGuard continues copying the resource files as usual, skipping any files with previously used names. Once more, the warning may be an indication of some problem, so it's advisable to remove the duplicates. A convenient way to do so is by specifying filters on the input jars. There is no option to switch off these warnings. The standard Android and DexGuard build processes automatically specify the input jars for you. There may not be an easy way to filter them to remove these warnings. You could remove the duplicate resource files manually from the input and the libraries.","title":"Notes and non-fatal warnings"},{"location":"troubleshooting.html#warnings","text":"DexGuard may terminate when it encounters parsing errors or I/O errors, or some more serious warnings: Warning: can't find superclass or interface or Warning: can't find referenced class A class in one of your program jars or library jars references a class or interface that is missing from the input. The warning lists both the referencing class(es), and the missing referenced class(es). There can be a few causes, each with their own solutions: If the missing class is referenced from your own code, you may have forgotten to specify an essential library. Just like when compiling all code from scratch, you must specify all libraries that the code is referencing, directly or indirectly. If the library should be processed and included in the output, you should specify it with -injars , otherwise you should specify it with -libraryjars . For example, if DexGuard complains that it can't find a java.lang class, you have to make sure that you are specifying the runtime library of your platform. For Android, it is typically packaged in android.jar . If the missing class is referenced from a pre-compiled third-party library, and your original code runs fine without it, then the missing dependency doesn't seem to hurt. The cleanest solution is to filter out the referencing class or classes from the input, with a filter like -injars myapplication.jar(!somepackage/SomeUnusedReferencingClass.class) \". DexGuard will then skip this class entirely in the input, and it will not bump into the problem of its missing reference. However, you may then have to filter out other classes that are in turn referencing the removed class. In practice, this works best if you can filter out entire unused packages at once, with a wildcard filter like -libraryjars mylibrary.jar(!someunusedpackage/**) . Instead of filtering out the problematic classes, the -ignorewarnings or -dontwarn options can be used to let DexGuard accept that there are classes missing. You should only use these options if you are certain that your application works without them. For example, if you're developing for Android, and DexGuard complains that it can't find a java.awt class, then some library that you are using is referencing java.awt . Android does not have this package, so your application may not be using any java.awt classes anyway. In this case, it's not an issue that they are missing, and you can let DexGuard accept this with \" -dontwarn java.awt.** \". If the missing class is an Android runtime class, you should make sure that you are building against an Android runtime that is sufficiently recent. Error: can't find any super classes of '...' (not even immediate super class '...') Error: can't find common super class of '...' and '...' It seems like you tried to avoid the warnings from the previous paragraph by specifying -ignorewarnings or -dontwarn , but it didn't work out. DexGuard's optimization step and preverification step really need the missing classes to make sense of the code. Preferably, you would solve the problem by adding the missing library, as discussed in the previous paragraph. If you're sure the class that references the missing class isn't used either, you could also try filtering it out from the input, by adding a filter to the corresponding -injars option: -injars myapplication.jar(!somepackage/SomeUnusedClass.class) . As a final solution, you could switch off optimization ( -dontoptimize ) and preverification ( -dontpreverify ). Warning: can't find referenced field/method '...' in program class '...' A program class is referencing a field or method that is missing from another program class. The warning lists both the referencing class, and the missing referenced class member. Your compiled class files are most likely inconsistent. Possibly, some class file didn't get recompiled properly, or some class file was left behind after its source file was removed. Try removing all compiled class files and rebuilding your project. Warning: can't find referenced field/method '...' in library class '...' A program class is referencing a field or method that is missing from a library class. The warning lists both the referencing class, and the missing referenced class member. Your compiled class files are inconsistent with the libraries. You may need to recompile the class files, or otherwise upgrade the libraries to consistent versions. Alternatively, you may get away with ignoring the inconsistency with the options -ignorewarnings or even -dontwarn . For instance if the code contains a class to optionally support recent versions of Android, you can specify \" -dontwarn mypackage.MySupportClass \". Warning: can't find enclosing class/method If there are unresolved references to classes that are defined inside methods in your input, once more, your compiled class files are likely inconsistent. Possibly, some class file didn't get recompiled properly, or some class file was left behind after its source file was removed. Try removing all compiled class files and rebuilding your project. Warning: there were checked files in an Instant App build One or more program classes of an Instant App attempts to perform file-level tamper detection, which is currently unsupported. Warning: library class '...' depends on program class '...' If any of your library classes depend on your program classes, by extending, implementing or just referencing them, your processed code will generally be unusable. Program classes can depend on library classes, but not the other way around. Program classes are processed, while library classes always remain unchanged. It is therefore impossible to adapt references from library classes to program classes, for instance if the program classes are renamed. You should define a clean separation between program code (specified with -injars ) and library code (specified with -libraryjars ). Warning: class file '...' unexpectedly contains class '...' The given class file contains a definition for the given class, but the directory name of the file doesn't correspond to the package name of the class. DexGuard will accept the class definition, but will not write out the processed version. Please make sure to package your input classes correctly. Notably, class files that are in the WEB-INF/classes directory in a WAR should be packaged in a jar and put in the WEB-INF/lib directory. If you don't mind these classes not being written to the output, you can specify the -ignorewarnings option, or even the -dontwarn option. Warning: '...' is not being kept as '...', but remapped to '...' There is a conflict between a -keep option and the mapping file specified with an -applymapping option, in the obfuscation step. The given class name or class member name can't be kept by its original name, as specified in the configuration, but it has to be mapped to the other given name, as specified in the mapping file. You should adapt your configuration, or your mapping file to remove the conflict. Alternatively, if you're sure the renaming won't hurt, you can specify the -ignorewarnings option, or even the -dontwarn option. Warning: field/method '...' can't be mapped to '...' There is a conflict between some new program code and the mapping file specified with an -applymapping option, in the obfuscation step. The given class member can't be mapped to the given name, because it would conflict with another class member that is already being mapped to the same name. This can happen if you are performing incremental obfuscation, and applying an obfuscation mapping file from an initial obfuscation step. For instance, some new class may have been added that extends two existing classes, introducing a conflict in the name space of its class members. If you're sure the class member receiving another name than the one specified won't hurt, you can specify the -ignorewarnings option, or even the -dontwarn option. Note that you should always use the -useuniqueclassmembernames option in the initial obfuscation step, in order to reduce the risk of conflicts. Warning: not encrypting kept class '...' Your configuration contains options -keep and -encryptclasses to keep and to encrypt the given class. This would most likely result in broken code, since an encrypted class is no longer a valid entry point. To avoid problems, the class won't be encrypted. You can suppress this warning by specifying the -dontwarn option. Warning: not encrypting class '...', referenced from a resource file Your configuration contains the option -encryptclasses to encrypt the given class, which is also referenced from a resource file. This would most likely result in broken code, since an encrypted class is no longer a valid entry point. To avoid problems, the class won't be encrypted. You can suppress this warning by specifying the -dontwarn option. Warning: not encrypting class '...', extended by the unencrypted class '...' Your configuration contains the option -encryptclasses to encrypt the given class, but the class is extended from by another, unencrypted class. The former class can't be encrypted either, for technical reasons. You can suppress this warning by specifying the -dontwarn option. Warning: not encrypting class '...', referenced in a method descriptor Your configuration contains the option -encryptclasses to encrypt the given class, but the class is referenced in the descriptor (argument types) of a method that occurs in encrypted and in unencrypted classes. Such a descriptor class can't be encrypted, for technical reasons. You can suppress this warning by specifying the -dontwarn option. Note: not splitting kept class '...' Your configuration contains the -keep and -splitdexfile options to keep and split the given class. This would most likely result in broken code, since a split class is no longer a valid entry point. To avoid problems,the class is not split. You can suppress this note by specifying the -dontnote option. Note: not splitting class '...', referenced from a resource file Your configuration contains the option -splitdexfile to split the given class, which is however also referenced from a resource file. This would most likely result in broken code, since a split class is no longer a valid entry point. To avoid problems, the class is not split. You can suppress this note by specifying the -dontnote option. Note: not splitting class '...', extended by the unsplit class '...' Your configuration contains the option -splitdexfile to split the given class, but the class is extended by another class that is not split. The former class can't be split either, for technical reasons. You can suppress this note by specifying the -dontnote option. Note: not splitting class '...', referenced in a method descriptor Your configuration contains the option -splitdexfile to split the given class, but the class is referenced in the descriptor (argument types) of a method that occurs in split and in unsplit classes. Such a descriptor class can't be split, for technical reasons. You can suppress this note by specifying the -dontnote option. Error: Unsupported class version number You are trying to process class files compiled for a recent version of Java that your copy of DexGuard doesn't support yet. You should check if a new release of DexGuard is available that solves the compatibility issues. IOException: Can't process resource XML file '...' (Not a binary Android resource XML file) You are probably processing an Android library project, while specifying a configuration for an Android application project. Library projects contain Android resource XML files in text form, while application projects contain them in compiled binary form. Mixing up the project type causes parsing problems. For example, in your build.gradle file, you should point to the default configuration dexguard-library-release.pro instead of dexguard-release.pro . Technically, the former contains the option -android (intended for Android libraries), while the latter contains the option -dalvik (intended for Android applications). IOException: Can't write resource ['...'.so]: New string section exceeds the length of the original This is a rare problem, where the combined obfuscated native function names are longer than the original native function names. You can generally work around it by reducing the obfuscation of the JNI methods: -keepclassmembernames class * { native <methods> ; } If this isn't sufficient, you can disable the obfuscation of the JNI methods entirely: -keepclasseswithmembernames , includedescriptorclasses class * { native <methods> ; } If ever necessary, you can leave native libraries untouched with the following configuration, before the default configuration: -adaptresourcefilecontents !lib/**.so The default configurations dexguard-release-conservative.pro and dexguard-library-release-conservative.pro contain these settings. Error: You have to specify -keep options You either forgot to specify -keep options, or you mistyped the class names. DexGuard has to know exactly what you want to keep: an application, an applet, a servlet, a midlet,..., or any combination of these. Without the proper seed specifications, DexGuard will shrink, optimize, or obfuscate all class files away. Error: Expecting class path separator ';' before 'Files\\Java\\ ... ' (in Windows) If the path of your runtime jar contains spaces, like in \"Program Files\", you have to enclose it with single or double quotes, as explained in the section on file names . This is true for all file names containing special characters, on all platforms. Error: Can't read '...' DexGuard can't read the specified file or directory. Double-check that the name is correct in your configuration, that the file is readable, and that it is not corrupt. An additional message \"Unexpected end of ZLIB input stream\" suggests that the file is truncated. You should make sure that the file is complete on disk when DexGuard starts, and that it is not somehow overwritten by DexGuard's own output. Error: Can't write '...' DexGuard can't write the specified file or directory. Double-check that the name is correct in your configuration and that the file is writable. No such property: '...' The DexGuard plugin can't find a property in Gradle or in the Android plugin. You should verify if the versions of the plugins are compatible. If you are using an older version of the Android plugin than the documented version, you should upgrade. If you are using a more recent version, you should check if a new release of DexGuard is available that solves the compatibility issues.","title":"Serious warnings and I/O errors"},{"location":"troubleshooting.html#other-errors","text":"OutOfMemoryError You can try increasing the heap size of the Java virtual machine, with the usual -Xmx options. In Java, specify the option as an argument to the JVM: java -Xmx1024m In Gradle, you can pass this option to DexGuard using the jvmArgs property of the DexGuard Gradle block. You can also reduce the amount of memory that DexGuard needs by removing unnecessary library jars from your configuration, or by filtering out unused library packages and classes. StackOverflowError This error might occur when processing a large code base. In theory, increasing the stack size of the Java virtual machine (with the usual -Xss option) should help. In practice however, the -Xss setting doesn't have any effect on the main thread, due to Sun Bug #4362291 . As a result, this solution will only work when running DexGuard in a different thread. Unexpected error DexGuard has encountered an unexpected condition, typically in the optimization step. It may or may not recover. You should be able to avoid it using the -dontoptimize option. In any case, please report the problem, preferably with the simplest example that causes DexGuard to crash. Otherwise... Maybe your class files are corrupt. See if recompiling them and trying again helps. If not, please report the problem, preferably with the simplest example that causes DexGuard to crash.","title":"Other errors"},{"location":"troubleshooting.html#afterprocessing","text":"If DexGuard seems to run fine, but your processed code doesn't look right, there might be a couple of reasons: Disappearing classes If you are working on Windows and it looks like some classes have disappeared from your output, you should make sure you're not writing your output class files to a directory (or unpacking the output jar). On platforms with case-insensitive file systems, such as Windows, unpacking tools often let class files with similar lower-case and upper-case names overwrite each other. If you really can't switch to a different operating system, you could consider using DexGuard's -dontusemixedcaseclassnames option. You should make sure your class files are in directories that correspond to their package names. DexGuard will read misplaced class files, but it will not write their processed versions. Notably, class files that are in the WEB-INF/classes directory in a WAR should be packaged in a jar and put in the WEB-INF/lib directory. Classes or class members not being kept If DexGuard is not keeping the right classes or class members, make sure you are using fully qualified class names. If the package name of some class is missing, DexGuard won't match the elements that you might be expecting. It may help to double-check for typos too. You can use the -printseeds option to see which elements are being kept. If you are using marker interfaces to keep other classes, the marker interfaces themselves are probably being removed in the shrinking step. You should therefore always explicitly keep any marker interfaces, with an option like -keep interface MyMarkerInterface . Similarly, if you are keeping classes based on annotations, you may have to avoid that the annotation classes themselves are removed in the shrinking step. You should package the annotation classes as a library, or explicitly keep them in your program code with an option like \" -keep @interface * \". Please note that for DexGuard to see runtime-invisible annotations, you currently have to implement the workaround for runtime-invisible annotations . Class names not being obfuscated If the names of some classes in your obfuscated code aren't obfuscated, you should first check all your configuration files. Chances are that some -keep option is preserving the original names. These options may be hiding in your own configuration files or in configuration files from libraries. Furthermore, some class names mentioned in the Android manifest must always be preserved, to avoid compatibility issues when upgrading versions of the app. More specifically, DexGuard automatically keeps the names of exported activities, broadcast receivers and services. You can find the underlying reasons in the Google blog \"Things that cannot change\" . Field names not being obfuscated If the names of some fields in your obfuscated code aren't obfuscated, this may be due to -keep options preserving the original names, for the sake of libraries like GSON. Such libraries perform reflection on the fields. If the names were obfuscated, the resulting JSON strings would come out obfuscated as well, which generally breaks persistence of the data or communication with servers. Method names not being obfuscated If the names of some methods in your obfuscated code aren't obfuscated, this is most likely because they extend or implement method names in the underlying runtime libraries. Since the runtime libraries are not obfuscated, any corresponding names in the application code can't be obfuscated either, since they must remain consistent. Variable names not being obfuscated If the names of the local variables and parameters in your obfuscated code don't look obfuscated, because they suspiciously resemble the names of their types, it's probably because the decompiler that you are using is coming up with those names. DexGuard's obfuscation step does remove the original names entirely, unless you explicitly keep the LocalVariableTable or LocalVariableTypeTable attributes. Strings not being encrypted If you have applied -encryptstrings , but the specified strings are still readable when you disassemble the code, you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. With the -verbose option, DexGuard reports how many strings it has encrypted in the build log. Furthermore, you should check how you have specified the strings: string literals, all the strings in specified classes, all the strings in specified methods, or all the uses of specified string constants. Note that the Java compiler inlines string constants wherever they are used. If you explicitly keep a final string field with -keep , its uses may be encrypted, but its definition is preserved without encryption. Classes not being encrypted If you have applied -encryptclasses , but the specified classes are still readable when you disassemble the code, you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. With the -verbose option, DexGuard reports how many classes it has encrypted in the build log. Due to technical constraints, classes that are created by reflection can't be encrypted. This can be reflection in your application (e.g. for deserialization) or in the Android runtime (e.g. activities, layouts, etc.). DexGuard will avoid encrypting such classes and print out warnings about it. The recommended solution is to move sensitive code to separate (inner) classes and encrypt those. Native libraries not being encrypted If you have applied -encryptnativelibraries , but the specified native libraries are not encrypted (for instance, they still clearly start with \"ELF\"), you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. Furthermore, you should make sure that your code loads each native library with System.loadLibrary(\"mylibrary\") , with the library name specified as a string literal or constant. With the -verbose option, DexGuard then reports in the build log how many native libraries it has encrypted. Assets not being encrypted If you have applied -encryptassetfiles , but the specified assets remain readable inside the processed application, you should make sure that obfuscation is enabled. Obfuscation is only the default for release builds. Furthermore, you should make sure that your code loads each asset file with AssetManager#open(\"myfile\") , with the file name specified as a string literal or constant. With the -verbose option, DexGuard then reports in the build log how many asset files it has encrypted. Access to wrong classes reflected If you have applied -accessthroughreflection , using a wildcard class specification together with a member specification, DexGuard will reflect the access to any class matching the class specification, regardless if the member specification matches or not (contrary to other configuration directives). Additionally, all access to matching members is reflected. You should make sure that the class specification only matches classes that need to be accessed through reflection. Library project is not obfuscated when consumed by app If you have applied DexGuard to a library module that is consumed by an application module in the same project, the library module may seem unaffected by DexGuard. This is not the case. What happened is that since the Android gradle plugin v3.0, the library module's aar file is no longer exploded. Instead, the intermediate files are used. Since DexGuard outputs an obfuscated aar, the files the Android gradle plugin uses are not processed by DexGuard. In order to work around this issue, refer to the setup of the AssetEncryptionLibrary and NativeLibraryInLibraryProject samples provided with your DexGuard download.","title":"Unexpected observations after processing"},{"location":"troubleshooting.html#installing","text":"If DexGuard runs fine, but adb install refuses to install your processed application, it should print out one of the following error messages: Failure [INSTALL_PARSE_FAILED_MANIFEST_MALFORMED] In a custom build process, you need to specify some attribute names that the obfuscation step needs to preserve in the Android manifest file, with the option -keepresourcexmlattributenames . Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES] On Android 2.2 or older, if you also see \"Package ... has no certificates at entry ...; ignoring!\" in the logcat output, your application may contain file names with special UTF-8 characters. You then need to avoid file name dictionaries with such characters (including the default file name dictionary). You can specify or override it with the option -resourcefilenameobfuscationdictionary with your own text file. You can specify an empty file, so DexGuard just continues with a, b, c, etc. File upload has failed for the Samsung app market If you get \"File upload has failed. There is no application ID(PackageName) or Version information(VersionName) in the Android Manifest.xml file you have registered.\" while publishing your Android application on the Samsung app market, then you need to preserve additional XML attribute names . File upload has failed for AirWatch If you get \"System.IndexOutOfRangeException: Index was outside the bounds of the array.\" while publishing your Android application to AirWatch, then you need to preserve additional XML attribute names: -keepresourcexmlattributenames manifest/package,manifest/versionName and add the following to your gradle.properties in the root project folder: android.enableAapt2 = false systemProp.encode.resourcexml.utf16 = true","title":"Problems while installing an Android application"},{"location":"troubleshooting.html#runtime","text":"If DexGuard runs fine, but your processed application doesn't work, there might be several reasons: Stack traces without class names or line numbers If your stack traces don't contain any class names or lines numbers, even though you are keeping the proper attributes, make sure this debugging information is present in your compiled code to start with. Notably the Ant javac task has debugging information switched off by default. NoClassDefFoundError Your class path is probably incorrect. It should at least contain all library jars, and your processed program jar. ClassNotFoundException Your code is probably calling Class.forName , trying to create the missing class dynamically. DexGuard can only detect constant name arguments, like Class.forName(\"com.example.MyClass\") . For variable name arguments like Class.forName(someClass) , you have to keep all possible classes using the appropriate -keep option, e.g. -keep class com.example.MyClass or -keep class * implements com.example.MyInterface . While setting up your configuration, you can specify the option -addconfigurationdebugging to help track down these cases at runtime and let the instrumented code suggest settings for them. NoSuchFieldException Your code is probably calling something like myClass.getField , trying to find some field dynamically. Since DexGuard can't always detect this automatically, you have to keep the missing field using the appropriate -keep option, e.g. \" -keepclassmembers class mypackage.MyClass { int myField; } \". While setting up your configuration, you can specify the option -addconfigurationdebugging to help track down these cases at run-time and let the instrumented code suggest settings for them. NoSuchMethodException Your code is probably calling something like myClass.getMethod , trying to find some method dynamically. Since DexGuard can't always detect this automatically, you have to keep the missing method using the appropriate -keep option, e.g. -keepclassmembers class com.example.MyClass { void myMethod(); } . While setting up your configuration, you can specify the option -addconfigurationdebugging to help track down these cases at run-time and let the instrumented code suggest settings for them. UnsatisfiedLinkError: Couldn't load '...': findLibrary returned null Your code is failing to load or find a native library from bytecode. DexGuard may have shrunk the native library, since it can't always detect all usages automatically. You have to keep the native library using the appropriate -keepresourcefiles option, e.g. -keepresourcefiles lib/*/libexample.so . Failed registering methods for '...' A native library in your application is calling RegisterNatives , trying to link JNI methods (in bytecode) with JNI functions (in native code). The call generally uses hard-coded method names. However, DexGuard can't detect and handle such calls automatically, so it may have obfuscated these method names in the bytecode. The call then fails. Like with any reflection, you need to preserve the referenced method names using the appropriate -keep option, e.g. -keep class package.MyJniClass { native <methods>; } . MissingResourceException or NullPointerException Your processed code may be unable to find some resource files. DexGuard simply copies resource files over from the input jars to the output jars. Their names and contents remain unchanged, unless you specify the options -adaptresourcefilenames and/or -adaptresourcefilecontents . Furthermore, directory entries in jar files aren't copied, unless you specify the option -keepdirectories . Note that Sun advises against calling Class.getResource() for directories (Sun Bug #4761949]( http://bugs.sun.com/view_bug.do?bug_id=4761949 )). Resources$NotFoundException: Resource ID #0x0 Your Android application is probably calling resources.getIdentifier , resources.getValue , resources.getDrawable , or a similar method that retrieves a resource by its name and type. Just like with reflection on class names, you have to keep this resource with its original name, using the appropriate -keepresources option, e.g. -keepresources drawable/my_icon or -keepresources layout/* . Whenever possible in your code, you should reference resources by their more efficient numeric identifiers from the R classes, which don't require any configuration. Fragment$InstantiationException You may be encrypting a Fragment class in your Android application. When DexGuard encrypts classes, it makes sure that they are decrypted the first time they are instantiated or accessed. This is not possible for classes that are instantiated through reflection, such as Fragment classes. A workaround may be to access the class early on in the application, e.g. Class c = MyFragment.class; This should let the application decrypt and load the class before the Android support classes try to access it. FileNotFoundException Your Android application may be calling assetManager.open , assetManager.openFd , or a similar method that retrieves an asset file. DexGuard can't always detect this automatically. Just like with reflection on resources, you then have to keep this asset with its original name, using the appropriate -keepresourcefiles option, e.g. -keepresourcefiles assets/my_icon.png . ArrayStoreException: sun.reflect.annotation.EnumConstantNotPresentExceptionProxy You are probably running code that has been processed for Android on a Java virtual machine. If the code contains annotations with obfuscated enum values, the Java VM and the Android VM behave differently in a subtle way. If you do want to test such processed code on a Java VM, you should preserve the names of the enum types: -keepnames enum * . Disappearing annotations By default, the obfuscation step removes all annotations. If your application relies on annotations to function properly, you should explicitly keep them with -keepattributes *Annotation* . Preserving runtime-invisible annotations By default, D8/R8 strips runtime-invisible annotations when building a release configuration. As a consequence, these annotations will not be visible to DexGuard when post-processing. This may be a problem when using annotation based DexGuard configuration or when using DexGuard with Espresso testing . In such cases, you can instruct D8/R8 to not strip the annotations by making the following changes to your build.gradle file: Groovy buildTypes { release { ... // Enable R8 for the build type. minifyEnabled true // Supply the configuration detailed below. proguardFile \"r8-rules.pro\" } ... } Kotlin buildTypes { getByName ( \"release\" ) { ... // Enable R8 for the build type. isMinifyEnabled = true // Supply the configuration detailed below. proguardFile ( \"r8-rules.pro\" ) } ... } The configuration that is supplied to R8 this way instructs it to do nothing and causes the runtime-invisible annotations to not be stripped. # r8-rules.pro -dontobfuscate -dontoptimize -dontshrink Please note that this workaround is the only exception where minifyEnabled should be set to true on a DexGuard-enabled build type. For all other DexGuard-enabled build types, make sure to set minifyEnabled to false. Invalid or corrupt jarfile You are probably starting your application with the java option -jar instead of the option -classpath . The java virtual machine returns with this error message if your jar doesn't contain a manifest file ( META-INF/MANIFEST.MF ), if the manifest file doesn't specify a main class ( Main-Class: ...), or if the jar doesn't contain this main class. You should then make sure that the input jar contains a valid manifest file to start with, that this manifest file is the one that is copied (the first manifest file that is encountered), and that the main class is kept in your configuration, InvalidJarIndexException: Invalid index At least one of your processed jar files contains an index file META-INF/INDEX.LIST , listing all class files in the jar. DexGuard by default copies files like these unchanged. DexGuard may however remove or rename classes, thus invalidating the file. You should filter the index file out of the input ( -injars in.jar(!META-INF/INDEX.LIST) ) or update the file after having applied DexGuard ( jar -i out.jar ). Disappearing loops If your code contains empty busy-waiting loops, DexGuard's optimization step may remove them. More specifically, this happens if a loop continuously checks the value of a non-volatile field that is changed in a different thread. The specifications of the Java Virtual Machine require that you always mark fields that are accessed across different threads without further synchronization as volatile . If this is not possible for some reason, you'll have to switch off optimization using the -dontoptimize option. SecurityException: SHA1 digest error You may have forgotten to sign your program jar after having processed it with DexGuard. ClassCastException: class not an enum IllegalArgumentException: class not an enum type You should make sure you're preserving the special methods of enumeration types, which the runtime environment calls by introspection. The required options are shown in the examples . ArrayStoreException: sun.reflect.annotation.EnumConstantNotPresentExceptionProxy You are probably processing annotations involving enumerations. You should make sure you're preserving the special methods of the enumeration type, as shown in the examples. IllegalArgumentException: methods with same signature but incompatible return types You are probably running some code that has been obfuscated with the -overloadaggressively option. The class java.lang.reflect.Proxy can't handle classes that contain methods with the same names and signatures, but different return types. Its method newProxyInstance then throws this exception. You can avoid the problem by not using the option. CompilerError: duplicate addition You are probably compiling or running some code that has been obfuscated with the -overloadaggressively option. This option triggers a bug in sun.tools.java.MethodSet.add in Sun's JDK 1.2.2, which is used for (dynamic) compilation. You should avoid this option. ClassFormatError: repetitive field name/signature You are probably processing some code that has been obfuscated before with the -overloadaggressively option. You should use the same option again in the second processing round. ClassFormatError: Invalid index in LocalVariableTable in class file If you are keeping the LocalVariableTable or LocalVariableTypeTable attributes, DexGuard's optimizing step is sometimes unable to update them consistently. You should let the obfuscation step remove these attributes or disable the optimization step. NullPointerException: create returned null (Dagger) IllegalStateException: Module adapter for class ... could not be loaded. Please ensure that code generation was run for this module. IllegalStateException: Could not load class ... needed for binding members/... Dagger 1 relies on reflection to combine annotated base classes and their corresponding generated classes. DexGuard's default configuration already preserves the generated classes, but you still preserve the annotated base classes in your project-specific configuration. This is explained in some more detail in the Dagger example . VerifyError Verification errors when executing a program are almost certainly the result of a bug in the optimization step of DexGuard. Make sure you are using the latest version. You should be able to work around the problem by using the -dontoptimize option.","title":"Problems at runtime"},{"location":"troubleshooting.html#espresso","text":"This is a collection of the most common errors that occur when applying DexGuard to your Espresso test and how you can fix them. Please make sure your tests work without DexGuard first and that you have read the best practices section on applying DexGuard to your Espresso tests before you read any further. No tests found. This usually means that your test classes are not in the form that your test runner expects (e.g. don't inherit from TestCase or lack @Test annotations). This is caused by the fact that DexGuard's shrinking has removed a part of the standard library from your application which Espresso depends on. Including the dexguard-espresso.pro default configuration should prevent this from happening. NoClassDefFoundError , NoSuchFieldError or NoSuchMethodError These errors usually mean that you use functionality from the application under test in your Espresso test. Avoiding this is the preferred solution, but if that's not possible adding the appropriate keep rules to the application being tested will solve your problem. Resources$NotFoundException This exception usually means that a resource you reference in your Espresso test has been optimized by DexGuard and can no longer be found as a result. Ideally, you avoid this situation entirely, but if you cannot, using the dexguard-espresso-no-resource-optimizations.pro will likely resolve the issue. AmbiguousViewMatcherException , NoMatchingViewException or DefaultFailureHandler$AssertionFailedWithCauseError: 'with string from resource id: ...' doesn't match the selected view These messages mean Espresso is unable to get the right view for the current test. This is likely caused by the resource optimizations DexGuard performs on them. Including the dexguard-espresso-no-resource-optimizations.pro default configuration should solve the problem. IncompatibleClassChangeError When you get this error it means DexGuard optimized a part of the code in your application that you are trying to access in your test. This is discouraged, but can be solved by including the dexguard-espresso-aggressive-optimizations.pro default configuration which will disable the specific optimization causing this error. Failed to find the generated JsonAdapter class for class This error occurs when using Moshi codegen which tries to access generated classes through reflection. Include /lib/dexguard-moshi.pro in your configuration file to fix this issue.","title":"Problems with Espresso tests"},{"location":"usage.html","text":"DexGuard is compatible with ProGuard configuration. The sections below provide more details, with the new options compared to ProGuard highlighted . Input/Output Options \u00b6 @ filename Short for ' -include filename '. -include filename Recursively reads configuration options from the given file filename . -basedirectory directoryname Specifies the base directory for all subsequent relative file names in these configuration arguments or this configuration file. -injars [, feature_name ] class_path Specifies the input jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories) of the application to be processed. The class files in these jars will be processed and written to the output jars. By default, any non-class files will be copied without changes. Please be aware of any temporary files (e.g. created by IDEs), especially if you are reading your input files straight from directories. An optional feature name specifies how the contents should be grouped and packaged, notably for dynamic features in Android app bundles. The entries in the class path can be filtered, as explained in the filters section. For better readability, class path entries can be specified using multiple -injars options. -outjars class_path Specifies the names of the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). The processed input of the preceding -injars options will be written to the named jars. This allows you to collect the contents of groups of input jars into corresponding groups of output jars. In addition, the output entries can be filtered, as explained in the filters section. Each processed class file or resource file is then written to the first output entry with a matching filter, within the group of output jars. You must avoid letting the output files overwrite any input files. For better readability, class path entries can be specified using multiple -outjars options. Without any -outjars options, no jars will be written. -libraryjars class_path Specifies the library jars (or apks, aabs, aars, wars, ears, jmods, zips, directories) of the application to be processed. The files in these jars will not be included in the output jars. The specified library jars should at least contain the class files that are extended by application class files. Library class files that are only called needn't be present, although their presence can improve the results of the optimization step. The entries in the class path can be filtered, as explained in the filters section. For better readability, class path entries can be specified using multiple -libraryjars options. Please note that the boot path and the class path set for running DexGuard are not considered when looking for library classes. This means that you explicitly have to specify the run-time jar that your code will use. -pluginjars class_path Specifies jars containing DexGuard encryption plugin implementations. When specified, DexGuard will use plugin implementations from these jars for encrypting resources in the processed application/library. If unspecified, DexGuard will use its own default encryption implementations. The Encryption Plugins page contains more details on how to implement and use your own DexGuard plugins. This option is only useful in combination with one or more of the following encryption options: -encryptstrings , -encryptnativelibraries , -encryptassetfiles and -encryptresourcefiles . -skipnonpubliclibraryclasses Specifies to skip non-public classes while reading library jars, to speed up processing and reduce memory usage of DexGuard. By default, DexGuard reads non-public and public library classes alike. However, non-public classes are often not relevant, if they don't affect the actual program code in the input jars. Ignoring them then speeds up DexGuard, without affecting the output. Unfortunately, some libraries, including recent JSE run-time libraries, contain non-public library classes that are extended by public library classes. You then can't use this option. DexGuard will print out warnings if it can't find classes due to this option being set. -dontskipnonpubliclibraryclasses Specifies not to ignore non-public library classes. As of version 4.5, this is the default setting. -dontskipnonpubliclibraryclassmembers Specifies not to ignore package visible library class members (fields and methods). By default, DexGuard skips these class members while parsing library classes, as program classes will generally not refer to them. Sometimes however, program classes reside in the same packages as library classes, and they do refer to their package visible class members. In those cases, it can be useful to actually read the class members, in order to make sure the processed code remains consistent. -keepdirectories [ directory_filter ] Specifies the directories to be kept in the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). By default, directory entries are removed. This reduces the jar size, but it may break your program if the code tries to find them with constructs like \" com.example.MyClass.class.getResource(\"\") \". You'll then want to keep the directory corresponding to the package, \" -keepdirectories com.example \". If the option is specified without a filter, all directories are kept. With a filter, only matching directories are kept. For instance, \" -keepdirectories mydirectory \" matches the specified directory, \" -keepdirectories mydirectory/* \" matches its immediate subdirectories, and \" -keepdirectories mydirectory/** \" matches all of its subdirectories. -multidex Deprecated: this option is now applied automatically. Specifies that classes should split across multiple dex files, if the main classes.dex file has grown beyond the constraints of the dex format. The typical breaking point is more than 64K method IDs, triggered by large external libraries. The corresponding warning sign from the dx compiler is \"Unable to execute dex: method ID not in [0, 0xffff]: 65536\"). This option relies on the Android run-time and the optional Android multidex support library to glue the dex files back together when the application is run. This means that you should still add a dependency on com.android.support:multidex:* in your project, and let your Android manifest or application refer to it. Only applicable when targeting Android with the -dalvik option. Performance tip: Dynamically loading classes this way introduces some overhead when the application is started. You should preferably check if the shrinking step doesn't reduce the code to an acceptable size again. Note that you can also apply shrinking in debug builds\u2014see the documentation for the various plugins. -printmaindexlist [ filename ] Specifies to print the list of classes that are placed into the main dex and why they need to be stored there. The list is printed to the standard output or to the given file. Only applicable when the application has multiple dex files. -splitdexfile class_filter Specifies classes that should be put in a separate dex file. Each instance of this option results in a separate dex file, so you generally want to specify classes in a comma-separated list. This option automatically inserts the necessary code to lazily load the split dex files, the first time they are accessed at run-time. This option provides more control than regular multidexing, and the resulting dex files are loaded lazily instead of eagerly. You don't need the Android multidex support library in your project. Only applicable when targeting Android with the -dalvik option. Performance tip: Dynamically loading classes this way and then accessing them by reflection introduces some overhead, mostly when the classes are first accessed. You should preferably check if the shrinking step doesn't reduce the code to an acceptable size again. Note that you can also apply shrinking in debug builds\u2014see the documentation for the various plugins. Performance tip: Every reference from the main dex file to a separate dex file carries some overhead, due to reflection. If performance is important for these references, you can reduce the overhead by accessing classes through interfaces that are not in separate dex files. Counter-indication: it is currently not possible to encrypt classes that have direct references to classes in separate dex files. You may need to consider this when deciding which classes to split. Counter-indication: loading classes from a separate dex file will only work on Android 4.0 devices or later (API level 14+). -instantappfeature name activity URL Specifies one feature of an Instant App to be created. If you specify one or more of these options, DexGuard automatically transforms your traditional installed app into an Instant App, based on all specified features. It partitions and adapts the code, the Android manifest files, and the resources. It packages the features in separate apk files. Each option specifies a feature name, the activity that is the entry point of the feature, and a URL to access the feature. If many features depend on an activity, you can specify an empty feature name ('') to package it in the base apk. If two activities are closely related, you can also package them in the same feature. The Instant App example illustrates the option. -performanceprofile filename Optimizes the startup performance, given a .hprof file that is extracted right after starting the app. To obtain the correct .hprof file, do the following: Connect your mobile device to your computer and make sure you have root access. Build a debug version of your application (that is, without obfuscation, optimization and shrinking enabled). Launch your app. When your app completely started up, extract the .hprof file by performing the following steps in the terminal: Get the process id of the app. (column pid) adb shell ps | grep YOUR_APP_NAME Dump the .hprof file. You need root access for this step. adb root adb shell am dumpheap PROCESS_ID /data/local/tmp/performance.hprof Pull this file from the device to your computer. adb pull /data/local/tmp/performance.hprof Finally, move performance.hprof to your app directory and pass the filename to the -performanceprofile option. After performing these steps, you can turn obfuscation, optimization and shrinking back on. Extracting the .hprof file needs to be repeated every time you change your program in a significant way. Note : Any potential performance increase will only be noticeable on old devices (4.4 and earlier), for apps with noticeable startup times and strictly for \"cold starts\", meaning that application files are not yet loaded into memory. Counter-indication: this optimization will have no effect for classes that are encrypted or for applications that use packing (-pack). -splitdimensions [ dimension_filter ] Deprecated: split dimensions are now automatically read directly from an app bundle so this option is no longer required Specifies a filter for dimensions of resources (\"abi\", \"density\", \"language\"). The default is to split along these three dimensions. -dontcompress [ file_filter ] Specifies files that should not be compressed in output archives (apks, aabs, jars, aars, wars, ears, jmods, or zips). Some environments or applications may then be able to map the files into memory. For example, the Android run-time can access uncompressed images or raw files efficiently, reducing the amount of RAM that is required. This option is generally combined with the -zipalign option below, to specify the optimal alignment of the data. The option is mostly relevant when processing an Android app or creating an app bundle. -zipalign n Specifies the number of bytes to which uncompressed data in output archives should be aligned. For example, the Android run-time can access uncompressed images or raw files efficiently if they are aligned to 4 bytes. This option should be combined with the -dontcompress option above, to specify which files should not be compressed. -target version Specifies the version number to be set in the processed class files. The version number can be one of 1.0 ,..., 1.9 , or the more recent short numbers 5 ,..., 12 . By default, the version numbers of the class files are left unchanged. You can also downgrade class files to older versions than Java 8. DexGuard changes their version numbers and backports Java 8 constructs. DexGuard generally doesn't backport changes in the Java runtime, except for the Java 8 stream API and the Java 8 date API, if you add the backported libraries net.sourceforge.streamsupport and org.threeten as input, respectively. Note: When targeting Android with the -dalvik option, this option has the following effect: 1.6: targeting Android 4.3- devices, backporting any Java 7/8 features. 1.7 (default): targeting Android 4.4+ devices, backporting Java 8 features. 1.8: targeting Android 7.0+ devices, backporting lambda expressions, using Dex format 037. Note: When building Android applications, the property minSdkVersion contained in the AndroidManifest.xml is taken into account to properly setup the target setting. In general it is not necessary to specify a custom -target setting on your own. -forceprocessing Specifies to process the input, even if the output seems up to date. The up-to-dateness test is based on a comparison of the date stamps of the specified input, output, and configuration files or directories. Keep Options for Code \u00b6 -keep [ , modifier ,...] class_specification Specifies classes and class members (fields and methods) to be preserved as entry points to your code. For example, in order to keep an application , you can specify the main class along with its main method. In order to process a library , you should specify all publicly accessible elements. -keepclassmembers [ , modifier ,...] class_specification Specifies class members to be preserved, if their classes are preserved as well. For example, you may want to keep all serialization fields and methods of classes that implement the Serializable interface. -keepclasseswithmembers [ , modifier ,...] class_specification Specifies classes and class members to be preserved, on the condition that all of the specified class members are present. For example, you may want to keep all applications that have a main method, without having to list them explicitly. -keepnames class_specification Short for -keep , allowshrinking class_specification Specifies classes and class members whose names are to be preserved, if they aren't removed in the shrinking phase. For example, you may want to keep all class names of classes that implement the Serializable interface, so that the processed code remains compatible with any originally serialized classes. Classes that aren't used at all can still be removed. Only applicable when obfuscating. -keepclassmembernames class_specification Short for -keepclassmembers , allowshrinking class_specification Specifies class members whose names are to be preserved, if they aren't removed in the shrinking phase. For example, you may want to preserve the name of the synthetic class$ methods when processing a library compiled by JDK 1.2 or older, so obfuscators can detect it again when processing an application that uses the processed library (although DexGuard itself doesn't need this). Only applicable when obfuscating. -keepclasseswithmembernames class_specification Short for -keepclasseswithmembers , allowshrinking class_specification Specifies classes and class members whose names are to be preserved, on the condition that all of the specified class members are present after the shrinking phase. For example, you may want to keep all native method names and the names of their classes, so that the processed code can still link with the native library code. Native methods that aren't used at all can still be removed. If a class file is used, but none of its native methods are, its name will still be obfuscated. Only applicable when obfuscating. -keepcode [ , modifier ,...] class_specification Specifies code attributes to be preserved, if their methods are preserved as well. -if class_specification Specifies classes and class members that must be present to activate the subsequent keep option ( -keep , -keepclassmembers ,...). The condition and the subsequent keep option can share wildcards and references to wildcards. For example, you can keep classes on the condition that classes with related names exist in your project, with frameworks like Dagger and Butterknife . -printseeds [ filename ] Specifies to exhaustively list classes and class members matched by the various -keep options. The list is printed to the standard output or to the given file. The list can be useful to verify if the intended class members are really found, especially if you're using wildcards. For example, you may want to list all the application classes that you are keeping. Keep Options for Resources \u00b6 -keepresourcefiles [ file_filter ] Specifies the Android resource files that should be preserved, with their original names. By default, the shrinking step removes Android resource files that appear to be unused. The obfuscation step additionally renames the remaining files with short, meaningless names or names from a given dictionary. With this option, you can preserve matching files, with their original names. The filter is applied to the complete file names, typically of the form \"res/**\", for instance res/xml/config.xml . For example, you should keep the AndroidManifest.xml file as the main entry point when processing an Android application . You may also need to apply the option if your code relies on the extension of the file name. Only applicable when processing Android applications or libraries. Counter-indication: Android internally makes a distinction between resources and the corresponding resource files. They can even have different names. If your code accesses a resource file through some sort of reflection, you generally need to preserve its resource with the -keepresources option, rather than this option. -keepresources [ , keepresources_modifier ,...] [ name_filter ] Specifies the Android resources that should be preserved, with their original names. Binary Android resource files are stored in the res directory and contain an index of all defined resources (XML files, image files, etc). Each resource is identified by a name and by a numeric identifier. The shrinking step removes resources that appear to be unused. The optimization step may inline unambiguous resources in code and in other resources, as well as remove duplicate and empty resources. The obfuscation step additionally obfuscates their names. With this option, you can preserve resources with their original names, if they are still required, for instance for Resources#getIdentifier(name, type, package) . The filter is applied to strings of the form \"type/name\", for example \" layout/main \" or \" drawable/icon \". Only applicable when processing Android applications or libraries. -keepresourcexmlelements [ name_filter ] Specifies the XML elements in the Android resource XML files that should be preserved. The optimization step may inline XML information in the Java code, for example the values of meta-data entries in the Android Manifest. When shrinking is enabled, DexGuard may additionally remove XML elements that are no longer being used after the inlining step. With this option, you can preserve XML elements, if they are still required. The filter is applied to strings of the form \"element/element/.../element\", based on the names of the nested XML elements. By appending an attribute filter of the form \"@name=value\", you can additionally refine the filter to only match elements that have an attribute with the given name and value. -keepresourcexmlattributenames [ name_filter ] Specifies the Android resource XML attribute names that should be preserved. Binary Android resource XML files are stored in the res directory and contain XML elements with attributes. Each attribute is identified by a name, but often also by a numeric identifier. The obfuscation step can then remove the name. you can preserve it with this option, if it is still required, for AttributeSet#getAttributeValue(namespace, name) or AttributeSet#getAttributeName(id) . The filter is applied to strings of the form \"element/element/.../element/attribute\", based on the names of the nested elements and the attributes. For example, the Android runtime somewhat arbitrarily requires the names of the attributes \"installLocation\", \"versionCode\", and \"name\", in some elements in the Android manifest file. The examples for processing a complete Android application and for publishing on the Samsung app market show how they are preserved. Only applicable when obfuscating Android code. Shrinking Options \u00b6 -dontshrink Specifies not to shrink the input. By default, DexGuard shrinks the code and resources: it removes all unused classes, class members, resources, resource files, assets files, and native libraries. It only keeps the ones listed by the various -keep options, and the ones on which they depend, directly or indirectly. It also applies a shrinking step after each optimization step, since some optimizations may open up the possibility to remove more code and resources. -printusage [ filename ] Specifies to list dead code of the input class files. The list is printed to the standard output or to the given file. For example, you can list the unused code of an application . Only applicable when shrinking. -printresourceusage [ filename ] Specifies to list unused resources in the input APK. The list is printed to the standard output or to the given file. Only applicable when shrinking and targeting Android with -dalvik . -whyareyoukeeping class_specification Specifies to print details on why the given classes and class members are being kept in the shrinking step. This can be useful if you are wondering why some given element is present in the output. In general, there can be many different reasons. This option prints the shortest chain of methods to a specified seed or entry point, for each specified class and class member. In the current implementation, the shortest chain that is printed out may sometimes contain circular deductions -- these do not reflect the actual shrinking process. If the -verbose option if specified, the traces include full field and method signatures. Only applicable when shrinking. Optimization Options \u00b6 -dontoptimize Specifies not to optimize the input class files. By default, DexGuard optimizes all code and resources. It inlines and merges classes, class members, resources, and resource files. It optimizes all methods at a bytecode level. -optimizations optimization_filter Specifies the optimizations to be enabled and disabled, at a more fine-grained level. Only applicable when optimizing. This is an expert option. -optimizationpasses n Specifies the number of optimization passes to be performed. By default, a single pass is performed. Multiple passes may result in further improvements. If no improvements are found after an optimization pass, the optimization is ended. Only applicable when optimizing. -assumenosideeffects class_specification Specifies methods that don't have any side effects, other than possibly returning a value. For example, the method System.currentTimeMillis() returns a value, but it doesn't have any side effects. In the optimization step, DexGuard can then remove calls to such methods, if it can determine that the return values aren't used. DexGuard will analyze your program code to find such methods automatically. It will not analyze library code, for which this option can therefore be useful. For example, you could specify the method System.currentTimeMillis() , so that any idle calls to it will be removed. With some care, you can also use the option to remove logging code . Note that DexGuard applies the option to the entire hierarchy of the specified methods. Only applicable when optimizing. In general, making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumenoexternalsideeffects class_specification Specifies methods that don't have any side effects, except possibly on the instances on which they are called. This statement is weaker than -assumenosideeffects , because it allows side effects on the parameters or the heap. For example, the StringBuffer#append methods have side effects, but no external side effects. This is useful when removing logging code , to also remove any related string concatenation code. Only applicable when optimizing. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumenoescapingparameters class_specification Specifies methods that don't let their reference parameters escape to the heap. Such methods can use, modify, or return the parameters, but not store them in any fields, either directly or indirectly. For example, the method System.arrayCopy does not let its reference parameters escape, but method System.setSecurityManager does. Only applicable when optimizing. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumenoexternalreturnvalues class_specification Specifies methods that don't return reference values that were already on the heap when they are called. For example, the ProcessBuilder#start returns a Process reference value, but it is a new instance that wasn't on the heap yet. Only applicable when optimizing. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumevalues class_specification Specifies fixed values or ranges of values for primitive fields and methods. For example, you can optimize your app for given Android SDK versions by specifying the supported range in the version constant. ProGuard can then optimize away code paths for older versions. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -allowaccessmodification Specifies that the access modifiers of classes and class members may be broadened during processing. This can improve the results of the optimization step. For instance, when inlining a public getter, it may be necessary to make the accessed field public too. Although Java's binary compatibility specifications formally do not require this (cfr. The Java Language Specification, Third Edition , Section 13.4.6 ), some virtual machines would have problems with the processed code otherwise. Only applicable when optimizing (and when obfuscating with the -repackageclasses option). Counter-indication: you probably shouldn't use this option when processing code that is to be used as a library, since classes and class members that weren't designed to be public in the API may become public. -mergeinterfacesaggressively Specifies that interfaces may be merged, even if their implementing classes don't implement all interface methods. This can reduce the size of the output by reducing the total number of classes. Note that Java's binary compatibility specifications allow such constructs (cfr. The Java Language Specification, Third Edition , Section 13.5.3 ), even if they are not allowed in the Java language (cfr. The Java Language Specification, Third Edition , Section 8.1.4 ). Only applicable when optimizing. Counter-indication: setting this option can reduce the performance of the processed code on some JVMs, since advanced just-in-time compilation tends to favor more interfaces with fewer implementing classes. Worse, some JVMs may not be able to handle the resulting code. Obfuscation Options \u00b6 -dontobfuscate Specifies not to obfuscate, reflect, or encrypt the input classes, resources, assets, and native libraries. By default, DexGuard obfuscates the code: it assigns new short random names to classes, class members, resources, resource files, assets files, and native libraries. It also removes internal attributes that are only useful for debugging, such as source files names, variable names, and line numbers. Finally, it applies reflection and encryption to specified elements. -printmapping [ filename ] Specifies to print the mapping from old names to new names for classes and class members that have been renamed. The mapping is printed to the standard output or to the given file. For example, it is required for subsequent incremental obfuscation , or if you ever want to make sense again of obfuscated stack traces . Only applicable when obfuscating. -applymapping filename Specifies to reuse the given name mapping that was printed out in a previous obfuscation run of DexGuard. Classes and class members that are listed in the mapping file receive the names specified along with them. Classes and class members that are not mentioned receive new names. The mapping may refer to input classes as well as library classes. This option can be useful for incremental obfuscation , i.e. processing add-ons or small patches to an existing piece of code. If the structure of the code changes fundamentally, DexGuard may print out warnings that applying a mapping is causing conflicts. You may be able to reduce this risk by specifying the option -useuniqueclassmembernames in both obfuscation runs. Only a single mapping file is allowed. Only applicable when obfuscating. -printresourcefilenamemapping [ filename ] Specifies to print the mapping from old names to new names for resource files (assets, native libraries, Android resources). The mapping is printed to the standard output or to the given file. Only applicable when obfuscating. -printresourcemapping [ filename ] Specifies to print the mapping from old ids to new ids for resource files (assets, native libraries, Android resources). The mapping is printed to the standard output or to the given file. Only applicable when obfuscating. -applyresourcemapping filename Specifies to reuse the given resource name mapping that was printed out in a previous obfuscation run of DexGuard. Resources that are listed in the mapping file receive the names specified along with them. Resources that are not mentioned receive new names. Only applicable when obfuscating. -obfuscationdictionary filename or naming scheme Specifies the dictionary file or naming scheme to use for obfuscating field and method names. By default, short names like 'a', 'b', etc. are used as obfuscated names. A dictionary file contains a list of words, separated by newlines. For example, it could contain reserved key words, identifiers with foreign characters and so on. White space, punctuation characters, duplicate words and comments preceded by a # sign are ignored. Alternatively, an internal naming scheme can be specified. Note that the chosen names hardly improve the obfuscation. Decent compilers can automatically replace them, and the effect can fairly simply be undone by obfuscating again with simpler names. The most useful application is specifying strings that are typically already present in class files (such as 'Code'), thus reducing the class file sizes just a little bit more. Only applicable when obfuscating. -classobfuscationdictionary filename or naming scheme Specifies the dictionary file or naming scheme to use for obfuscating class names. This is similar to the option -obfuscationdictionary . Only applicable when obfuscating. -packageobfuscationdictionary filename Specifies a text file from which all valid words are used as obfuscated package names. Each line contains a name. White space, punctuation characters, duplicate words and comments after a # sign are ignored. Only applicable when obfuscating. -overloadaggressively Specifies to apply aggressive overloading while obfuscating. Multiple fields and methods can then get the same names, as long as their arguments and return types are different, as required by Java bytecode (not just their arguments, as required by the Java language). This option can make the processed code even smaller (and less comprehensible). Only applicable when obfuscating. Counter-indication: the resulting class files fall within the Java bytecode specification (cfr. The Java Virtual Machine Specification, Second Edition , first paragraphs of Section 4.5 and Section 4.6 ), even though this kind of overloading is not allowed in the Java language (cfr. The Java Language Specification, Third Edition , Section 8.3 and Section 8.4.5 ). Still, some tools have problems with it. Notably, the Dalvik VM can't handle overloaded static fields. -useuniqueclassmembernames Specifies to assign the same obfuscated names to class members that have the same names, and different obfuscated names to class members that have different names (for each given class member signature). Without the option, more class members can be mapped to the same short names like 'a', 'b', etc. The option therefore increases the size of the resulting code slightly, but it ensures that the saved obfuscation name mapping can always be respected in subsequent incremental obfuscation steps. For instance, consider two distinct interfaces containing methods with the same name and signature. Without this option, these methods may get different obfuscated names in a first obfuscation step. If a patch is then added containing a class that implements both interfaces, DexGuard will have to enforce the same method name for both methods in an incremental obfuscation step. The original obfuscated code is changed, in order to keep the resulting code consistent. With this option in the initial obfuscation step , such renaming will never be necessary. This option is only applicable when obfuscating. In fact, if you are planning on performing incremental obfuscation, you probably want to avoid shrinking and optimization altogether, since these steps could remove or modify parts of your code that are essential for later additions. -distinctclassmembernames class_specification Specifies to assign distinct obfuscated names to the members of the classes matching the given class specification. Without the option, multiple class members with different JVM signatures might be mapped to the same member name like 'a', 'b', etc. The option therefore increases the size of the resulting code slightly, but it ensures that classe / interfaces only contain unique names. For instance, consider the case where through reflection, the members of the class are exposed to another language like Javascript. Javascript does not support overloaded functions and thus cannot distinguish between members with the same name. Part of your class becomes unaccessible through this interface. This can be solved by applying this flag on the classes that can be exposed. This option is only applicable when obfuscating, as the class members are otherwise not renamed. -dontusemixedcaseclassnames Specifies not to generate mixed-case class names while obfuscating. By default, obfuscated class names can contain a mix of upper-case characters and lower-case characters. This creates perfectly acceptable and usable jars. Only if a jar is unpacked on a platform with a case-insensitive filing system (say, Windows), the unpacking tool may let similarly named class files overwrite each other. Code that self-destructs when it's unpacked! Developers who really want to unpack their jars on Windows can use this option to switch off this behavior. Obfuscated jars will become slightly larger as a result. Only applicable when obfuscating. -keeppackagenames [ package_filter ] Specifies not to obfuscate the given package names. The optional filter is a comma-separated list of package names. Package names can contain ? , * , and ** wildcards, and they can be preceded by the ! negator. Only applicable when obfuscating. -flattenpackagehierarchy [ package_name ] Specifies to repackage all packages that are renamed, by moving them into the single given parent package. Without argument or with an empty string (''), the packages are moved into the root package. This option is one example of further obfuscating package names . It can make the processed code smaller and less comprehensible. Only applicable when obfuscating. -repackageclasses [ package_name ] Specifies to repackage all class files that are renamed, by moving them into the single given package. Without argument or with an empty string (''), the package is removed completely. This option overrides the -flattenpackagehierarchy option. It is another example of further obfuscating package names . It can make the processed code even smaller and less comprehensible. Its deprecated name is -defaultpackage . Only applicable when obfuscating. Counter-indication: classes that look for resource files in their package directories will no longer work properly if they are moved elsewhere. When in doubt, just leave the packaging untouched by not using this option. Note: On Android, you should not use the empty string when classes like activities, views, etc. may be renamed. The Android run-time automatically prefixes package-less names in XML files with the application package name or with android.view . This is unavoidable but it breaks the application in this case. -keepattributes [ attribute_filter ] Specifies any optional attributes to be preserved. The attributes can be specified with one or more -keepattributes directives. The optional filter is a comma-separated list of attribute names that Java virtual machines and DexGuard support. Attribute names can contain ? , * , and ** wildcards, and they can be preceded by the ! negator. For example, you should at least keep the Exceptions , InnerClasses , and Signature attributes when processing a library . You should also keep the SourceFile and LineNumberTable attributes for producing useful obfuscated stack traces . Finally, you may want to keep annotations if your code depends on them. Only applicable when obfuscating. -keepparameternames Specifies to keep the parameter names and types of methods that are kept. This option actually keeps trimmed versions of the debugging attributes LocalVariableTable and LocalVariableTypeTable . It can be useful when processing a library . Some IDEs can use the information to assist developers who use the library, for example with tool tips or autocompletion. Only applicable when obfuscating. -renamesourcefileattribute [ string ] Specifies a constant string to be put in the SourceFile attributes (and SourceDir attributes) of the class files. Note that the attribute has to be present to start with, so it also has to be preserved explicitly using the -keepattributes directive. For example, you may want to have your processed libraries and applications produce useful obfuscated stack traces . Only applicable when obfuscating. It is possible to preserve the SourceFile attribute for kept classes by specifying the Java system property obfuscate.keptclasses.dontrenamesourcefileattribute (with -D..... ). -accessthroughreflection [ ,encryptstrings ] class_specification Specifies to replace direct access to the specified classes and class members by reflection. Matching class references are then replaced by Class.forName constructs. Reads and writes of matching fields are replaced by Class.getField and Field.get/set constructs. Method invocation are replaced by Class.getMethod and Method.invoke constructs. For example, when processing the Android License Verification Library, you may want to add reflection for sensitive APIs in the Android run-time. Only applicable when obfuscating. The encryptstrings modifier additionally encrypts the strings that are created for the reflection, effectively hiding all references to the reflected class or class member. Limitation: Due to technical constraints, -accessthroughreflection cannot currently be applied to java.lang.Object methods. -obfuscatecode [ , strength ] class_specification Specifies to obfuscate the code (i.e. bytecode instructions) of the specified methods. If the class specification does not specify any methods, all methods in the specified class or classes are obfuscated. With specified methods, only the code of matching methods is obfuscated. The default obfuscation strength is low . Code obfuscation makes it more difficult to disassemble or decompile classes. Depending on the specified strength , different techniques are applied. They raise the bar for any reverse engineering attempt. Only applicable when obfuscating. Performance tip: Code obfuscation increases the code size and introduces some minor processing overhead in the obfuscated methods at runtime. You should use a low obfuscation strength for methods that are critical for application performance or that execute a large number of arithmetic calculations. Limitation: Due to technical constraints, you can currently not apply code obfuscation to methods using synchronization blocks (however methods marked synchronized are fine). -virtualizecode class_specification Specifies to virtualize the code (i.e. bytecode instructions) of the specified methods. If the class specification does not specify any methods, all methods in the specified class or classes are virtualized. With specified methods, only the code of matching methods is virtualized. Code virtualization makes it more difficult to apply static or dynamic analysis of the application classes as it rewrites the bodies of virtualized methods with a randomized instruction set that is executed by an inlined virtual machine. It considerably raises the bar for any reverse engineering attempt. Only applicable when obfuscating. Performance tip: Code virtualization increases the code size and introduces some processing overhead in the virtualized methods at runtime. You should not virtualize methods that are critical for application performance. Limitation: Due to technical constraints, you can currently not apply code virtualization to initializers (constructors, static initializers) and methods using synchronization blocks (however methods marked synchronized are supported). -obfuscatejavascript file_filter Specifies that the contents of all Javascript files matching the given filter should be obfuscated using DexGuard's own built-in Javascript obfuscator. -javascriptconfiguration filename Specifies a file that contains a Javascript configuration. The configuration file will be passed to the Javascript obfuscator, to obfuscate any Javascript files specified in -obfuscatejavascript . Note: You can find more details about the integration and usage of the Javascript obfuscator in the separate Javascript obfuscator manual . -javascriptplugin filename [ string ] Use the specified plugin jar and optional string to obfuscate Javascript files. -encryptclasses [ class_filter ] -encryptclasses class_specification Specifies that classes whose names either match the given filter or class specification should be encrypted. When using a class specification, specified fields and methods are ignored as classes will always be encrypted as a whole. This makes it more difficult to disassemble or decompile them. \"Obfuscated\" would be a better word, since the processed code necessarily has to be able to reverse the encryption. It therefore increases the code size and introduces processing overhead at runtime, whenever the class is loaded or accessed. However, it raises the bar for any reverse engineering attempts. For example, if you have some sensitive license checking class, you may want to protect it by encrypting it. Only applicable when obfuscating. You can additionally protect encrypted classes by obfuscating their code with obfuscation strength medium or high. This will render the classes unusable if they are manually extracted from the DEX file. Code obfuscation should not be applied however on performance-sensitive code that is executed very frequently (e.g., tight code loops). Counter-indications: It is not possible to encrypt classes that are explicitly preserved from obfuscation (in your configuration), extended by non-encrypted classes, or created by reflection (for instance because they are referenced from XML files). Note: When encrypting classes in library projects , the code must set a temporary directory: System.setProperty(\"java.io.tmpdir\", getDir(\"files\", Context.MODE_PRIVATE).getPath()); Caveat: When encrypting classes in library projects , the encrypted classes must not contain references to classes or class members that are later on obfuscated in the final application projects. Once encrypted, classes can no longer be changed, so their references would become invalid. If encrypted classes do contain references to other non-encrypted classes in their library projects, these referenced classes and class members must be preserved from obfuscation in the application projects. If your requirements allow it, it is easier to encrypt classes when processing the final application. Performance tip: Every access from an external class to an encrypted class carries some overhead, due to reflection. If performance is important in this part of your code, you can reduce the overhead by accessing the class through an interface that is not encrypted. -encryptstrings [ string_filter ] [ -encryptstrings ] class_specification Specifies to encrypt string constants that either match the given filter or that are defined in matching classes. With a class specification without fields or methods, all strings in the matching class or classes are encrypted. With specified fields, the matching final String constants are encrypted. With specified methods, all strings in the matching methods are encrypted. String encryption makes it more difficult to find them in disassembled or decompiled code. Again, \"obfuscated\" would be a better word, since the processed code necessarily has to be able to reverse the encryption. It therefore increases the code size and introduces processing overhead whenever the string is accessed. But again, it raises the bar for any reverse engineering attempts. For example, if you have hard-coded some key string, you may want to encrypt it to hide it a bit better. Also, if you are already accessing a class or a class member through introspection, you may want to obfuscate the resulting strings containing their names in the code. Only applicable when obfuscating. Caveat: The current implementation does not support encrypting strings in static initializers in interfaces. Final string constants in interfaces are not a problem. Performance tip: Every encrypted string is decrypted on the fly at run-time, without implicit caching. If performance of encrypted strings is important in some parts of your code, you can define them as private static String fields, so they are only decrypted once, when the class is initialized. Don't declare them as final though, because the compiler will then inline them again. -adaptclassstrings [ class_filter ] Specifies that string constants that correspond to class names should be obfuscated as well. Without a filter, all string constants that correspond to class names are adapted. With a filter, only string constants in classes that match the filter are adapted. For example, if your code contains a large number of hard-coded strings that refer to classes, and you prefer not to keep their names, you may want to use this option. Primarily applicable when obfuscating, although corresponding classes are automatically kept in the shrinking step too. -keepkotlinmetadata Instructs DexGuard to process kotlin.Metadata annotations if present. Currently only shrinking and obfuscation of its content is supported. Classes containing such annotations should be excuded from optimization if this option is enabled. -adaptresourcefilenames [ file_filter ] Specifies the resource files to be renamed, based on the obfuscated names of the corresponding class files (if any). Without a filter, all resource files that correspond to class files are renamed. With a filter, only matching files are renamed. For example, see processing resource files . Only applicable when obfuscating. -adaptresourcefilecontents [ file_filter ] Specifies the resource files and native libraries whose contents are to be updated. Any class names mentioned in the resource files are renamed, based on the obfuscated names of the corresponding classes (if any). Any function names in the native libraries are renamed, based on the obfuscated names of the corresponding native methods (if any). Without a filter, the contents of all resource files updated. With a filter, only matching files are updated. The resource files are parsed and written using UTF-8 encoding. For an example, see processing resource files . Only applicable when obfuscating. Caveat: You probably only want to apply this option to text files, Android resource XML files, and native libraries, since parsing and adapting general binary files as text files can cause unexpected problems. Therefore, make sure that you specify a sufficiently narrow filter. -stripnativelibrarysections [ file_filter ] Specifies the native libraries that should undergo a removal of sections which are not needed at runtime. Note: This flag only has an effect on native libraries that also match the -adaptresourcefilecontents filter. -resourcefilenameobfuscationdictionary filename Specifies a text file from which the lines are used as obfuscated Android resource file names. Each line contains a name. Comments after a # sign are ignored. Only applicable when obfuscating Android code. -encryptmetadata [ string_filter ] Specifies the metadata in the Android Manifest that should be encrypted. All metadata whose name matches the given filter will be encrypted. DexGuard will inline the metadata values in the code and then encrypt these values in the code. The original metadata entries will be removed from the Android Manifest, unless they are explicitly kept using -keepresourcexmlelements . Only String metadata which are retrieved using Bundle.getString(int) with a integer constant (not a variable) are currently supported. -encryptassetfiles [ file_filter ] Specifies the Android asset files that should be encrypted. Asset files are stored in the assets directory and can contain any data. The obfuscation step can automatically encrypt them and make sure they are decrypted on the fly at run-time. In order for this to work, the assets must be loaded using one of the AssetManager.open methods. Only applicable when obfuscating Android code. Note: If the processed application contains at least one call to AssetManager.open(String) with a non-constant string argument, DexGuard will encrypt all assets that match the specified file filter. If there are assets that are loaded via other mechanisms, make sure they do not match the specified file filter. -encryptresources [ name_filter ] Specifies the Android resources to be encrypted. The filter is applied to strings of the form \"type/name\", for example \"string/apiKey\". Currently only String resources are supported. A resource excluded from obfuscation using -keepresources can still be encrypted by using the allowencryption modifier. Only applicable when processing Android applications. Counter-indication: resource Strings referenced from other XML files can't be encrypted. -encryptresourcefiles [ file_filter ] Specifies to encrypt Android resource files. Resource files are stored in the res directory and can contain application resources such as layout XML files. The obfuscation step can automatically encrypt them and make sure they are decrypted on the fly at run-time. Supported resources: res/layout , res/menu , and res/xml files. Counter-indication: app widgets can't decrypt resources. Don't encrypt resource files that are accessed by app widgets or retrieved via android.content.pm.PackageManager. Only applicable when processing Android applications. Counter-indication: resource file encryption is not compatible with Android App Bundles. -encryptnativelibraries [ file_filter ] Specifies the Android native libraries that should be encrypted. Native libraries are packaged in subdirectories of the lib directory. The obfuscation step can automatically encrypt them and make sure they are decrypted on the fly at run-time. In order for this to work, your application must load the native library using System.loadLibrary(String) or be a dependency of an encrypted native library. Your configuration can then specify \" -encryptnativelibraries lib/**/libmycode.so \", matching the complete path and name of the library. Note that the paths are the paths as you find them in the output, with lib/ , not libs/ . Also note the wildcards: if a library is encrypted for one platform, it must be encrypted for all platforms. Only applicable when obfuscating Android code. Note: For a more secure way of loading your encrypted native libraries, you can include lib/dexguard-nativeloader.aar as a dependency to your project. Note: If the processed application contains at least one call to System.loadLibrary(String) with a non-constant string argument, DexGuard will encrypt all native libraries that match the specified file filter. If there are libraries that are loaded via other mechanisms, make sure they do not match the specified file filter. Note: When encrypting native libraries in library projects , the code should set a temporary directory, for maximum portability: System.setProperty(\"java.io.tmpdir\", getDir(\"files\", Context.MODE_PRIVATE).getPath()); -randomizationseed integer_seed Specifies an additional value that is taken into account when generating the seed value to randomize the obfuscation. -printclassencryption [ filename ] Specifies to print the class encryption groups, and the plugins which were used to encrypt each class group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting classes. -printstringencryption [ filename ] Specifies to print the string encryption groups, and the plugins which were used to encrypt each string group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting strings. -printassetencryption [ filename ] Specifies to print the asset encryption groups, and the plugin which was used to encrypt each asset group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting assets. -printresourceencryption [ filename ] Specifies to print the resources that are encrypted, and the plugin which was used to encrypt them. The mapping is printed to the standard output or to the given file. Only applicable when encrypting resources. -printnativelibraryencryption [ filename ] Specifies to print the native library encryption groups, and the plugins which was used to encrypt each group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting native libraries. Preverification Options \u00b6 -dontpreverify Specifies not to preverify the processed class files. By default, class files are preverified if they are targeted at Java Micro Edition or at Java 6 or higher. For Java Micro Edition, preverification is required, so you will need to run an external preverifier on the processed code if you specify this option. For Java 6, preverification is optional, but as of Java 7, it is required. Only when eventually targeting Android, it is not necessary, so you can then switch it off to reduce the processing time a bit. This option is not relevant for Android applications. -microedition Specifies that the processed class files are targeted at Java Micro Edition. The preverifier will then add the appropriate StackMap attributes, which are different from the default StackMapTable attributes for Java Standard Edition. For example, you will need this option if you are processing midlets. This option is not relevant for Android applications. -android Specifies that the processed class files are targeted at the Android platform. DexGuard will then make sure some features like string encryption and class encryption are compatible with Android. For example, you may need this option if you are processing libraries for Android. This option is always set in DexGuard. Conversion Options \u00b6 -dalvik Specifies that the code is targeted at the Android platform and the Dalvik virtual machine. DexGuard will then convert the processed class files to the Dex format. The output will contain a single classes.dex file instead of many .class files. For example, you probably want to use this option if you are processing Android applications . -protobuffer Deprecated: app bundles are now automatically detected so this option is no longer required Specifies to write the processed resource files in protobuffer format. Jar Signing Options \u00b6 -keystore filename Specifies the key store file that contains your private signing key. Only required if you want DexGuard to sign the output jars. -keystorepassword password Specifies the password of the key store. This can also be a pin in the case of a PKCS11 configuration. Only required if you want DexGuard to sign the output jars. -keyalias alias Specifies the alias of the key that you want to select from the key store. Only required if you want DexGuard to sign the output jars. -keypassword password Specifies the password of the key. Only required if you want DexGuard to sign the output jars. -pkcs11configuration filename Specifies the configuration file that contains the connection information to the PKCS11 keystore. Only required if you want DexGuard to sign the output jars using PKCS11. More about the configuration format can be found by running man 5 pkcs11.conf . -certificatelineage filename Specifies the certificate lineage file, if you want to apply key rotation. You then need to specify the corresponding oldest and newest key stores, aliases, and passwords. Alternatively, you can specify the entire lineage, without a lineage file, as a list of key stores, aliases, and passwords (oldest to newest). -apksignatureschemes [ signature_scheme_filter ] Specifies a filter for apk signing schemes that should be used when creating an apk. DexGuard supports the following apk signing schemes: v1, v2, v3, v4 . By default, if no apk signature scheme option is provided, v1 and v2 signature schemes are enabled. RASP Options \u00b6 See RASP for more information on these options: -raspchecks RASP detector list Enable one or more of the RASP detectors. -raspcontinueon RASP detector list By default, an app will crash on a RASP threat, unless listed. -raspcallback class_specification Custom callback that will be executed when a RASP threat is detected. -raspclassfilter class_filter Class filter used to refine the RASP injection locations. -raspaggressiveness Detector name aggressiveness level Change the level of aggressiveness of RASP injection for a certain RASP detector. -raspfiletamperlist file list List of files checked by the RASP File Tamper detector. -raspcertificatehash certificate hash Specify the certificate hash of the signing key which will be used to sign the app. General Options \u00b6 -verbose Specifies to write out some more information during processing. If the program terminates with an exception, this option will print out the entire stack trace, instead of just the exception message. -dontnote [ class_filter ] -dontnote [' type [ :id ]'] Specifies not to print notes about potential mistakes or omissions in the configuration, such as typos in class names or missing options that might be useful. The optional filter is a regular expression; DexGuard doesn't print notes about classes with matching names. You can also specify a type with an optional id to suppress advice and warnings that are printed in the protection report. Quotes When writing a -dontnote rule for the protection report that contains an id the entire argument has to be quoted as shown below. -dontnote ' report_message : 1234 ' -dontwarn [ class_filter ] Specifies not to warn about unresolved references and other important problems at all. The optional filter is a regular expression; DexGuard doesn't print warnings about classes with matching names. Ignoring warnings can be dangerous. For instance, if the unresolved classes or class members are indeed required for processing, the processed code will not function properly. Only use this option if you know what you're doing! -ignorewarnings Specifies to print any warnings about unresolved references and other important problems, but to continue processing in any case. Ignoring warnings can be dangerous. For instance, if the unresolved classes or class members are indeed required for processing, the processed code will not function properly. Only use this option if you know what you're doing! -printconfiguration [ filename ] Specifies to write out the entire configuration that has been parsed, with included files and replaced variables. The structure is printed to the standard output or to the given file. This can sometimes be useful to debug configurations, or to convert XML configurations into a more readable format. -printlibraryconfiguration filename Specifies to generate and write out the configuration that is needed when you additionally process the obfuscated output again with ProGuard or DexGuard. The configuration provides keep rules for all classes, class members and resource files whose use can no longer be found after the primary obfuscation step, due to reflection, encryption, ... Any keep rule from the input configuration will also be copied to the library configuration, if it is still applicable. If the option is not specified, the configuration is still automatically generated and written to the \u2018proguard.txt\u2019 file inside the output AAR for all projects that have at least one keep rule with the \u2018 asapi \u2019 modifier. Only applicable to library projects. -printstatistics [ filename ] Specifies to write out extended statistics on package-level. The statistics are printed to the standard output or to the given file. This can be useful to verify or optimize configurations. Note: by default, the package hierarchy up to level 3 will be displayed, e.g. com.example.subpackage . This can be customised with some Java system properties, which can be set as JVM arguments (with -D... ): statistics.maxlevel= level : the maximum package hierarchy level to display. statistics.fold= package_filter : packages matching the filter will be folded. statistics.expand= package_filter : packages matching the filter will be expanded. -printinjectmapping [ filename ] Specifies to write out a mapping of which RASP checking code was injected into which method in your application. -printthreatcastmapping [ filename ] Specifies to write out a mapping file that lists the human readable method names for each check location identifier. This mapping file can be uploaded to your ThreatCast server portal , to provide more info on the runtime threats your app is facing. -threatcastappuseridgetter class_specification Specifies a custom App User ID (AUID) getter method that will be executed to collect the AUID and send it to ThreatCast when a RASP threat is detected. -addconfigurationdebugging Specifies to instrument the processed code with debugging statements that print out suggestions for missing DexGuard configuration. This can be very useful to get practical hints at run-time , if your processed code crashes because it still lacks some configuration for reflection. For example, the code may be serializing classes with the GSON library and you may need some configuration for it. You can generally just copy/paste the suggestions from the console into your configuration file. Counter-indication: do not use this option in release versions, as it adds obfuscation information to the processed code. -disableprotectionreport Disables the generation of protection reports. When protection report generation is disabled, DexGuard does not create the HTML report which summarizes the impact of DexGuard on the generated outputs. -disabletelemetry Disables the sending of usage reports to Guardsquare's servers. -protectionreportdirectory directoryname Specifies the location where protection reports shall be created. By default, such files are created in the 'reports' directory. -intermediatedirectory directoryname Specifies the location of DexGuard's intermediate directory. This is an optional rule that puts the directory of intermediate files in the specified location and prevents it from being removed. When not provided, the directory is created in the default location for temporary directories and is removed after processing. When the specified directory is not empty, the \u2018allowoverwrite\u2019 modifier should be provided. Note that this may overwrite existing files and directories in the specified location, so be careful when using this modifier. allowoverwrite Modifier for intermediatedirectory that specifies that files and directories in the given intermediate directory may be overwritten. This is useful when you have specified a non-existent or empty directory that DexGuard has used during a first run, and you want to reuse this directory for intermediate files in subsequent runs. Be careful with this modifier when you have specified an intermediate directory that is not DexGuard-specific. -disableversioncheck Disables performing the version check. By default, this check is enabled to check whether a newer DexGuard version is available. If enabled, a message is added to the build log, warning you when a new release is available and notifying you that you might want to try out a new beta release. Class Paths \u00b6 DexGuard accepts a generalization of class paths to specify input files and output files. A class path consists of entries, separated by the traditional path separator (e.g. ' : ' on Unix, or ' ; ' on Windows platforms). The order of the entries determines their priorities, in case of duplicates. Each input entry can be: A class file, dex file, or resource file, An apk file, containing any of the above, An aab file, containing any of the above, A jar file, containing any of the above, An aar file, containing any of the above, A war file, containing any of the above, An ear file, containing any of the above, A jmod file, containing any of the above, A zip file, containing any of the above, A directory (structure), containing any of the above. The paths of directly specified class files and resource files is ignored, so class files should generally be part of a jar file, an aar file, a war file, an ear file, a zip file, or a directory. In addition, the paths of class files should not have any additional directory prefixes inside the archives or directories. Each output entry can be: An apk file, in which all processed and converted class files and resource files will be collected. An aab file, in which any and all of the above will be collected, A jar file, in which any and all of the above will be collected, An aar file, in which any and all of the above will be collected, A war file, in which any and all of the above will be collected, An ear file, in which any and all of the above will be collected, A jmod file, in which any and all of the above will be collected, A zip file, in which any and all of the above will be collected, A directory, in which any and all of the above will be collected. When writing output entries, DexGuard generally packages the results in a sensible way, reconstructing the input entries as much as required. Writing everything to an output directory is the most straightforward option: the output directory will contain a complete reconstruction of the input entries. The packaging can be almost arbitrarily complex though: you could process an entire application, packaged in a zip file along with its documentation, writing it out as a zip file again. The Examples section shows a few ways to restructure output archives . Files and directories can be specified as discussed in the section on file names below. In addition, DexGuard provides the possibility to filter the class path entries and their contents, based on their full relative file names. Each class path entry can be followed by up to 9 types of file filters between parentheses, separated by semi-colons: A filter for all jmod names that are encountered, A filter for all aar names that are encountered, A filter for all aab names that are encountered, A filter for all apk names that are encountered, A filter for all zip names that are encountered, A filter for all ear names that are encountered, A filter for all war names that are encountered, A filter for all jar names that are encountered, A filter for all class file names and resource file names that are encountered. If fewer than 9 filters are specified, they are assumed to be the latter filters. Any empty filters are ignored. More formally, a filtered class path entry looks like this: classpathentry([[[[[[[[jmodfilter;]aarfilter;]aabfilter;]apkfilter;]zipfilter;]earfilter;]warfilter;]jarfilter;]filefilter) Square brackets \"[]\" mean that their contents are optional. For example, \" android.jar(java/**.class,javax/**.class) \" matches all class files in the java and javax directories inside the android jar. For example, \" input.jar(!**.gif,images/**) \" matches all files in the images directory inside the input jar, except gif files. The different filters are applied to all corresponding file types, irrespective of their nesting levels in the input; they are orthogonal. For example, \" input.war(lib/**.jar,support/**.jar;**.class,**.gif) \" only considers jar files in the lib and support directories in the input war, not any other jar files. It then matches all class files and gif files that are encountered. The filters allow for an almost infinite number of packaging and repackaging possibilities. The Examples section provides a few more examples for filtering input and output . File Names \u00b6 DexGuard accepts absolute paths and relative paths for the various file names and directory names. A relative path is interpreted as follows: relative to the base directory, if set, or otherwise relative to the configuration file in which it is specified, if any, or otherwise relative to the working directory. The names can contain Java system properties (or Ant properties, when using Ant), delimited by angular brackets, ' < ' and ' > '. The properties are automatically replaced by their corresponding values. For example, <java.home>/lib/rt.jar is automatically expanded to something like /usr/local/java/jdk/jre/lib/rt.jar . Similarly, <user.home> is expanded to the user's home directory, and <user.dir> is expanded to the current working directory. Names with special characters like spaces and parentheses must be quoted with single or double quotes. Each file name in a list of names has to be quoted individually. Note that the quotes themselves may need to be escaped when used on the command line, to avoid them being gobbled by the shell. For example, on the command line, you could use an option like '-injars \"my program.jar\":\"/your directory/your program.jar\"' . File Filters \u00b6 Like general filters , a file filter is a comma-separated list of file names that can contain wildcards. Only files with matching file names are read (in the case of input jars), or written (in the case of output jars). The following wildcards are supported: Wildcard Meaning ? matches any single character in a file name. * matches any part of a filename not containing the directory separator. ** matches any part of a filename, possibly containing any number of directory separators. For example, \" java/**.class,javax/**.class \" matches all class files in the java and javax . Furthermore, a file name can be preceded by an exclamation mark ' ! ' to exclude the file name from further attempts to match with subsequent file names. For example, \" !**.gif,images/** \" matches all files in the images directory, except gif files. The Examples section provides a few more examples for filtering input and output . Filters \u00b6 DexGuard offers options with filters for many different aspects of the configuration: names of files, directories, classes, packages, attributes, optimizations, etc. A filter is a list of comma-separated names that can contain wildcards. Only names that match an item on the list pass the filter. The supported wildcards depend on the type of names for which the filter is being used, but the following wildcards are typical: Wildcard Meaning ? matches any single character in a name. * matches any part of a name not containing the package separator or directory separator. ** matches any part of a name, possibly containing any number of package separators or directory separators. For example, \" foo,*bar \" matches the name foo and all names ending with bar . Furthermore, a name can be preceded by a negating exclamation mark ' ! ' to exclude the name from further attempts to match with subsequent names. So, if a name matches an item in the filter, it is accepted or rejected right away, depending on whether the item has a negator. If the name doesn't match the item, it is tested against the next item, and so on. It if doesn't match any items, it is accepted or rejected, depending on the whether the last item has a negator or not. For example, \" !foobar,*bar \" matches all names ending with bar , except foobar . Naming schemes \u00b6 DexGuard currently offers three naming schemes, which serve as an alternative to providing file-based dictionaries for renaming class and member names. Naming Scheme Description Example <keptnames> Recycle class and member names that were explicitly kept. -obfuscationdictionary <keptnames> <alphabetic> Shortcut for a simple alphabetic naming scheme (like ProGuard). -obfuscationdictionary <alphabetic> <utf8> Use UTF-8 characters. (deprecated: may cause issues on certain devices) -obfuscationdictionary <utf8> Overview of Keep Options \u00b6 The various -keep options for shrinking and obfuscation may seem a bit confusing at first, but there's actually a pattern behind them. The following table summarizes how they are related: Keep From being removed or renamed From being renamed Classes and class members -keep -keepnames Class members only -keepclassmembers -keepclassmembernames Classes and class members, if class members present -keepclasseswithmembers -keepclasseswithmembernames Each of these -keep options is of course followed by a specification of the classes and class members (fields and methods) to which it should be applied. If you're not sure which option you need, you should probably simply use -keep . It will make sure the specified classes and class members are not removed in the shrinking step, and not renamed in the obfuscation step. If you specify a class, without class members, DexGuard only preserves the class and its parameterless constructor as entry points. It may still remove, optimize, or obfuscate its other class members. If you specify a method, DexGuard only preserves the method as an entry point. Its code may still be optimized and adapted. Keep Option Modifiers \u00b6 includedescriptorclasses Specifies that any classes in the type descriptors of the methods and fields that the -keep option keeps should be kept as well. This is typically useful when keeping native method names , to make sure that the parameter types of native methods aren't renamed either. Their signatures then remain completely unchanged and compatible with the native libraries. includecode Specifies that code attributes of the methods that the -keep option keeps should be kept as well, i.e. may not be optimized or obfuscated. This is typically useful for already optimized or obfuscated classes, to make sure that their code is not modified during optimization. allowshrinking Specifies that the entry points specified in the -keep option may be shrunk, even if they have to be preserved otherwise. That is, the entry points may be removed in the shrinking step, but if they are necessary after all, they may not be optimized or obfuscated. allowoptimization Specifies that the entry points specified in the -keep option may be optimized, even if they have to be preserved otherwise. That is, the entry points may be altered in the optimization step, but they may not be removed or obfuscated. This modifier is only useful for achieving unusual requirements. allowobfuscation Specifies that the entry points specified in the -keep option may be obfuscated, even if they have to be preserved otherwise. That is, the entry points may be renamed in the obfuscation step, but they may not be removed or optimized. This modifier is only useful for achieving unusual requirements. allowmultidexing Deprecated: This modifier is now the default behavior of keep rules. To specify classes that need to end up in the primary dex, see inmaindex . Specifies that the entry points specified in the -keep option may be placed in any secondary dex files, even if they have to be preserved otherwise. That is, the entry points may be present in a secondary dex file, but they may not be removed, optimized or renamed. This option is only useful when you have multiple dex files. inmaindex Specifies that the entry points specified in the -keep option need to end up in the primary dex file. This option is only useful when you have multiple dex files. DexGuard already checks which classes need to be in the primary dex due to constraints of Android API 19 and below, so this option should rarely be necessary. asapi Specifies that the entry point(s) specified in the -keep option are part of the library\u2019s API. API keep rules are processed exactly the same way as other keep rules, but they are not copied into the output library configuration. Only applicable to library projects. Keep Resources Option Modifiers \u00b6 allowobfuscation Specifies that the resources specified in the -keepresources option may be obfuscated, even if they have to be preserved otherwise. That is, the resources may be renamed in the obfuscation step, but they may not be removed. This modifier is only useful for achieving unusual requirements. allowencryption Specifies that the resource specified in the -keepresources option can be encrypted even if its name should be kept as-is. This modifier is only useful in combination with -encryptresource . Strength Modifiers \u00b6 low Specifies that the code of methods specified in the -obfuscatecode option should be obfuscated with low strength. The code size of obfuscated methods will slightly increase, while their runtime performance might decrease slightly. medium Specifies that the code of methods specified in the -obfuscatecode option should be obfuscated with moderate strength. The code size of obfuscated methods will increase moderately, while their runtime performance might decrease. high Specifies that the code of methods specified in the -obfuscatecode option should be obfuscated with high strength. The code size of obfuscated methods will increase moderately, while their runtime performance might decrease considerably. This modifier should not be used for performance critical methods. Class Specifications \u00b6 A class specification is a template of classes and class members (fields and methods). It is used in the various -keep options and in the -assumenosideeffects option. The corresponding option is only applied to classes and class members that match the template. The template was designed to look very Java-like, with some extensions for wildcards. To get a feel for the syntax, you should probably look at the examples , but this is an attempt at a complete formal definition: [@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname] [{ [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] <fields> | (fieldtype fieldname); [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] <methods> | <init>(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...)); [@annotationtype] [[!]public|private|protected|static ... ] *; ... }] Square brackets \"[]\" mean that their contents are optional. Ellipsis dots \"...\" mean that any number of the preceding items may be specified. A vertical bar \"|\" delimits two alternatives. Non-bold parentheses \"()\" just group parts of the specification that belong together. The indentation tries to clarify the intended meaning, but white-space is irrelevant in actual configuration files. The class keyword refers to any interface or class. The interface keyword restricts matches to interface classes. The enum keyword restricts matches to enumeration classes. Preceding the interface or enum keywords by a ! restricts matches to classes that are not interfaces or enumerations, respectively. Every classname must be fully qualified, e.g. java.lang.String . Inner classes are separated by a dollar sign \" $ \", e.g. java.lang.Thread$State . Class names may be specified as regular expressions containing the following wildcards: Wildcard Meaning ? matches any single character in a class name, but not the package separator. For example, \" com.example.Test? \" matches \" com.example.Test1 \" and \" com.example.Test2 \", but not \" com.example.Test12 \". * matches any part of a class name not containing the package separator. For example, \" com.example.*Test* \" matches \" com.example.Test \" and \" com.example.YourTestApplication \", but not \" com.example.mysubpackage.MyTest \". Or, more generally, \" com.example.* \" matches all classes in \" com.example \", but not in its subpackages. ** matches any part of a class name, possibly containing any number of package separators. For example, \" **.Test \" matches all Test classes in all packages except the root package. Or, \" com.example.** \" matches all classes in \" com.example \" and in its subpackages. <n> matches the n 'th matched wildcard in the same option. For example, \" com.example.*Foo<1> \" matches \" com.example.BarFooBar \". For additional flexibility, class names can actually be comma-separated lists of class names, with optional ! negators, just like file name filters. This notation doesn't look very Java-like, so it should be used with moderation. For convenience and for backward compatibility, the class name * refers to any class, irrespective of its package, when used on its own (e.g. -keep class * ). The extends and implements specifications are typically used to restrict classes with wildcards. They are currently equivalent, specifying that only classes extending or implementing the given class (directly or indirectly) qualify. The given class itself is not included in this set. If required, it should be specified in a separate option. The @ specifications can be used to restrict classes and class members to the ones that are annotated with the specified annotation types. An annotationtype is specified just like a classname . Fields and methods are specified much like in Java, except that method argument lists don't contain argument names (just like in other tools like javadoc and javap ). The specifications can also contain the following catch-all wildcards: Wildcard Meaning <init> matches any constructor. <fields> matches any field. <methods> matches any method. * matches any field or method. Note that the above wildcards don't have return types. Only the <init> wildcard has an argument list. Fields and methods may also be specified using regular expressions. Names can contain the following wildcards: Wildcard Meaning ? matches any single character in a method name. * matches any part of a method name. <n> matches the n 'th matched wildcard in the same option. Types in descriptors can contain the following wildcards: Wildcard Meaning % matches any primitive type (\" boolean \", \" int \", etc, but not \" void \"). ? matches any single character in a class name. * matches any part of a class name not containing the package separator. ** matches any part of a class name, possibly containing any number of package separators. *** matches any type (primitive or non-primitive, array or non-array). ... matches any number of arguments of any type. <n> matches the n 'th matched wildcard in the same option. Note that the ? , * , and ** wildcards will never match primitive types. Furthermore, only the *** wildcards will match array types of any dimension. For example, \" ** get*() \" matches \" java.lang.Object getObject() \", but not \" float getFloat() \", nor \" java.lang.Object[] getObjects() \". Constructors can also be specified using their short class names (without package) or using their full class names. As in the Java language, the constructor specification has an argument list, but no return type. The class access modifiers and class member access modifiers are typically used to restrict wildcarded classes and class members. They specify that the corresponding access flags have to be set for the member to match. A preceding ! specifies that the corresponding access flag should be unset. Combining multiple flags is allowed (e.g. public static ). It means that both access flags have to be set (e.g. public and static ), except when they are conflicting, in which case at least one of them has to be set (e.g. at least public or protected ). DexGuard supports the additional modifiers synthetic , bridge , and varargs , which may be set by compilers.","title":"Reference Guide"},{"location":"usage.html#iooptions","text":"@ filename Short for ' -include filename '. -include filename Recursively reads configuration options from the given file filename . -basedirectory directoryname Specifies the base directory for all subsequent relative file names in these configuration arguments or this configuration file. -injars [, feature_name ] class_path Specifies the input jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories) of the application to be processed. The class files in these jars will be processed and written to the output jars. By default, any non-class files will be copied without changes. Please be aware of any temporary files (e.g. created by IDEs), especially if you are reading your input files straight from directories. An optional feature name specifies how the contents should be grouped and packaged, notably for dynamic features in Android app bundles. The entries in the class path can be filtered, as explained in the filters section. For better readability, class path entries can be specified using multiple -injars options. -outjars class_path Specifies the names of the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). The processed input of the preceding -injars options will be written to the named jars. This allows you to collect the contents of groups of input jars into corresponding groups of output jars. In addition, the output entries can be filtered, as explained in the filters section. Each processed class file or resource file is then written to the first output entry with a matching filter, within the group of output jars. You must avoid letting the output files overwrite any input files. For better readability, class path entries can be specified using multiple -outjars options. Without any -outjars options, no jars will be written. -libraryjars class_path Specifies the library jars (or apks, aabs, aars, wars, ears, jmods, zips, directories) of the application to be processed. The files in these jars will not be included in the output jars. The specified library jars should at least contain the class files that are extended by application class files. Library class files that are only called needn't be present, although their presence can improve the results of the optimization step. The entries in the class path can be filtered, as explained in the filters section. For better readability, class path entries can be specified using multiple -libraryjars options. Please note that the boot path and the class path set for running DexGuard are not considered when looking for library classes. This means that you explicitly have to specify the run-time jar that your code will use. -pluginjars class_path Specifies jars containing DexGuard encryption plugin implementations. When specified, DexGuard will use plugin implementations from these jars for encrypting resources in the processed application/library. If unspecified, DexGuard will use its own default encryption implementations. The Encryption Plugins page contains more details on how to implement and use your own DexGuard plugins. This option is only useful in combination with one or more of the following encryption options: -encryptstrings , -encryptnativelibraries , -encryptassetfiles and -encryptresourcefiles . -skipnonpubliclibraryclasses Specifies to skip non-public classes while reading library jars, to speed up processing and reduce memory usage of DexGuard. By default, DexGuard reads non-public and public library classes alike. However, non-public classes are often not relevant, if they don't affect the actual program code in the input jars. Ignoring them then speeds up DexGuard, without affecting the output. Unfortunately, some libraries, including recent JSE run-time libraries, contain non-public library classes that are extended by public library classes. You then can't use this option. DexGuard will print out warnings if it can't find classes due to this option being set. -dontskipnonpubliclibraryclasses Specifies not to ignore non-public library classes. As of version 4.5, this is the default setting. -dontskipnonpubliclibraryclassmembers Specifies not to ignore package visible library class members (fields and methods). By default, DexGuard skips these class members while parsing library classes, as program classes will generally not refer to them. Sometimes however, program classes reside in the same packages as library classes, and they do refer to their package visible class members. In those cases, it can be useful to actually read the class members, in order to make sure the processed code remains consistent. -keepdirectories [ directory_filter ] Specifies the directories to be kept in the output jars (or apks, aabs, aars, wars, ears, jmods, zips, or directories). By default, directory entries are removed. This reduces the jar size, but it may break your program if the code tries to find them with constructs like \" com.example.MyClass.class.getResource(\"\") \". You'll then want to keep the directory corresponding to the package, \" -keepdirectories com.example \". If the option is specified without a filter, all directories are kept. With a filter, only matching directories are kept. For instance, \" -keepdirectories mydirectory \" matches the specified directory, \" -keepdirectories mydirectory/* \" matches its immediate subdirectories, and \" -keepdirectories mydirectory/** \" matches all of its subdirectories. -multidex Deprecated: this option is now applied automatically. Specifies that classes should split across multiple dex files, if the main classes.dex file has grown beyond the constraints of the dex format. The typical breaking point is more than 64K method IDs, triggered by large external libraries. The corresponding warning sign from the dx compiler is \"Unable to execute dex: method ID not in [0, 0xffff]: 65536\"). This option relies on the Android run-time and the optional Android multidex support library to glue the dex files back together when the application is run. This means that you should still add a dependency on com.android.support:multidex:* in your project, and let your Android manifest or application refer to it. Only applicable when targeting Android with the -dalvik option. Performance tip: Dynamically loading classes this way introduces some overhead when the application is started. You should preferably check if the shrinking step doesn't reduce the code to an acceptable size again. Note that you can also apply shrinking in debug builds\u2014see the documentation for the various plugins. -printmaindexlist [ filename ] Specifies to print the list of classes that are placed into the main dex and why they need to be stored there. The list is printed to the standard output or to the given file. Only applicable when the application has multiple dex files. -splitdexfile class_filter Specifies classes that should be put in a separate dex file. Each instance of this option results in a separate dex file, so you generally want to specify classes in a comma-separated list. This option automatically inserts the necessary code to lazily load the split dex files, the first time they are accessed at run-time. This option provides more control than regular multidexing, and the resulting dex files are loaded lazily instead of eagerly. You don't need the Android multidex support library in your project. Only applicable when targeting Android with the -dalvik option. Performance tip: Dynamically loading classes this way and then accessing them by reflection introduces some overhead, mostly when the classes are first accessed. You should preferably check if the shrinking step doesn't reduce the code to an acceptable size again. Note that you can also apply shrinking in debug builds\u2014see the documentation for the various plugins. Performance tip: Every reference from the main dex file to a separate dex file carries some overhead, due to reflection. If performance is important for these references, you can reduce the overhead by accessing classes through interfaces that are not in separate dex files. Counter-indication: it is currently not possible to encrypt classes that have direct references to classes in separate dex files. You may need to consider this when deciding which classes to split. Counter-indication: loading classes from a separate dex file will only work on Android 4.0 devices or later (API level 14+). -instantappfeature name activity URL Specifies one feature of an Instant App to be created. If you specify one or more of these options, DexGuard automatically transforms your traditional installed app into an Instant App, based on all specified features. It partitions and adapts the code, the Android manifest files, and the resources. It packages the features in separate apk files. Each option specifies a feature name, the activity that is the entry point of the feature, and a URL to access the feature. If many features depend on an activity, you can specify an empty feature name ('') to package it in the base apk. If two activities are closely related, you can also package them in the same feature. The Instant App example illustrates the option. -performanceprofile filename Optimizes the startup performance, given a .hprof file that is extracted right after starting the app. To obtain the correct .hprof file, do the following: Connect your mobile device to your computer and make sure you have root access. Build a debug version of your application (that is, without obfuscation, optimization and shrinking enabled). Launch your app. When your app completely started up, extract the .hprof file by performing the following steps in the terminal: Get the process id of the app. (column pid) adb shell ps | grep YOUR_APP_NAME Dump the .hprof file. You need root access for this step. adb root adb shell am dumpheap PROCESS_ID /data/local/tmp/performance.hprof Pull this file from the device to your computer. adb pull /data/local/tmp/performance.hprof Finally, move performance.hprof to your app directory and pass the filename to the -performanceprofile option. After performing these steps, you can turn obfuscation, optimization and shrinking back on. Extracting the .hprof file needs to be repeated every time you change your program in a significant way. Note : Any potential performance increase will only be noticeable on old devices (4.4 and earlier), for apps with noticeable startup times and strictly for \"cold starts\", meaning that application files are not yet loaded into memory. Counter-indication: this optimization will have no effect for classes that are encrypted or for applications that use packing (-pack). -splitdimensions [ dimension_filter ] Deprecated: split dimensions are now automatically read directly from an app bundle so this option is no longer required Specifies a filter for dimensions of resources (\"abi\", \"density\", \"language\"). The default is to split along these three dimensions. -dontcompress [ file_filter ] Specifies files that should not be compressed in output archives (apks, aabs, jars, aars, wars, ears, jmods, or zips). Some environments or applications may then be able to map the files into memory. For example, the Android run-time can access uncompressed images or raw files efficiently, reducing the amount of RAM that is required. This option is generally combined with the -zipalign option below, to specify the optimal alignment of the data. The option is mostly relevant when processing an Android app or creating an app bundle. -zipalign n Specifies the number of bytes to which uncompressed data in output archives should be aligned. For example, the Android run-time can access uncompressed images or raw files efficiently if they are aligned to 4 bytes. This option should be combined with the -dontcompress option above, to specify which files should not be compressed. -target version Specifies the version number to be set in the processed class files. The version number can be one of 1.0 ,..., 1.9 , or the more recent short numbers 5 ,..., 12 . By default, the version numbers of the class files are left unchanged. You can also downgrade class files to older versions than Java 8. DexGuard changes their version numbers and backports Java 8 constructs. DexGuard generally doesn't backport changes in the Java runtime, except for the Java 8 stream API and the Java 8 date API, if you add the backported libraries net.sourceforge.streamsupport and org.threeten as input, respectively. Note: When targeting Android with the -dalvik option, this option has the following effect: 1.6: targeting Android 4.3- devices, backporting any Java 7/8 features. 1.7 (default): targeting Android 4.4+ devices, backporting Java 8 features. 1.8: targeting Android 7.0+ devices, backporting lambda expressions, using Dex format 037. Note: When building Android applications, the property minSdkVersion contained in the AndroidManifest.xml is taken into account to properly setup the target setting. In general it is not necessary to specify a custom -target setting on your own. -forceprocessing Specifies to process the input, even if the output seems up to date. The up-to-dateness test is based on a comparison of the date stamps of the specified input, output, and configuration files or directories.","title":"Input/Output Options"},{"location":"usage.html#keepcodeoptions","text":"-keep [ , modifier ,...] class_specification Specifies classes and class members (fields and methods) to be preserved as entry points to your code. For example, in order to keep an application , you can specify the main class along with its main method. In order to process a library , you should specify all publicly accessible elements. -keepclassmembers [ , modifier ,...] class_specification Specifies class members to be preserved, if their classes are preserved as well. For example, you may want to keep all serialization fields and methods of classes that implement the Serializable interface. -keepclasseswithmembers [ , modifier ,...] class_specification Specifies classes and class members to be preserved, on the condition that all of the specified class members are present. For example, you may want to keep all applications that have a main method, without having to list them explicitly. -keepnames class_specification Short for -keep , allowshrinking class_specification Specifies classes and class members whose names are to be preserved, if they aren't removed in the shrinking phase. For example, you may want to keep all class names of classes that implement the Serializable interface, so that the processed code remains compatible with any originally serialized classes. Classes that aren't used at all can still be removed. Only applicable when obfuscating. -keepclassmembernames class_specification Short for -keepclassmembers , allowshrinking class_specification Specifies class members whose names are to be preserved, if they aren't removed in the shrinking phase. For example, you may want to preserve the name of the synthetic class$ methods when processing a library compiled by JDK 1.2 or older, so obfuscators can detect it again when processing an application that uses the processed library (although DexGuard itself doesn't need this). Only applicable when obfuscating. -keepclasseswithmembernames class_specification Short for -keepclasseswithmembers , allowshrinking class_specification Specifies classes and class members whose names are to be preserved, on the condition that all of the specified class members are present after the shrinking phase. For example, you may want to keep all native method names and the names of their classes, so that the processed code can still link with the native library code. Native methods that aren't used at all can still be removed. If a class file is used, but none of its native methods are, its name will still be obfuscated. Only applicable when obfuscating. -keepcode [ , modifier ,...] class_specification Specifies code attributes to be preserved, if their methods are preserved as well. -if class_specification Specifies classes and class members that must be present to activate the subsequent keep option ( -keep , -keepclassmembers ,...). The condition and the subsequent keep option can share wildcards and references to wildcards. For example, you can keep classes on the condition that classes with related names exist in your project, with frameworks like Dagger and Butterknife . -printseeds [ filename ] Specifies to exhaustively list classes and class members matched by the various -keep options. The list is printed to the standard output or to the given file. The list can be useful to verify if the intended class members are really found, especially if you're using wildcards. For example, you may want to list all the application classes that you are keeping.","title":"Keep Options for Code"},{"location":"usage.html#keepresourcesoptions","text":"-keepresourcefiles [ file_filter ] Specifies the Android resource files that should be preserved, with their original names. By default, the shrinking step removes Android resource files that appear to be unused. The obfuscation step additionally renames the remaining files with short, meaningless names or names from a given dictionary. With this option, you can preserve matching files, with their original names. The filter is applied to the complete file names, typically of the form \"res/**\", for instance res/xml/config.xml . For example, you should keep the AndroidManifest.xml file as the main entry point when processing an Android application . You may also need to apply the option if your code relies on the extension of the file name. Only applicable when processing Android applications or libraries. Counter-indication: Android internally makes a distinction between resources and the corresponding resource files. They can even have different names. If your code accesses a resource file through some sort of reflection, you generally need to preserve its resource with the -keepresources option, rather than this option. -keepresources [ , keepresources_modifier ,...] [ name_filter ] Specifies the Android resources that should be preserved, with their original names. Binary Android resource files are stored in the res directory and contain an index of all defined resources (XML files, image files, etc). Each resource is identified by a name and by a numeric identifier. The shrinking step removes resources that appear to be unused. The optimization step may inline unambiguous resources in code and in other resources, as well as remove duplicate and empty resources. The obfuscation step additionally obfuscates their names. With this option, you can preserve resources with their original names, if they are still required, for instance for Resources#getIdentifier(name, type, package) . The filter is applied to strings of the form \"type/name\", for example \" layout/main \" or \" drawable/icon \". Only applicable when processing Android applications or libraries. -keepresourcexmlelements [ name_filter ] Specifies the XML elements in the Android resource XML files that should be preserved. The optimization step may inline XML information in the Java code, for example the values of meta-data entries in the Android Manifest. When shrinking is enabled, DexGuard may additionally remove XML elements that are no longer being used after the inlining step. With this option, you can preserve XML elements, if they are still required. The filter is applied to strings of the form \"element/element/.../element\", based on the names of the nested XML elements. By appending an attribute filter of the form \"@name=value\", you can additionally refine the filter to only match elements that have an attribute with the given name and value. -keepresourcexmlattributenames [ name_filter ] Specifies the Android resource XML attribute names that should be preserved. Binary Android resource XML files are stored in the res directory and contain XML elements with attributes. Each attribute is identified by a name, but often also by a numeric identifier. The obfuscation step can then remove the name. you can preserve it with this option, if it is still required, for AttributeSet#getAttributeValue(namespace, name) or AttributeSet#getAttributeName(id) . The filter is applied to strings of the form \"element/element/.../element/attribute\", based on the names of the nested elements and the attributes. For example, the Android runtime somewhat arbitrarily requires the names of the attributes \"installLocation\", \"versionCode\", and \"name\", in some elements in the Android manifest file. The examples for processing a complete Android application and for publishing on the Samsung app market show how they are preserved. Only applicable when obfuscating Android code.","title":"Keep Options for Resources"},{"location":"usage.html#shrinkingoptions","text":"-dontshrink Specifies not to shrink the input. By default, DexGuard shrinks the code and resources: it removes all unused classes, class members, resources, resource files, assets files, and native libraries. It only keeps the ones listed by the various -keep options, and the ones on which they depend, directly or indirectly. It also applies a shrinking step after each optimization step, since some optimizations may open up the possibility to remove more code and resources. -printusage [ filename ] Specifies to list dead code of the input class files. The list is printed to the standard output or to the given file. For example, you can list the unused code of an application . Only applicable when shrinking. -printresourceusage [ filename ] Specifies to list unused resources in the input APK. The list is printed to the standard output or to the given file. Only applicable when shrinking and targeting Android with -dalvik . -whyareyoukeeping class_specification Specifies to print details on why the given classes and class members are being kept in the shrinking step. This can be useful if you are wondering why some given element is present in the output. In general, there can be many different reasons. This option prints the shortest chain of methods to a specified seed or entry point, for each specified class and class member. In the current implementation, the shortest chain that is printed out may sometimes contain circular deductions -- these do not reflect the actual shrinking process. If the -verbose option if specified, the traces include full field and method signatures. Only applicable when shrinking.","title":"Shrinking Options"},{"location":"usage.html#optimizationoptions","text":"-dontoptimize Specifies not to optimize the input class files. By default, DexGuard optimizes all code and resources. It inlines and merges classes, class members, resources, and resource files. It optimizes all methods at a bytecode level. -optimizations optimization_filter Specifies the optimizations to be enabled and disabled, at a more fine-grained level. Only applicable when optimizing. This is an expert option. -optimizationpasses n Specifies the number of optimization passes to be performed. By default, a single pass is performed. Multiple passes may result in further improvements. If no improvements are found after an optimization pass, the optimization is ended. Only applicable when optimizing. -assumenosideeffects class_specification Specifies methods that don't have any side effects, other than possibly returning a value. For example, the method System.currentTimeMillis() returns a value, but it doesn't have any side effects. In the optimization step, DexGuard can then remove calls to such methods, if it can determine that the return values aren't used. DexGuard will analyze your program code to find such methods automatically. It will not analyze library code, for which this option can therefore be useful. For example, you could specify the method System.currentTimeMillis() , so that any idle calls to it will be removed. With some care, you can also use the option to remove logging code . Note that DexGuard applies the option to the entire hierarchy of the specified methods. Only applicable when optimizing. In general, making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumenoexternalsideeffects class_specification Specifies methods that don't have any side effects, except possibly on the instances on which they are called. This statement is weaker than -assumenosideeffects , because it allows side effects on the parameters or the heap. For example, the StringBuffer#append methods have side effects, but no external side effects. This is useful when removing logging code , to also remove any related string concatenation code. Only applicable when optimizing. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumenoescapingparameters class_specification Specifies methods that don't let their reference parameters escape to the heap. Such methods can use, modify, or return the parameters, but not store them in any fields, either directly or indirectly. For example, the method System.arrayCopy does not let its reference parameters escape, but method System.setSecurityManager does. Only applicable when optimizing. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumenoexternalreturnvalues class_specification Specifies methods that don't return reference values that were already on the heap when they are called. For example, the ProcessBuilder#start returns a Process reference value, but it is a new instance that wasn't on the heap yet. Only applicable when optimizing. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -assumevalues class_specification Specifies fixed values or ranges of values for primitive fields and methods. For example, you can optimize your app for given Android SDK versions by specifying the supported range in the version constant. ProGuard can then optimize away code paths for older versions. Making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you're doing! -allowaccessmodification Specifies that the access modifiers of classes and class members may be broadened during processing. This can improve the results of the optimization step. For instance, when inlining a public getter, it may be necessary to make the accessed field public too. Although Java's binary compatibility specifications formally do not require this (cfr. The Java Language Specification, Third Edition , Section 13.4.6 ), some virtual machines would have problems with the processed code otherwise. Only applicable when optimizing (and when obfuscating with the -repackageclasses option). Counter-indication: you probably shouldn't use this option when processing code that is to be used as a library, since classes and class members that weren't designed to be public in the API may become public. -mergeinterfacesaggressively Specifies that interfaces may be merged, even if their implementing classes don't implement all interface methods. This can reduce the size of the output by reducing the total number of classes. Note that Java's binary compatibility specifications allow such constructs (cfr. The Java Language Specification, Third Edition , Section 13.5.3 ), even if they are not allowed in the Java language (cfr. The Java Language Specification, Third Edition , Section 8.1.4 ). Only applicable when optimizing. Counter-indication: setting this option can reduce the performance of the processed code on some JVMs, since advanced just-in-time compilation tends to favor more interfaces with fewer implementing classes. Worse, some JVMs may not be able to handle the resulting code.","title":"Optimization Options"},{"location":"usage.html#obfuscationoptions","text":"-dontobfuscate Specifies not to obfuscate, reflect, or encrypt the input classes, resources, assets, and native libraries. By default, DexGuard obfuscates the code: it assigns new short random names to classes, class members, resources, resource files, assets files, and native libraries. It also removes internal attributes that are only useful for debugging, such as source files names, variable names, and line numbers. Finally, it applies reflection and encryption to specified elements. -printmapping [ filename ] Specifies to print the mapping from old names to new names for classes and class members that have been renamed. The mapping is printed to the standard output or to the given file. For example, it is required for subsequent incremental obfuscation , or if you ever want to make sense again of obfuscated stack traces . Only applicable when obfuscating. -applymapping filename Specifies to reuse the given name mapping that was printed out in a previous obfuscation run of DexGuard. Classes and class members that are listed in the mapping file receive the names specified along with them. Classes and class members that are not mentioned receive new names. The mapping may refer to input classes as well as library classes. This option can be useful for incremental obfuscation , i.e. processing add-ons or small patches to an existing piece of code. If the structure of the code changes fundamentally, DexGuard may print out warnings that applying a mapping is causing conflicts. You may be able to reduce this risk by specifying the option -useuniqueclassmembernames in both obfuscation runs. Only a single mapping file is allowed. Only applicable when obfuscating. -printresourcefilenamemapping [ filename ] Specifies to print the mapping from old names to new names for resource files (assets, native libraries, Android resources). The mapping is printed to the standard output or to the given file. Only applicable when obfuscating. -printresourcemapping [ filename ] Specifies to print the mapping from old ids to new ids for resource files (assets, native libraries, Android resources). The mapping is printed to the standard output or to the given file. Only applicable when obfuscating. -applyresourcemapping filename Specifies to reuse the given resource name mapping that was printed out in a previous obfuscation run of DexGuard. Resources that are listed in the mapping file receive the names specified along with them. Resources that are not mentioned receive new names. Only applicable when obfuscating. -obfuscationdictionary filename or naming scheme Specifies the dictionary file or naming scheme to use for obfuscating field and method names. By default, short names like 'a', 'b', etc. are used as obfuscated names. A dictionary file contains a list of words, separated by newlines. For example, it could contain reserved key words, identifiers with foreign characters and so on. White space, punctuation characters, duplicate words and comments preceded by a # sign are ignored. Alternatively, an internal naming scheme can be specified. Note that the chosen names hardly improve the obfuscation. Decent compilers can automatically replace them, and the effect can fairly simply be undone by obfuscating again with simpler names. The most useful application is specifying strings that are typically already present in class files (such as 'Code'), thus reducing the class file sizes just a little bit more. Only applicable when obfuscating. -classobfuscationdictionary filename or naming scheme Specifies the dictionary file or naming scheme to use for obfuscating class names. This is similar to the option -obfuscationdictionary . Only applicable when obfuscating. -packageobfuscationdictionary filename Specifies a text file from which all valid words are used as obfuscated package names. Each line contains a name. White space, punctuation characters, duplicate words and comments after a # sign are ignored. Only applicable when obfuscating. -overloadaggressively Specifies to apply aggressive overloading while obfuscating. Multiple fields and methods can then get the same names, as long as their arguments and return types are different, as required by Java bytecode (not just their arguments, as required by the Java language). This option can make the processed code even smaller (and less comprehensible). Only applicable when obfuscating. Counter-indication: the resulting class files fall within the Java bytecode specification (cfr. The Java Virtual Machine Specification, Second Edition , first paragraphs of Section 4.5 and Section 4.6 ), even though this kind of overloading is not allowed in the Java language (cfr. The Java Language Specification, Third Edition , Section 8.3 and Section 8.4.5 ). Still, some tools have problems with it. Notably, the Dalvik VM can't handle overloaded static fields. -useuniqueclassmembernames Specifies to assign the same obfuscated names to class members that have the same names, and different obfuscated names to class members that have different names (for each given class member signature). Without the option, more class members can be mapped to the same short names like 'a', 'b', etc. The option therefore increases the size of the resulting code slightly, but it ensures that the saved obfuscation name mapping can always be respected in subsequent incremental obfuscation steps. For instance, consider two distinct interfaces containing methods with the same name and signature. Without this option, these methods may get different obfuscated names in a first obfuscation step. If a patch is then added containing a class that implements both interfaces, DexGuard will have to enforce the same method name for both methods in an incremental obfuscation step. The original obfuscated code is changed, in order to keep the resulting code consistent. With this option in the initial obfuscation step , such renaming will never be necessary. This option is only applicable when obfuscating. In fact, if you are planning on performing incremental obfuscation, you probably want to avoid shrinking and optimization altogether, since these steps could remove or modify parts of your code that are essential for later additions. -distinctclassmembernames class_specification Specifies to assign distinct obfuscated names to the members of the classes matching the given class specification. Without the option, multiple class members with different JVM signatures might be mapped to the same member name like 'a', 'b', etc. The option therefore increases the size of the resulting code slightly, but it ensures that classe / interfaces only contain unique names. For instance, consider the case where through reflection, the members of the class are exposed to another language like Javascript. Javascript does not support overloaded functions and thus cannot distinguish between members with the same name. Part of your class becomes unaccessible through this interface. This can be solved by applying this flag on the classes that can be exposed. This option is only applicable when obfuscating, as the class members are otherwise not renamed. -dontusemixedcaseclassnames Specifies not to generate mixed-case class names while obfuscating. By default, obfuscated class names can contain a mix of upper-case characters and lower-case characters. This creates perfectly acceptable and usable jars. Only if a jar is unpacked on a platform with a case-insensitive filing system (say, Windows), the unpacking tool may let similarly named class files overwrite each other. Code that self-destructs when it's unpacked! Developers who really want to unpack their jars on Windows can use this option to switch off this behavior. Obfuscated jars will become slightly larger as a result. Only applicable when obfuscating. -keeppackagenames [ package_filter ] Specifies not to obfuscate the given package names. The optional filter is a comma-separated list of package names. Package names can contain ? , * , and ** wildcards, and they can be preceded by the ! negator. Only applicable when obfuscating. -flattenpackagehierarchy [ package_name ] Specifies to repackage all packages that are renamed, by moving them into the single given parent package. Without argument or with an empty string (''), the packages are moved into the root package. This option is one example of further obfuscating package names . It can make the processed code smaller and less comprehensible. Only applicable when obfuscating. -repackageclasses [ package_name ] Specifies to repackage all class files that are renamed, by moving them into the single given package. Without argument or with an empty string (''), the package is removed completely. This option overrides the -flattenpackagehierarchy option. It is another example of further obfuscating package names . It can make the processed code even smaller and less comprehensible. Its deprecated name is -defaultpackage . Only applicable when obfuscating. Counter-indication: classes that look for resource files in their package directories will no longer work properly if they are moved elsewhere. When in doubt, just leave the packaging untouched by not using this option. Note: On Android, you should not use the empty string when classes like activities, views, etc. may be renamed. The Android run-time automatically prefixes package-less names in XML files with the application package name or with android.view . This is unavoidable but it breaks the application in this case. -keepattributes [ attribute_filter ] Specifies any optional attributes to be preserved. The attributes can be specified with one or more -keepattributes directives. The optional filter is a comma-separated list of attribute names that Java virtual machines and DexGuard support. Attribute names can contain ? , * , and ** wildcards, and they can be preceded by the ! negator. For example, you should at least keep the Exceptions , InnerClasses , and Signature attributes when processing a library . You should also keep the SourceFile and LineNumberTable attributes for producing useful obfuscated stack traces . Finally, you may want to keep annotations if your code depends on them. Only applicable when obfuscating. -keepparameternames Specifies to keep the parameter names and types of methods that are kept. This option actually keeps trimmed versions of the debugging attributes LocalVariableTable and LocalVariableTypeTable . It can be useful when processing a library . Some IDEs can use the information to assist developers who use the library, for example with tool tips or autocompletion. Only applicable when obfuscating. -renamesourcefileattribute [ string ] Specifies a constant string to be put in the SourceFile attributes (and SourceDir attributes) of the class files. Note that the attribute has to be present to start with, so it also has to be preserved explicitly using the -keepattributes directive. For example, you may want to have your processed libraries and applications produce useful obfuscated stack traces . Only applicable when obfuscating. It is possible to preserve the SourceFile attribute for kept classes by specifying the Java system property obfuscate.keptclasses.dontrenamesourcefileattribute (with -D..... ). -accessthroughreflection [ ,encryptstrings ] class_specification Specifies to replace direct access to the specified classes and class members by reflection. Matching class references are then replaced by Class.forName constructs. Reads and writes of matching fields are replaced by Class.getField and Field.get/set constructs. Method invocation are replaced by Class.getMethod and Method.invoke constructs. For example, when processing the Android License Verification Library, you may want to add reflection for sensitive APIs in the Android run-time. Only applicable when obfuscating. The encryptstrings modifier additionally encrypts the strings that are created for the reflection, effectively hiding all references to the reflected class or class member. Limitation: Due to technical constraints, -accessthroughreflection cannot currently be applied to java.lang.Object methods. -obfuscatecode [ , strength ] class_specification Specifies to obfuscate the code (i.e. bytecode instructions) of the specified methods. If the class specification does not specify any methods, all methods in the specified class or classes are obfuscated. With specified methods, only the code of matching methods is obfuscated. The default obfuscation strength is low . Code obfuscation makes it more difficult to disassemble or decompile classes. Depending on the specified strength , different techniques are applied. They raise the bar for any reverse engineering attempt. Only applicable when obfuscating. Performance tip: Code obfuscation increases the code size and introduces some minor processing overhead in the obfuscated methods at runtime. You should use a low obfuscation strength for methods that are critical for application performance or that execute a large number of arithmetic calculations. Limitation: Due to technical constraints, you can currently not apply code obfuscation to methods using synchronization blocks (however methods marked synchronized are fine). -virtualizecode class_specification Specifies to virtualize the code (i.e. bytecode instructions) of the specified methods. If the class specification does not specify any methods, all methods in the specified class or classes are virtualized. With specified methods, only the code of matching methods is virtualized. Code virtualization makes it more difficult to apply static or dynamic analysis of the application classes as it rewrites the bodies of virtualized methods with a randomized instruction set that is executed by an inlined virtual machine. It considerably raises the bar for any reverse engineering attempt. Only applicable when obfuscating. Performance tip: Code virtualization increases the code size and introduces some processing overhead in the virtualized methods at runtime. You should not virtualize methods that are critical for application performance. Limitation: Due to technical constraints, you can currently not apply code virtualization to initializers (constructors, static initializers) and methods using synchronization blocks (however methods marked synchronized are supported). -obfuscatejavascript file_filter Specifies that the contents of all Javascript files matching the given filter should be obfuscated using DexGuard's own built-in Javascript obfuscator. -javascriptconfiguration filename Specifies a file that contains a Javascript configuration. The configuration file will be passed to the Javascript obfuscator, to obfuscate any Javascript files specified in -obfuscatejavascript . Note: You can find more details about the integration and usage of the Javascript obfuscator in the separate Javascript obfuscator manual . -javascriptplugin filename [ string ] Use the specified plugin jar and optional string to obfuscate Javascript files. -encryptclasses [ class_filter ] -encryptclasses class_specification Specifies that classes whose names either match the given filter or class specification should be encrypted. When using a class specification, specified fields and methods are ignored as classes will always be encrypted as a whole. This makes it more difficult to disassemble or decompile them. \"Obfuscated\" would be a better word, since the processed code necessarily has to be able to reverse the encryption. It therefore increases the code size and introduces processing overhead at runtime, whenever the class is loaded or accessed. However, it raises the bar for any reverse engineering attempts. For example, if you have some sensitive license checking class, you may want to protect it by encrypting it. Only applicable when obfuscating. You can additionally protect encrypted classes by obfuscating their code with obfuscation strength medium or high. This will render the classes unusable if they are manually extracted from the DEX file. Code obfuscation should not be applied however on performance-sensitive code that is executed very frequently (e.g., tight code loops). Counter-indications: It is not possible to encrypt classes that are explicitly preserved from obfuscation (in your configuration), extended by non-encrypted classes, or created by reflection (for instance because they are referenced from XML files). Note: When encrypting classes in library projects , the code must set a temporary directory: System.setProperty(\"java.io.tmpdir\", getDir(\"files\", Context.MODE_PRIVATE).getPath()); Caveat: When encrypting classes in library projects , the encrypted classes must not contain references to classes or class members that are later on obfuscated in the final application projects. Once encrypted, classes can no longer be changed, so their references would become invalid. If encrypted classes do contain references to other non-encrypted classes in their library projects, these referenced classes and class members must be preserved from obfuscation in the application projects. If your requirements allow it, it is easier to encrypt classes when processing the final application. Performance tip: Every access from an external class to an encrypted class carries some overhead, due to reflection. If performance is important in this part of your code, you can reduce the overhead by accessing the class through an interface that is not encrypted. -encryptstrings [ string_filter ] [ -encryptstrings ] class_specification Specifies to encrypt string constants that either match the given filter or that are defined in matching classes. With a class specification without fields or methods, all strings in the matching class or classes are encrypted. With specified fields, the matching final String constants are encrypted. With specified methods, all strings in the matching methods are encrypted. String encryption makes it more difficult to find them in disassembled or decompiled code. Again, \"obfuscated\" would be a better word, since the processed code necessarily has to be able to reverse the encryption. It therefore increases the code size and introduces processing overhead whenever the string is accessed. But again, it raises the bar for any reverse engineering attempts. For example, if you have hard-coded some key string, you may want to encrypt it to hide it a bit better. Also, if you are already accessing a class or a class member through introspection, you may want to obfuscate the resulting strings containing their names in the code. Only applicable when obfuscating. Caveat: The current implementation does not support encrypting strings in static initializers in interfaces. Final string constants in interfaces are not a problem. Performance tip: Every encrypted string is decrypted on the fly at run-time, without implicit caching. If performance of encrypted strings is important in some parts of your code, you can define them as private static String fields, so they are only decrypted once, when the class is initialized. Don't declare them as final though, because the compiler will then inline them again. -adaptclassstrings [ class_filter ] Specifies that string constants that correspond to class names should be obfuscated as well. Without a filter, all string constants that correspond to class names are adapted. With a filter, only string constants in classes that match the filter are adapted. For example, if your code contains a large number of hard-coded strings that refer to classes, and you prefer not to keep their names, you may want to use this option. Primarily applicable when obfuscating, although corresponding classes are automatically kept in the shrinking step too. -keepkotlinmetadata Instructs DexGuard to process kotlin.Metadata annotations if present. Currently only shrinking and obfuscation of its content is supported. Classes containing such annotations should be excuded from optimization if this option is enabled. -adaptresourcefilenames [ file_filter ] Specifies the resource files to be renamed, based on the obfuscated names of the corresponding class files (if any). Without a filter, all resource files that correspond to class files are renamed. With a filter, only matching files are renamed. For example, see processing resource files . Only applicable when obfuscating. -adaptresourcefilecontents [ file_filter ] Specifies the resource files and native libraries whose contents are to be updated. Any class names mentioned in the resource files are renamed, based on the obfuscated names of the corresponding classes (if any). Any function names in the native libraries are renamed, based on the obfuscated names of the corresponding native methods (if any). Without a filter, the contents of all resource files updated. With a filter, only matching files are updated. The resource files are parsed and written using UTF-8 encoding. For an example, see processing resource files . Only applicable when obfuscating. Caveat: You probably only want to apply this option to text files, Android resource XML files, and native libraries, since parsing and adapting general binary files as text files can cause unexpected problems. Therefore, make sure that you specify a sufficiently narrow filter. -stripnativelibrarysections [ file_filter ] Specifies the native libraries that should undergo a removal of sections which are not needed at runtime. Note: This flag only has an effect on native libraries that also match the -adaptresourcefilecontents filter. -resourcefilenameobfuscationdictionary filename Specifies a text file from which the lines are used as obfuscated Android resource file names. Each line contains a name. Comments after a # sign are ignored. Only applicable when obfuscating Android code. -encryptmetadata [ string_filter ] Specifies the metadata in the Android Manifest that should be encrypted. All metadata whose name matches the given filter will be encrypted. DexGuard will inline the metadata values in the code and then encrypt these values in the code. The original metadata entries will be removed from the Android Manifest, unless they are explicitly kept using -keepresourcexmlelements . Only String metadata which are retrieved using Bundle.getString(int) with a integer constant (not a variable) are currently supported. -encryptassetfiles [ file_filter ] Specifies the Android asset files that should be encrypted. Asset files are stored in the assets directory and can contain any data. The obfuscation step can automatically encrypt them and make sure they are decrypted on the fly at run-time. In order for this to work, the assets must be loaded using one of the AssetManager.open methods. Only applicable when obfuscating Android code. Note: If the processed application contains at least one call to AssetManager.open(String) with a non-constant string argument, DexGuard will encrypt all assets that match the specified file filter. If there are assets that are loaded via other mechanisms, make sure they do not match the specified file filter. -encryptresources [ name_filter ] Specifies the Android resources to be encrypted. The filter is applied to strings of the form \"type/name\", for example \"string/apiKey\". Currently only String resources are supported. A resource excluded from obfuscation using -keepresources can still be encrypted by using the allowencryption modifier. Only applicable when processing Android applications. Counter-indication: resource Strings referenced from other XML files can't be encrypted. -encryptresourcefiles [ file_filter ] Specifies to encrypt Android resource files. Resource files are stored in the res directory and can contain application resources such as layout XML files. The obfuscation step can automatically encrypt them and make sure they are decrypted on the fly at run-time. Supported resources: res/layout , res/menu , and res/xml files. Counter-indication: app widgets can't decrypt resources. Don't encrypt resource files that are accessed by app widgets or retrieved via android.content.pm.PackageManager. Only applicable when processing Android applications. Counter-indication: resource file encryption is not compatible with Android App Bundles. -encryptnativelibraries [ file_filter ] Specifies the Android native libraries that should be encrypted. Native libraries are packaged in subdirectories of the lib directory. The obfuscation step can automatically encrypt them and make sure they are decrypted on the fly at run-time. In order for this to work, your application must load the native library using System.loadLibrary(String) or be a dependency of an encrypted native library. Your configuration can then specify \" -encryptnativelibraries lib/**/libmycode.so \", matching the complete path and name of the library. Note that the paths are the paths as you find them in the output, with lib/ , not libs/ . Also note the wildcards: if a library is encrypted for one platform, it must be encrypted for all platforms. Only applicable when obfuscating Android code. Note: For a more secure way of loading your encrypted native libraries, you can include lib/dexguard-nativeloader.aar as a dependency to your project. Note: If the processed application contains at least one call to System.loadLibrary(String) with a non-constant string argument, DexGuard will encrypt all native libraries that match the specified file filter. If there are libraries that are loaded via other mechanisms, make sure they do not match the specified file filter. Note: When encrypting native libraries in library projects , the code should set a temporary directory, for maximum portability: System.setProperty(\"java.io.tmpdir\", getDir(\"files\", Context.MODE_PRIVATE).getPath()); -randomizationseed integer_seed Specifies an additional value that is taken into account when generating the seed value to randomize the obfuscation. -printclassencryption [ filename ] Specifies to print the class encryption groups, and the plugins which were used to encrypt each class group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting classes. -printstringencryption [ filename ] Specifies to print the string encryption groups, and the plugins which were used to encrypt each string group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting strings. -printassetencryption [ filename ] Specifies to print the asset encryption groups, and the plugin which was used to encrypt each asset group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting assets. -printresourceencryption [ filename ] Specifies to print the resources that are encrypted, and the plugin which was used to encrypt them. The mapping is printed to the standard output or to the given file. Only applicable when encrypting resources. -printnativelibraryencryption [ filename ] Specifies to print the native library encryption groups, and the plugins which was used to encrypt each group. The mapping is printed to the standard output or to the given file. Only applicable when encrypting native libraries.","title":"Obfuscation Options"},{"location":"usage.html#preverificationoptions","text":"-dontpreverify Specifies not to preverify the processed class files. By default, class files are preverified if they are targeted at Java Micro Edition or at Java 6 or higher. For Java Micro Edition, preverification is required, so you will need to run an external preverifier on the processed code if you specify this option. For Java 6, preverification is optional, but as of Java 7, it is required. Only when eventually targeting Android, it is not necessary, so you can then switch it off to reduce the processing time a bit. This option is not relevant for Android applications. -microedition Specifies that the processed class files are targeted at Java Micro Edition. The preverifier will then add the appropriate StackMap attributes, which are different from the default StackMapTable attributes for Java Standard Edition. For example, you will need this option if you are processing midlets. This option is not relevant for Android applications. -android Specifies that the processed class files are targeted at the Android platform. DexGuard will then make sure some features like string encryption and class encryption are compatible with Android. For example, you may need this option if you are processing libraries for Android. This option is always set in DexGuard.","title":"Preverification Options"},{"location":"usage.html#conversionoptions","text":"-dalvik Specifies that the code is targeted at the Android platform and the Dalvik virtual machine. DexGuard will then convert the processed class files to the Dex format. The output will contain a single classes.dex file instead of many .class files. For example, you probably want to use this option if you are processing Android applications . -protobuffer Deprecated: app bundles are now automatically detected so this option is no longer required Specifies to write the processed resource files in protobuffer format.","title":"Conversion Options"},{"location":"usage.html#signingoptions","text":"-keystore filename Specifies the key store file that contains your private signing key. Only required if you want DexGuard to sign the output jars. -keystorepassword password Specifies the password of the key store. This can also be a pin in the case of a PKCS11 configuration. Only required if you want DexGuard to sign the output jars. -keyalias alias Specifies the alias of the key that you want to select from the key store. Only required if you want DexGuard to sign the output jars. -keypassword password Specifies the password of the key. Only required if you want DexGuard to sign the output jars. -pkcs11configuration filename Specifies the configuration file that contains the connection information to the PKCS11 keystore. Only required if you want DexGuard to sign the output jars using PKCS11. More about the configuration format can be found by running man 5 pkcs11.conf . -certificatelineage filename Specifies the certificate lineage file, if you want to apply key rotation. You then need to specify the corresponding oldest and newest key stores, aliases, and passwords. Alternatively, you can specify the entire lineage, without a lineage file, as a list of key stores, aliases, and passwords (oldest to newest). -apksignatureschemes [ signature_scheme_filter ] Specifies a filter for apk signing schemes that should be used when creating an apk. DexGuard supports the following apk signing schemes: v1, v2, v3, v4 . By default, if no apk signature scheme option is provided, v1 and v2 signature schemes are enabled.","title":"Jar Signing Options"},{"location":"usage.html#raspoptions","text":"See RASP for more information on these options: -raspchecks RASP detector list Enable one or more of the RASP detectors. -raspcontinueon RASP detector list By default, an app will crash on a RASP threat, unless listed. -raspcallback class_specification Custom callback that will be executed when a RASP threat is detected. -raspclassfilter class_filter Class filter used to refine the RASP injection locations. -raspaggressiveness Detector name aggressiveness level Change the level of aggressiveness of RASP injection for a certain RASP detector. -raspfiletamperlist file list List of files checked by the RASP File Tamper detector. -raspcertificatehash certificate hash Specify the certificate hash of the signing key which will be used to sign the app.","title":"RASP Options"},{"location":"usage.html#generaloptions","text":"-verbose Specifies to write out some more information during processing. If the program terminates with an exception, this option will print out the entire stack trace, instead of just the exception message. -dontnote [ class_filter ] -dontnote [' type [ :id ]'] Specifies not to print notes about potential mistakes or omissions in the configuration, such as typos in class names or missing options that might be useful. The optional filter is a regular expression; DexGuard doesn't print notes about classes with matching names. You can also specify a type with an optional id to suppress advice and warnings that are printed in the protection report. Quotes When writing a -dontnote rule for the protection report that contains an id the entire argument has to be quoted as shown below. -dontnote ' report_message : 1234 ' -dontwarn [ class_filter ] Specifies not to warn about unresolved references and other important problems at all. The optional filter is a regular expression; DexGuard doesn't print warnings about classes with matching names. Ignoring warnings can be dangerous. For instance, if the unresolved classes or class members are indeed required for processing, the processed code will not function properly. Only use this option if you know what you're doing! -ignorewarnings Specifies to print any warnings about unresolved references and other important problems, but to continue processing in any case. Ignoring warnings can be dangerous. For instance, if the unresolved classes or class members are indeed required for processing, the processed code will not function properly. Only use this option if you know what you're doing! -printconfiguration [ filename ] Specifies to write out the entire configuration that has been parsed, with included files and replaced variables. The structure is printed to the standard output or to the given file. This can sometimes be useful to debug configurations, or to convert XML configurations into a more readable format. -printlibraryconfiguration filename Specifies to generate and write out the configuration that is needed when you additionally process the obfuscated output again with ProGuard or DexGuard. The configuration provides keep rules for all classes, class members and resource files whose use can no longer be found after the primary obfuscation step, due to reflection, encryption, ... Any keep rule from the input configuration will also be copied to the library configuration, if it is still applicable. If the option is not specified, the configuration is still automatically generated and written to the \u2018proguard.txt\u2019 file inside the output AAR for all projects that have at least one keep rule with the \u2018 asapi \u2019 modifier. Only applicable to library projects. -printstatistics [ filename ] Specifies to write out extended statistics on package-level. The statistics are printed to the standard output or to the given file. This can be useful to verify or optimize configurations. Note: by default, the package hierarchy up to level 3 will be displayed, e.g. com.example.subpackage . This can be customised with some Java system properties, which can be set as JVM arguments (with -D... ): statistics.maxlevel= level : the maximum package hierarchy level to display. statistics.fold= package_filter : packages matching the filter will be folded. statistics.expand= package_filter : packages matching the filter will be expanded. -printinjectmapping [ filename ] Specifies to write out a mapping of which RASP checking code was injected into which method in your application. -printthreatcastmapping [ filename ] Specifies to write out a mapping file that lists the human readable method names for each check location identifier. This mapping file can be uploaded to your ThreatCast server portal , to provide more info on the runtime threats your app is facing. -threatcastappuseridgetter class_specification Specifies a custom App User ID (AUID) getter method that will be executed to collect the AUID and send it to ThreatCast when a RASP threat is detected. -addconfigurationdebugging Specifies to instrument the processed code with debugging statements that print out suggestions for missing DexGuard configuration. This can be very useful to get practical hints at run-time , if your processed code crashes because it still lacks some configuration for reflection. For example, the code may be serializing classes with the GSON library and you may need some configuration for it. You can generally just copy/paste the suggestions from the console into your configuration file. Counter-indication: do not use this option in release versions, as it adds obfuscation information to the processed code. -disableprotectionreport Disables the generation of protection reports. When protection report generation is disabled, DexGuard does not create the HTML report which summarizes the impact of DexGuard on the generated outputs. -disabletelemetry Disables the sending of usage reports to Guardsquare's servers. -protectionreportdirectory directoryname Specifies the location where protection reports shall be created. By default, such files are created in the 'reports' directory. -intermediatedirectory directoryname Specifies the location of DexGuard's intermediate directory. This is an optional rule that puts the directory of intermediate files in the specified location and prevents it from being removed. When not provided, the directory is created in the default location for temporary directories and is removed after processing. When the specified directory is not empty, the \u2018allowoverwrite\u2019 modifier should be provided. Note that this may overwrite existing files and directories in the specified location, so be careful when using this modifier. allowoverwrite Modifier for intermediatedirectory that specifies that files and directories in the given intermediate directory may be overwritten. This is useful when you have specified a non-existent or empty directory that DexGuard has used during a first run, and you want to reuse this directory for intermediate files in subsequent runs. Be careful with this modifier when you have specified an intermediate directory that is not DexGuard-specific. -disableversioncheck Disables performing the version check. By default, this check is enabled to check whether a newer DexGuard version is available. If enabled, a message is added to the build log, warning you when a new release is available and notifying you that you might want to try out a new beta release.","title":"General Options"},{"location":"usage.html#classpath","text":"DexGuard accepts a generalization of class paths to specify input files and output files. A class path consists of entries, separated by the traditional path separator (e.g. ' : ' on Unix, or ' ; ' on Windows platforms). The order of the entries determines their priorities, in case of duplicates. Each input entry can be: A class file, dex file, or resource file, An apk file, containing any of the above, An aab file, containing any of the above, A jar file, containing any of the above, An aar file, containing any of the above, A war file, containing any of the above, An ear file, containing any of the above, A jmod file, containing any of the above, A zip file, containing any of the above, A directory (structure), containing any of the above. The paths of directly specified class files and resource files is ignored, so class files should generally be part of a jar file, an aar file, a war file, an ear file, a zip file, or a directory. In addition, the paths of class files should not have any additional directory prefixes inside the archives or directories. Each output entry can be: An apk file, in which all processed and converted class files and resource files will be collected. An aab file, in which any and all of the above will be collected, A jar file, in which any and all of the above will be collected, An aar file, in which any and all of the above will be collected, A war file, in which any and all of the above will be collected, An ear file, in which any and all of the above will be collected, A jmod file, in which any and all of the above will be collected, A zip file, in which any and all of the above will be collected, A directory, in which any and all of the above will be collected. When writing output entries, DexGuard generally packages the results in a sensible way, reconstructing the input entries as much as required. Writing everything to an output directory is the most straightforward option: the output directory will contain a complete reconstruction of the input entries. The packaging can be almost arbitrarily complex though: you could process an entire application, packaged in a zip file along with its documentation, writing it out as a zip file again. The Examples section shows a few ways to restructure output archives . Files and directories can be specified as discussed in the section on file names below. In addition, DexGuard provides the possibility to filter the class path entries and their contents, based on their full relative file names. Each class path entry can be followed by up to 9 types of file filters between parentheses, separated by semi-colons: A filter for all jmod names that are encountered, A filter for all aar names that are encountered, A filter for all aab names that are encountered, A filter for all apk names that are encountered, A filter for all zip names that are encountered, A filter for all ear names that are encountered, A filter for all war names that are encountered, A filter for all jar names that are encountered, A filter for all class file names and resource file names that are encountered. If fewer than 9 filters are specified, they are assumed to be the latter filters. Any empty filters are ignored. More formally, a filtered class path entry looks like this: classpathentry([[[[[[[[jmodfilter;]aarfilter;]aabfilter;]apkfilter;]zipfilter;]earfilter;]warfilter;]jarfilter;]filefilter) Square brackets \"[]\" mean that their contents are optional. For example, \" android.jar(java/**.class,javax/**.class) \" matches all class files in the java and javax directories inside the android jar. For example, \" input.jar(!**.gif,images/**) \" matches all files in the images directory inside the input jar, except gif files. The different filters are applied to all corresponding file types, irrespective of their nesting levels in the input; they are orthogonal. For example, \" input.war(lib/**.jar,support/**.jar;**.class,**.gif) \" only considers jar files in the lib and support directories in the input war, not any other jar files. It then matches all class files and gif files that are encountered. The filters allow for an almost infinite number of packaging and repackaging possibilities. The Examples section provides a few more examples for filtering input and output .","title":"Class Paths"},{"location":"usage.html#filename","text":"DexGuard accepts absolute paths and relative paths for the various file names and directory names. A relative path is interpreted as follows: relative to the base directory, if set, or otherwise relative to the configuration file in which it is specified, if any, or otherwise relative to the working directory. The names can contain Java system properties (or Ant properties, when using Ant), delimited by angular brackets, ' < ' and ' > '. The properties are automatically replaced by their corresponding values. For example, <java.home>/lib/rt.jar is automatically expanded to something like /usr/local/java/jdk/jre/lib/rt.jar . Similarly, <user.home> is expanded to the user's home directory, and <user.dir> is expanded to the current working directory. Names with special characters like spaces and parentheses must be quoted with single or double quotes. Each file name in a list of names has to be quoted individually. Note that the quotes themselves may need to be escaped when used on the command line, to avoid them being gobbled by the shell. For example, on the command line, you could use an option like '-injars \"my program.jar\":\"/your directory/your program.jar\"' .","title":"File Names"},{"location":"usage.html#filefilters","text":"Like general filters , a file filter is a comma-separated list of file names that can contain wildcards. Only files with matching file names are read (in the case of input jars), or written (in the case of output jars). The following wildcards are supported: Wildcard Meaning ? matches any single character in a file name. * matches any part of a filename not containing the directory separator. ** matches any part of a filename, possibly containing any number of directory separators. For example, \" java/**.class,javax/**.class \" matches all class files in the java and javax . Furthermore, a file name can be preceded by an exclamation mark ' ! ' to exclude the file name from further attempts to match with subsequent file names. For example, \" !**.gif,images/** \" matches all files in the images directory, except gif files. The Examples section provides a few more examples for filtering input and output .","title":"File Filters"},{"location":"usage.html#filters","text":"DexGuard offers options with filters for many different aspects of the configuration: names of files, directories, classes, packages, attributes, optimizations, etc. A filter is a list of comma-separated names that can contain wildcards. Only names that match an item on the list pass the filter. The supported wildcards depend on the type of names for which the filter is being used, but the following wildcards are typical: Wildcard Meaning ? matches any single character in a name. * matches any part of a name not containing the package separator or directory separator. ** matches any part of a name, possibly containing any number of package separators or directory separators. For example, \" foo,*bar \" matches the name foo and all names ending with bar . Furthermore, a name can be preceded by a negating exclamation mark ' ! ' to exclude the name from further attempts to match with subsequent names. So, if a name matches an item in the filter, it is accepted or rejected right away, depending on whether the item has a negator. If the name doesn't match the item, it is tested against the next item, and so on. It if doesn't match any items, it is accepted or rejected, depending on the whether the last item has a negator or not. For example, \" !foobar,*bar \" matches all names ending with bar , except foobar .","title":"Filters"},{"location":"usage.html#namingschemes","text":"DexGuard currently offers three naming schemes, which serve as an alternative to providing file-based dictionaries for renaming class and member names. Naming Scheme Description Example <keptnames> Recycle class and member names that were explicitly kept. -obfuscationdictionary <keptnames> <alphabetic> Shortcut for a simple alphabetic naming scheme (like ProGuard). -obfuscationdictionary <alphabetic> <utf8> Use UTF-8 characters. (deprecated: may cause issues on certain devices) -obfuscationdictionary <utf8>","title":"Naming schemes"},{"location":"usage.html#keepoverview","text":"The various -keep options for shrinking and obfuscation may seem a bit confusing at first, but there's actually a pattern behind them. The following table summarizes how they are related: Keep From being removed or renamed From being renamed Classes and class members -keep -keepnames Class members only -keepclassmembers -keepclassmembernames Classes and class members, if class members present -keepclasseswithmembers -keepclasseswithmembernames Each of these -keep options is of course followed by a specification of the classes and class members (fields and methods) to which it should be applied. If you're not sure which option you need, you should probably simply use -keep . It will make sure the specified classes and class members are not removed in the shrinking step, and not renamed in the obfuscation step. If you specify a class, without class members, DexGuard only preserves the class and its parameterless constructor as entry points. It may still remove, optimize, or obfuscate its other class members. If you specify a method, DexGuard only preserves the method as an entry point. Its code may still be optimized and adapted.","title":"Overview of Keep Options"},{"location":"usage.html#keepoptionmodifiers","text":"includedescriptorclasses Specifies that any classes in the type descriptors of the methods and fields that the -keep option keeps should be kept as well. This is typically useful when keeping native method names , to make sure that the parameter types of native methods aren't renamed either. Their signatures then remain completely unchanged and compatible with the native libraries. includecode Specifies that code attributes of the methods that the -keep option keeps should be kept as well, i.e. may not be optimized or obfuscated. This is typically useful for already optimized or obfuscated classes, to make sure that their code is not modified during optimization. allowshrinking Specifies that the entry points specified in the -keep option may be shrunk, even if they have to be preserved otherwise. That is, the entry points may be removed in the shrinking step, but if they are necessary after all, they may not be optimized or obfuscated. allowoptimization Specifies that the entry points specified in the -keep option may be optimized, even if they have to be preserved otherwise. That is, the entry points may be altered in the optimization step, but they may not be removed or obfuscated. This modifier is only useful for achieving unusual requirements. allowobfuscation Specifies that the entry points specified in the -keep option may be obfuscated, even if they have to be preserved otherwise. That is, the entry points may be renamed in the obfuscation step, but they may not be removed or optimized. This modifier is only useful for achieving unusual requirements. allowmultidexing Deprecated: This modifier is now the default behavior of keep rules. To specify classes that need to end up in the primary dex, see inmaindex . Specifies that the entry points specified in the -keep option may be placed in any secondary dex files, even if they have to be preserved otherwise. That is, the entry points may be present in a secondary dex file, but they may not be removed, optimized or renamed. This option is only useful when you have multiple dex files. inmaindex Specifies that the entry points specified in the -keep option need to end up in the primary dex file. This option is only useful when you have multiple dex files. DexGuard already checks which classes need to be in the primary dex due to constraints of Android API 19 and below, so this option should rarely be necessary. asapi Specifies that the entry point(s) specified in the -keep option are part of the library\u2019s API. API keep rules are processed exactly the same way as other keep rules, but they are not copied into the output library configuration. Only applicable to library projects.","title":"Keep Option Modifiers"},{"location":"usage.html#keepresourcesoptionmodifiers","text":"allowobfuscation Specifies that the resources specified in the -keepresources option may be obfuscated, even if they have to be preserved otherwise. That is, the resources may be renamed in the obfuscation step, but they may not be removed. This modifier is only useful for achieving unusual requirements. allowencryption Specifies that the resource specified in the -keepresources option can be encrypted even if its name should be kept as-is. This modifier is only useful in combination with -encryptresource .","title":"Keep Resources Option Modifiers"},{"location":"usage.html#strengthmodifiers","text":"low Specifies that the code of methods specified in the -obfuscatecode option should be obfuscated with low strength. The code size of obfuscated methods will slightly increase, while their runtime performance might decrease slightly. medium Specifies that the code of methods specified in the -obfuscatecode option should be obfuscated with moderate strength. The code size of obfuscated methods will increase moderately, while their runtime performance might decrease. high Specifies that the code of methods specified in the -obfuscatecode option should be obfuscated with high strength. The code size of obfuscated methods will increase moderately, while their runtime performance might decrease considerably. This modifier should not be used for performance critical methods.","title":"Strength Modifiers"},{"location":"usage.html#classspecification","text":"A class specification is a template of classes and class members (fields and methods). It is used in the various -keep options and in the -assumenosideeffects option. The corresponding option is only applied to classes and class members that match the template. The template was designed to look very Java-like, with some extensions for wildcards. To get a feel for the syntax, you should probably look at the examples , but this is an attempt at a complete formal definition: [@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname] [{ [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] <fields> | (fieldtype fieldname); [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] <methods> | <init>(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...)); [@annotationtype] [[!]public|private|protected|static ... ] *; ... }] Square brackets \"[]\" mean that their contents are optional. Ellipsis dots \"...\" mean that any number of the preceding items may be specified. A vertical bar \"|\" delimits two alternatives. Non-bold parentheses \"()\" just group parts of the specification that belong together. The indentation tries to clarify the intended meaning, but white-space is irrelevant in actual configuration files. The class keyword refers to any interface or class. The interface keyword restricts matches to interface classes. The enum keyword restricts matches to enumeration classes. Preceding the interface or enum keywords by a ! restricts matches to classes that are not interfaces or enumerations, respectively. Every classname must be fully qualified, e.g. java.lang.String . Inner classes are separated by a dollar sign \" $ \", e.g. java.lang.Thread$State . Class names may be specified as regular expressions containing the following wildcards: Wildcard Meaning ? matches any single character in a class name, but not the package separator. For example, \" com.example.Test? \" matches \" com.example.Test1 \" and \" com.example.Test2 \", but not \" com.example.Test12 \". * matches any part of a class name not containing the package separator. For example, \" com.example.*Test* \" matches \" com.example.Test \" and \" com.example.YourTestApplication \", but not \" com.example.mysubpackage.MyTest \". Or, more generally, \" com.example.* \" matches all classes in \" com.example \", but not in its subpackages. ** matches any part of a class name, possibly containing any number of package separators. For example, \" **.Test \" matches all Test classes in all packages except the root package. Or, \" com.example.** \" matches all classes in \" com.example \" and in its subpackages. <n> matches the n 'th matched wildcard in the same option. For example, \" com.example.*Foo<1> \" matches \" com.example.BarFooBar \". For additional flexibility, class names can actually be comma-separated lists of class names, with optional ! negators, just like file name filters. This notation doesn't look very Java-like, so it should be used with moderation. For convenience and for backward compatibility, the class name * refers to any class, irrespective of its package, when used on its own (e.g. -keep class * ). The extends and implements specifications are typically used to restrict classes with wildcards. They are currently equivalent, specifying that only classes extending or implementing the given class (directly or indirectly) qualify. The given class itself is not included in this set. If required, it should be specified in a separate option. The @ specifications can be used to restrict classes and class members to the ones that are annotated with the specified annotation types. An annotationtype is specified just like a classname . Fields and methods are specified much like in Java, except that method argument lists don't contain argument names (just like in other tools like javadoc and javap ). The specifications can also contain the following catch-all wildcards: Wildcard Meaning <init> matches any constructor. <fields> matches any field. <methods> matches any method. * matches any field or method. Note that the above wildcards don't have return types. Only the <init> wildcard has an argument list. Fields and methods may also be specified using regular expressions. Names can contain the following wildcards: Wildcard Meaning ? matches any single character in a method name. * matches any part of a method name. <n> matches the n 'th matched wildcard in the same option. Types in descriptors can contain the following wildcards: Wildcard Meaning % matches any primitive type (\" boolean \", \" int \", etc, but not \" void \"). ? matches any single character in a class name. * matches any part of a class name not containing the package separator. ** matches any part of a class name, possibly containing any number of package separators. *** matches any type (primitive or non-primitive, array or non-array). ... matches any number of arguments of any type. <n> matches the n 'th matched wildcard in the same option. Note that the ? , * , and ** wildcards will never match primitive types. Furthermore, only the *** wildcards will match array types of any dimension. For example, \" ** get*() \" matches \" java.lang.Object getObject() \", but not \" float getFloat() \", nor \" java.lang.Object[] getObjects() \". Constructors can also be specified using their short class names (without package) or using their full class names. As in the Java language, the constructor specification has an argument list, but no return type. The class access modifiers and class member access modifiers are typically used to restrict wildcarded classes and class members. They specify that the corresponding access flags have to be set for the member to match. A preceding ! specifies that the corresponding access flag should be unset. Combining multiple flags is allowed (e.g. public static ). It means that both access flags have to be set (e.g. public and static ), except when they are conflicting, in which case at least one of them has to be set (e.g. at least public or protected ). DexGuard supports the additional modifiers synthetic , bridge , and varargs , which may be set by compilers.","title":"Class Specifications"},{"location":"verification.html","text":"Once you have build your Android application with DexGuard, you should verify that it still works and that it is suitably protected. Functionality \u00b6 First of all, you should make sure the application functions properly, by testing it thoroughly. If the obfuscated application doesn't work, you may need to update your configuration, as discussed in the configuration tips and the troubleshooting section . Static protection: obfuscation and encryption \u00b6 To check whether your application has been obfuscated properly, you can inspect the build logs and apply the same tools that a hacker typically uses: dexdump (Android SDK): disassembles Dalvik bytecode to a readable text format. aapt (Android SDK): disassembles binary resource XML files to a readable text format. baksmali (open source): disassembles Dalvik bytecode to a readable source format. smali (open source): assembles this source format to Dalvik bytecode again. apktool (open source): disassembles and assembles entire applications: bytecode, Android manifest files, resource files, and assets. dex2jar (open source): converts Dalvik byte code to Java bytecode. jad (free): decompiles Java bytecode to Java source code. Check the build log and mapping file \u00b6 You can get some feedback on the results by looking at the build log in verbose mode, with DexGuard option -verbose . DexGuard then prints out some statistics on the number of encrypted strings, classes, asset files, etc. In the obfuscation mapping file (which you can print using the -printmapping option), you can see the obfuscated names of all classes, fields, and methods. Class names and method names that are tied to the Android runtime can't be obfuscated, and names that are preserved with -keep options won't be obfuscated, but the other classes, fields, and methods should get meaningless names. Disassemble your processed bytecode \u00b6 Although all Dalvik bytecode can be disassembled by definition, DexGuard makes it much more difficult to interpret. Even if you don't understand the bytecode, you can quickly check if your processed code contains sensitive strings, class names, field names, or method names, by inspecting the output of dexdump : dexdump -d -f -t dexdump.tmp MyApp-release.apk On Linux or macOS, you can pipe its output through less or grep to quickly find strings. View your processed Android manifest file and resource XML files \u00b6 The Android build process converts resource XML files to more compact binary versions, but you can still view them in a text form with aapt : aapt dump xmltree MyApp-release.apk AndroidManifest.xml Although the output format is readable, you may prefer the original XML format that apktool can deliver, as discussed next. Disassemble your processed application \u00b6 You can inspect the entire processed application, including the Android manifest file and the resource XML files in their original XML format, with apktool : apktool d MyApp-release.apk However, apktool may not always be able to handle the hardened code, crashing while generating its output. This can be considered a useful feature, since the tool is also popular to clone and tamper with apps. Decompile your processed bytecode \u00b6 As a final step, you can check how well the code can be decompiled, with the combination of dex2jar and jad : dex2jar MyApp-release.apk jar -xf MyApp-release-dex2jar.jar jad mypackage/MyClass.class ..... At the very least, non-public identifiers should have obfuscated names that cause all kinds of problems. Non-trivial optimized code is typically hard to decompile and difficult to read. The decompiler also gets thoroughly confused by encryption code. Even more so than with apktool , the quality of the output depends a lot on the decompiler, so you may want to try different decompilers: jad, JD-GUI, Fernflower, Halcyon, etc. Dynamic protection: tamper detection \u00b6 Tamper detection is illustrated in the sample in samples/TamperDetection . It is essentially a call to a method of the DexGuard utility library to check whether the generated apk archive has been modified in any way. Your application can then act accordingly. To verify that the detection really works, you can tamper with the generated apk archive yourself. The slightest modification will set off the detector, so you can use tools like jar , zip , jarsigner , or even zipalign . For instance: zipalign -f 4 MyApp-release.apk MyApp-tampered.apk adb install -r MyApp-tampered.apk If you then run your application again, you should see your application's tamper code being activated.","title":"Verification"},{"location":"verification.html#functionality","text":"First of all, you should make sure the application functions properly, by testing it thoroughly. If the obfuscated application doesn't work, you may need to update your configuration, as discussed in the configuration tips and the troubleshooting section .","title":"Functionality"},{"location":"verification.html#static-protection-obfuscation-and-encryption","text":"To check whether your application has been obfuscated properly, you can inspect the build logs and apply the same tools that a hacker typically uses: dexdump (Android SDK): disassembles Dalvik bytecode to a readable text format. aapt (Android SDK): disassembles binary resource XML files to a readable text format. baksmali (open source): disassembles Dalvik bytecode to a readable source format. smali (open source): assembles this source format to Dalvik bytecode again. apktool (open source): disassembles and assembles entire applications: bytecode, Android manifest files, resource files, and assets. dex2jar (open source): converts Dalvik byte code to Java bytecode. jad (free): decompiles Java bytecode to Java source code.","title":"Static protection: obfuscation and encryption"},{"location":"verification.html#check-the-build-log-and-mapping-file","text":"You can get some feedback on the results by looking at the build log in verbose mode, with DexGuard option -verbose . DexGuard then prints out some statistics on the number of encrypted strings, classes, asset files, etc. In the obfuscation mapping file (which you can print using the -printmapping option), you can see the obfuscated names of all classes, fields, and methods. Class names and method names that are tied to the Android runtime can't be obfuscated, and names that are preserved with -keep options won't be obfuscated, but the other classes, fields, and methods should get meaningless names.","title":"Check the build log and mapping file"},{"location":"verification.html#disassemble-your-processed-bytecode","text":"Although all Dalvik bytecode can be disassembled by definition, DexGuard makes it much more difficult to interpret. Even if you don't understand the bytecode, you can quickly check if your processed code contains sensitive strings, class names, field names, or method names, by inspecting the output of dexdump : dexdump -d -f -t dexdump.tmp MyApp-release.apk On Linux or macOS, you can pipe its output through less or grep to quickly find strings.","title":"Disassemble your processed bytecode"},{"location":"verification.html#view-your-processed-android-manifest-file-and-resource-xml-files","text":"The Android build process converts resource XML files to more compact binary versions, but you can still view them in a text form with aapt : aapt dump xmltree MyApp-release.apk AndroidManifest.xml Although the output format is readable, you may prefer the original XML format that apktool can deliver, as discussed next.","title":"View your processed Android manifest file and resource XML files"},{"location":"verification.html#disassemble-your-processed-application","text":"You can inspect the entire processed application, including the Android manifest file and the resource XML files in their original XML format, with apktool : apktool d MyApp-release.apk However, apktool may not always be able to handle the hardened code, crashing while generating its output. This can be considered a useful feature, since the tool is also popular to clone and tamper with apps.","title":"Disassemble your processed application"},{"location":"verification.html#decompile-your-processed-bytecode","text":"As a final step, you can check how well the code can be decompiled, with the combination of dex2jar and jad : dex2jar MyApp-release.apk jar -xf MyApp-release-dex2jar.jar jad mypackage/MyClass.class ..... At the very least, non-public identifiers should have obfuscated names that cause all kinds of problems. Non-trivial optimized code is typically hard to decompile and difficult to read. The decompiler also gets thoroughly confused by encryption code. Even more so than with apktool , the quality of the output depends a lot on the decompiler, so you may want to try different decompilers: jad, JD-GUI, Fernflower, Halcyon, etc.","title":"Decompile your processed bytecode"},{"location":"verification.html#dynamic-protection-tamper-detection","text":"Tamper detection is illustrated in the sample in samples/TamperDetection . It is essentially a call to a method of the DexGuard utility library to check whether the generated apk archive has been modified in any way. Your application can then act accordingly. To verify that the detection really works, you can tamper with the generated apk archive yourself. The slightest modification will set off the detector, so you can use tools like jar , zip , jarsigner , or even zipalign . For instance: zipalign -f 4 MyApp-release.apk MyApp-tampered.apk adb install -r MyApp-tampered.apk If you then run your application again, you should see your application's tamper code being activated.","title":"Dynamic protection: tamper detection"},{"location":"whitebox.html","text":"DexGuard\u2019s optional addon for whitebox cryptography offers a small API for encrypting and decrypting dynamic application data with a whitebox implementation of the AES algorithm. This can be useful in those cases where an encryption key needs to be hardcoded into the application. DexGuard transforms and weaves the key into the code, in such a way that it can't be extracted. For example, the application can then securely download encrypted data from a remote server, without exposing the key. Dependencies for whitebox cryptography \u00b6 The addon contains a Java API for whitebox encryption and decryption. You can find the library in the DexGuard distribution at lib/whiteboxcrypto-runtime.jar It is self-contained and does not depend on any libraries, other than the standard Java/Android runtime library. Note that the library only works properly when DexGuard has processed the application. While processing, DexGuard weaves the necessary cryptographic routines and the specified encryption keys into the code. The whitebox cryptography API \u00b6 The whitebox cryptography API contains a single class, WhiteBoxCipher . It provides two straightforward methods for encrypting and decrypting input streams: public class WhiteBoxCipher { public static OutputStream encrypt ( OutputStream outputStream , String keyId ); public static InputStream decrypt ( InputStream inputStream , String keyId ); } For encrypting data , use WhiteBoxCipher.encrypt . It wraps a given OutputStream in an encrypting OutputStream . The wrapper stream encrypts all data that you write to it, and writes the resulting encrypted bytes to the wrapped stream: OutputStream outputStream = ...; OutputStream encryptingOutputStream = WhiteBoxCipher . encrypt ( outputStream , \"key1\" ); // You can now write unencrypted data to encryptingOutputStream. byte [] unencryptedData = ...; encryptingOutputStream . write ( unencryptedData ); // outputStream now contains the encrypted data. For decrypting data , use WhiteBoxCipher.decrypt . It wraps a given encrypted InputStream in a decrypting InputStream . The wrapper decrypts all bytes that it reads from the wrapped stream, and returns the resulting decrypted data to the consumer of the stream. InputStream encryptedInputStream = ...; InputStream decryptingInputStream = WhiteBoxCipher . decrypt ( encryptedInputStream , \"key1\" ); // You can now read decrypted data from decryptingInputStream. byte [] decryptedData = new byte [ ... ] ; decryptingInputStream . read ( decryptedData ); The encrypt and decrypt methods both take a keyId parameter. This is an identifier for a particular encryption key. You can freely pick any identifier, or multiple identifiers if you have multiple keys. You should then use the same identifier to specify the cryptographic key and other parameters in your DexGuard configuration. The next section discusses the corresponding options. Specifying encryption keys \u00b6 You need to specify your whitebox encryption keys in your DexGuard configuration. This approach ensures that the (sensitive) encryption keys remain strictly separated from the code. You can specify an encryption key with the following option: -whiteboxencryptionkeys key_id algorithm_parameters where the parameters are: key_id a unique, alphanumeric identifier for the specified key. algorithm_id the unique identifier of the encryption algorithm. algorithm_parameters algorithm-specific parameters, separated by spaces (see below for details). If you don\u2019t want to check in the encryption keys in your version control system, you can keep them separate from the rest of the DexGuard configuration by storing them in a separate configuration file. You can include this file from the main configuration file with the directive -include filename Finally, you can also define the keys in environment properties and use those in your DexGuard configuration. For example: -whiteboxencryptionkeys MyKey < my.key.parameters > Encryption parameters \u00b6 The whitebox library currently supports 128-bits AES encryption in ECB mode or in CBC mode. AES algorithm parameters \u00b6 The AES implementation expects an encryption key and an optional initialization vector: -whiteboxencryptionkeys key_id AES encryption_key [ initialization_vector ] If you specify just the encryption key, the mode of operation is ECB (Electronic Code Book). If you provide the encryption key and the initialization vector, the mode is CBC (Cipher Block Chaining). AES The identifier of the encryption algorithm. encryption_key The hexadecimal representation of the key. The implementation uses 16-byte keys. If the provided parameter is too short, it is padded with leading zeros; if it is too long, only the 16 least significant bytes are used. initialization_vector The hexadecimal representation of the optional AES initialization vector. The initialization vector is 16 bytes long. If the provided parameter is too short, it is padded with leading zeros. If it is too long, only the 16 least significant bytes are used. The following example specifies an AES encryption key with key identifier \"key1\", encryption key 1234567890abcdef1234567890abcdef and no initialization vector: -whiteboxencryptionkeys key1 1234567890abcdef1234567890abcdef Disabling obfuscation \u00b6 When obfuscation is disabled (in debug builds or explicitly with the option -dontobfuscate ), whitebox cryptography is disabled as well. Calls to WhiteBoxCipher 's encryption and decryption methods still work in the processed application, but they use a traditional, non-whitebox implementation. DexGuard then injects the encryption keys as plain strings in the application. You should therefore be careful not to distribute debug builds or other builds that are not obfuscated. Whitebox cryptography for static data \u00b6 DexGuard also provides encryption plugins that implement whitebox AES encryption for the protection of static content , such as classes, native libraries, Android assets, and resources. The plugins transparently encrypt the contents with generated AES keys while processing the application. The encryption keys are different for each version of the application. The plugins weave the decryption algorithms and the keys into the application, so it can decrypt the content at runtime. The plugins are located in the lib folder: For standalone processing / ant / maven integration: lib/whiteboxcrypto-asset-plugin.jar lib/whiteboxcrypto-class-plugin.jar lib/whiteboxcrypto-nativelibrary-plugin.jar lib/whiteboxcrypto-resource-plugin.jar For gradle integration: lib/whiteboxcrypto-asset-plugin-gradle.jar lib/whiteboxcrypto-class-plugin-gradle.jar lib/whiteboxcrypto-nativelibrary-plugin-gradle.jar lib/whiteboxcrypto-resource-plugin-gradle.jar You can enable any of them with the -pluginjars option. For example: -pluginjars lib/whiteboxcrypto-asset-plugin.jar Performance \u00b6 Whitebox encryption is computationally more expensive and has a larger code footprint than the default encryption plugins that come with DexGuard. It is therefore recommended to only use the static whitebox encryption plugins for a small number of resources, and for resources which are not time-critical. For example, applying the asset whitebox plugin to a large number of assets would probably expand the application code footprint too much. On the other hand, the overhead of protecting a single sensitive class or native library with a whitebox encryption plugin is generally acceptable in most cases.","title":"Whitebox Cryptography"},{"location":"whitebox.html#dependencies-for-whitebox-cryptography","text":"The addon contains a Java API for whitebox encryption and decryption. You can find the library in the DexGuard distribution at lib/whiteboxcrypto-runtime.jar It is self-contained and does not depend on any libraries, other than the standard Java/Android runtime library. Note that the library only works properly when DexGuard has processed the application. While processing, DexGuard weaves the necessary cryptographic routines and the specified encryption keys into the code.","title":"Dependencies for whitebox cryptography"},{"location":"whitebox.html#the-whitebox-cryptography-api","text":"The whitebox cryptography API contains a single class, WhiteBoxCipher . It provides two straightforward methods for encrypting and decrypting input streams: public class WhiteBoxCipher { public static OutputStream encrypt ( OutputStream outputStream , String keyId ); public static InputStream decrypt ( InputStream inputStream , String keyId ); } For encrypting data , use WhiteBoxCipher.encrypt . It wraps a given OutputStream in an encrypting OutputStream . The wrapper stream encrypts all data that you write to it, and writes the resulting encrypted bytes to the wrapped stream: OutputStream outputStream = ...; OutputStream encryptingOutputStream = WhiteBoxCipher . encrypt ( outputStream , \"key1\" ); // You can now write unencrypted data to encryptingOutputStream. byte [] unencryptedData = ...; encryptingOutputStream . write ( unencryptedData ); // outputStream now contains the encrypted data. For decrypting data , use WhiteBoxCipher.decrypt . It wraps a given encrypted InputStream in a decrypting InputStream . The wrapper decrypts all bytes that it reads from the wrapped stream, and returns the resulting decrypted data to the consumer of the stream. InputStream encryptedInputStream = ...; InputStream decryptingInputStream = WhiteBoxCipher . decrypt ( encryptedInputStream , \"key1\" ); // You can now read decrypted data from decryptingInputStream. byte [] decryptedData = new byte [ ... ] ; decryptingInputStream . read ( decryptedData ); The encrypt and decrypt methods both take a keyId parameter. This is an identifier for a particular encryption key. You can freely pick any identifier, or multiple identifiers if you have multiple keys. You should then use the same identifier to specify the cryptographic key and other parameters in your DexGuard configuration. The next section discusses the corresponding options.","title":"The whitebox cryptography API"},{"location":"whitebox.html#specifying-encryption-keys","text":"You need to specify your whitebox encryption keys in your DexGuard configuration. This approach ensures that the (sensitive) encryption keys remain strictly separated from the code. You can specify an encryption key with the following option: -whiteboxencryptionkeys key_id algorithm_parameters where the parameters are: key_id a unique, alphanumeric identifier for the specified key. algorithm_id the unique identifier of the encryption algorithm. algorithm_parameters algorithm-specific parameters, separated by spaces (see below for details). If you don\u2019t want to check in the encryption keys in your version control system, you can keep them separate from the rest of the DexGuard configuration by storing them in a separate configuration file. You can include this file from the main configuration file with the directive -include filename Finally, you can also define the keys in environment properties and use those in your DexGuard configuration. For example: -whiteboxencryptionkeys MyKey < my.key.parameters >","title":"Specifying encryption keys"},{"location":"whitebox.html#encryption-parameters","text":"The whitebox library currently supports 128-bits AES encryption in ECB mode or in CBC mode.","title":"Encryption parameters"},{"location":"whitebox.html#aes-algorithm-parameters","text":"The AES implementation expects an encryption key and an optional initialization vector: -whiteboxencryptionkeys key_id AES encryption_key [ initialization_vector ] If you specify just the encryption key, the mode of operation is ECB (Electronic Code Book). If you provide the encryption key and the initialization vector, the mode is CBC (Cipher Block Chaining). AES The identifier of the encryption algorithm. encryption_key The hexadecimal representation of the key. The implementation uses 16-byte keys. If the provided parameter is too short, it is padded with leading zeros; if it is too long, only the 16 least significant bytes are used. initialization_vector The hexadecimal representation of the optional AES initialization vector. The initialization vector is 16 bytes long. If the provided parameter is too short, it is padded with leading zeros. If it is too long, only the 16 least significant bytes are used. The following example specifies an AES encryption key with key identifier \"key1\", encryption key 1234567890abcdef1234567890abcdef and no initialization vector: -whiteboxencryptionkeys key1 1234567890abcdef1234567890abcdef","title":"AES algorithm parameters"},{"location":"whitebox.html#disabling-obfuscation","text":"When obfuscation is disabled (in debug builds or explicitly with the option -dontobfuscate ), whitebox cryptography is disabled as well. Calls to WhiteBoxCipher 's encryption and decryption methods still work in the processed application, but they use a traditional, non-whitebox implementation. DexGuard then injects the encryption keys as plain strings in the application. You should therefore be careful not to distribute debug builds or other builds that are not obfuscated.","title":"Disabling obfuscation"},{"location":"whitebox.html#whitebox-cryptography-for-static-data","text":"DexGuard also provides encryption plugins that implement whitebox AES encryption for the protection of static content , such as classes, native libraries, Android assets, and resources. The plugins transparently encrypt the contents with generated AES keys while processing the application. The encryption keys are different for each version of the application. The plugins weave the decryption algorithms and the keys into the application, so it can decrypt the content at runtime. The plugins are located in the lib folder: For standalone processing / ant / maven integration: lib/whiteboxcrypto-asset-plugin.jar lib/whiteboxcrypto-class-plugin.jar lib/whiteboxcrypto-nativelibrary-plugin.jar lib/whiteboxcrypto-resource-plugin.jar For gradle integration: lib/whiteboxcrypto-asset-plugin-gradle.jar lib/whiteboxcrypto-class-plugin-gradle.jar lib/whiteboxcrypto-nativelibrary-plugin-gradle.jar lib/whiteboxcrypto-resource-plugin-gradle.jar You can enable any of them with the -pluginjars option. For example: -pluginjars lib/whiteboxcrypto-asset-plugin.jar","title":"Whitebox cryptography for static data"},{"location":"whitebox.html#performance","text":"Whitebox encryption is computationally more expensive and has a larger code footprint than the default encryption plugins that come with DexGuard. It is therefore recommended to only use the static whitebox encryption plugins for a small number of resources, and for resources which are not time-critical. For example, applying the asset whitebox plugin to a large number of assets would probably expand the application code footprint too much. On the other hand, the overhead of protecting a single sensitive class or native library with a whitebox encryption plugin is generally acceptable in most cases.","title":"Performance"},{"location":"setup/cordovaplugin.html","text":"DexGuard can be integrated in the Cordova build process. This will ensure that DexGuard is automatically applied every time you Cordova commands such as cordova run android without having to make manual changes to the Android project directory. Quick start \u00b6 You can add the DexGuard Cordova plugin to your Cordova project like any other Cordova plugin: cordova plugin add path/to/plugin-dir Then, copy the files in the plugins 'templates' folder to the root of your project. You can customize these templates to your project: dexguard-plugin.json \u00b6 This is the configuration file of the plugin. All the configuration options are explained in detail in the Configuration section . build-extras.gradle \u00b6 This gradle file will be copied into the Android project and allows you to add gradle configuration to your application. This is required to enable DexGuard: Groovy apply plugin: 'dexguard' // Only necessary for EncryptedSystemWebViewClient dependencies { implementation ( name: 'dexguard-runtime' , ext: 'aar' ) } dexguard { path = 'DEXGUARD_PATH_PLACEHOLDER' configurations { release { defaultConfiguration 'dexguard-release-aggressive.pro' configuration 'dexguard-project.txt' } debug { defaultConfiguration 'dexguard-debug.pro' } } } Kotlin plugins { id ( \"dexguard\" ) } // Only necessary for EncryptedSystemWebViewClient dependencies { implementation ( mapOf ( \"name\" to \"dexguard-runtime\" , \"ext\" to \"aar\" )) } dexguard { path = \"DEXGUARD_PATH_PLACEHOLDER\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release-aggressive.pro\" ) configuration ( \"dexguard-project.txt\" ) } register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) } } } DEXGUARD_PATH_PLACEHOLDER will automatically be replaced by the Cordova plugin to the DexGuard location, according to the configuration set in dexguard-plugin.json Note that you can use this mechanism to add non-DexGuard related gradle configuration as well. dexguard-project.txt & javascript.yml \u00b6 These are the DexGuard and JavaScript obfuscation configuration files respectively. See their respective manuals for more information on how to configure these correctly. EncryptedCordovaActivity.java \u00b6 This is an example of a custom Activity that will be injected into the application and can therefore be used to extend the functionality of the MainActivity. This particular EncryptedCordovaActivity can be used to support asset encryption in a Cordova application. See the option customActivityFile for a more detailed explanation. Configuration \u00b6 To configure this plugin, create a file called \"dexguard-plugin.json\" (or use the template included in the templates folder) in the root of your Cordova project. A typical dexguard-plugin.json configuration looks as follows: { \"appLevelFiles\" : [ \"build-extras.gradle\" , \"dexguard-project.txt\" , \"javascript.yml\" ], \"dexguardPath\" : \"/path/to/dexguard\" , \"appDirectory\" : \"app\" , \"srcDirectory\" : \"src/main/java\" , \"customActivityFile\" : \"EncryptedCordovaActivity.java\" , \"mainActivity\" : \"io.cordova.hellocordova.MainActivity\" } appLevelFiles \u00b6 Provide a list of all the files that need to be copied to the app directory of your android application. Typically, this includes: the DexGuard configuration (dexguard-project.txt) the JavaScript obfuscation configuration (javascript.yml) build-extras.gradle appDirectory (required) \u00b6 Specify the path to your app-directory (relative to the platforms/android directory). This is where the files specified in 'appLevelFiles' will be copied to. srcDirectory (required) \u00b6 Specify the location of the java source directory of this application (relative to the app-directory ). Normally this is 'src/main/java'. dexguardPath (required) \u00b6 Specify the path to the directory containing dexguard.jar. This path can be absolute or relative to the platforms/android directory. customActivityFile (optional) \u00b6 Specify a Java class file of an Activity that extends CordovaActivity. The plugin will do two things: Copy this Activity to the java source directory of your application Modify the MainActivity to extend this custom Activity class instead of CordovaActivity This option allows you to add extra functionality to the application's MainActivity (eg: adding the DexGuard runtime checks). mainActivity (required when using 'customActivityFile') \u00b6 Specify the fully qualified name of this application's MainActivity. This option is required when using 'customActivityFile' . Output APK \u00b6 The protected APK is created and placed alongside the unprotected APK in the platforms/android/app/build/outputs/apk/<variant> directory, and has a -protected suffix in the name. Make sure to release the protected application The release application will require signing. Please refer to the Cordova user's guide for further information about signing an application. If you specify signature information, the protected APK will be signed using the provided information.","title":"Cordova Plugin"},{"location":"setup/cordovaplugin.html#quick-start","text":"You can add the DexGuard Cordova plugin to your Cordova project like any other Cordova plugin: cordova plugin add path/to/plugin-dir Then, copy the files in the plugins 'templates' folder to the root of your project. You can customize these templates to your project:","title":"Quick start"},{"location":"setup/cordovaplugin.html#dexguard-pluginjson","text":"This is the configuration file of the plugin. All the configuration options are explained in detail in the Configuration section .","title":"dexguard-plugin.json"},{"location":"setup/cordovaplugin.html#build-extrasgradle","text":"This gradle file will be copied into the Android project and allows you to add gradle configuration to your application. This is required to enable DexGuard: Groovy apply plugin: 'dexguard' // Only necessary for EncryptedSystemWebViewClient dependencies { implementation ( name: 'dexguard-runtime' , ext: 'aar' ) } dexguard { path = 'DEXGUARD_PATH_PLACEHOLDER' configurations { release { defaultConfiguration 'dexguard-release-aggressive.pro' configuration 'dexguard-project.txt' } debug { defaultConfiguration 'dexguard-debug.pro' } } } Kotlin plugins { id ( \"dexguard\" ) } // Only necessary for EncryptedSystemWebViewClient dependencies { implementation ( mapOf ( \"name\" to \"dexguard-runtime\" , \"ext\" to \"aar\" )) } dexguard { path = \"DEXGUARD_PATH_PLACEHOLDER\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release-aggressive.pro\" ) configuration ( \"dexguard-project.txt\" ) } register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) } } } DEXGUARD_PATH_PLACEHOLDER will automatically be replaced by the Cordova plugin to the DexGuard location, according to the configuration set in dexguard-plugin.json Note that you can use this mechanism to add non-DexGuard related gradle configuration as well.","title":"build-extras.gradle"},{"location":"setup/cordovaplugin.html#dexguard-projecttxt-javascriptyml","text":"These are the DexGuard and JavaScript obfuscation configuration files respectively. See their respective manuals for more information on how to configure these correctly.","title":"dexguard-project.txt &amp; javascript.yml"},{"location":"setup/cordovaplugin.html#encryptedcordovaactivityjava","text":"This is an example of a custom Activity that will be injected into the application and can therefore be used to extend the functionality of the MainActivity. This particular EncryptedCordovaActivity can be used to support asset encryption in a Cordova application. See the option customActivityFile for a more detailed explanation.","title":"EncryptedCordovaActivity.java"},{"location":"setup/cordovaplugin.html#configuration","text":"To configure this plugin, create a file called \"dexguard-plugin.json\" (or use the template included in the templates folder) in the root of your Cordova project. A typical dexguard-plugin.json configuration looks as follows: { \"appLevelFiles\" : [ \"build-extras.gradle\" , \"dexguard-project.txt\" , \"javascript.yml\" ], \"dexguardPath\" : \"/path/to/dexguard\" , \"appDirectory\" : \"app\" , \"srcDirectory\" : \"src/main/java\" , \"customActivityFile\" : \"EncryptedCordovaActivity.java\" , \"mainActivity\" : \"io.cordova.hellocordova.MainActivity\" }","title":"Configuration"},{"location":"setup/cordovaplugin.html#applevelfiles","text":"Provide a list of all the files that need to be copied to the app directory of your android application. Typically, this includes: the DexGuard configuration (dexguard-project.txt) the JavaScript obfuscation configuration (javascript.yml) build-extras.gradle","title":"appLevelFiles"},{"location":"setup/cordovaplugin.html#appdirectory-required","text":"Specify the path to your app-directory (relative to the platforms/android directory). This is where the files specified in 'appLevelFiles' will be copied to.","title":"appDirectory (required)"},{"location":"setup/cordovaplugin.html#srcdirectory-required","text":"Specify the location of the java source directory of this application (relative to the app-directory ). Normally this is 'src/main/java'.","title":"srcDirectory (required)"},{"location":"setup/cordovaplugin.html#dexguardpath-required","text":"Specify the path to the directory containing dexguard.jar. This path can be absolute or relative to the platforms/android directory.","title":"dexguardPath (required)"},{"location":"setup/cordovaplugin.html#customactivityfile-optional","text":"Specify a Java class file of an Activity that extends CordovaActivity. The plugin will do two things: Copy this Activity to the java source directory of your application Modify the MainActivity to extend this custom Activity class instead of CordovaActivity This option allows you to add extra functionality to the application's MainActivity (eg: adding the DexGuard runtime checks).","title":"customActivityFile (optional)"},{"location":"setup/cordovaplugin.html#mainactivity-required-when-using-customactivityfile","text":"Specify the fully qualified name of this application's MainActivity. This option is required when using 'customActivityFile' .","title":"mainActivity (required when using 'customActivityFile')"},{"location":"setup/cordovaplugin.html#output-apk","text":"The protected APK is created and placed alongside the unprotected APK in the platforms/android/app/build/outputs/apk/<variant> directory, and has a -protected suffix in the name. Make sure to release the protected application The release application will require signing. Please refer to the Cordova user's guide for further information about signing an application. If you specify signature information, the protected APK will be signed using the provided information.","title":"Output APK"},{"location":"setup/espresso.html","text":"Automated testing is a very useful tool to verify your application works as expected. As the hardening that DexGuard applies can change the structure of your code you may want to use these automated tests to verify everything still works as it should. Espresso is a testing framework that can do just that, it is provided by Google and can easily be configured in your Gradle project. A test build for an unprocessed application doesn't always work with its processed version. For this reason the test has to be processed by DexGuard using a specific configuration. When using the DexGuard Gradle plugin no additional action is required, the test will automatically be processed using the aforementioned configuration. However, you will have to prevent D8/R8 from stripping Espresso annotations , install and run the tests manually. When executing DexGuard outside of the build process you will have to perform the following actions: Build your application. Build the test application. Process your application using DexGuard and print out the mapping file. Process the test application using DexGuard and the Espresso conifguration. Install both applications to a test device or emulator. Execute the Espresso tests. Build your application \u00b6 You can build your application using the assemble Gradle task. This task will build all variants of your application, if you only want to build a single variant, append the name of the variant to the end. For example, assembleRelease to build only the release variant. Linux/macOS ./gradlew assembleRelease Windows gradlew assembleRelease Warning If you use Espresso annotations, you will have to make sure they are not stripped by D8/R8 while building your application. DexGuard cannot see the annotations otherwise, which may result in exceptions at runtime. Please visit this page for more information. Build the test application \u00b6 The test application is a special test variant derived from the one you want to test. As such, you can build it like any other variant of your application. The name of this test variant is the name of the base variant appended with androidTest . For example, releaseAndroidTest for the release variant. This test variant will build an application containing your Espresso tests, it will be installed alongside your actual application. Upon opening this test application it will open up the application it's supposed to test and performs the actions described in the tests, reporting the results. Building this test variant is done by calling its assemble task. If you are testing your debug build this would look something like this: Linux/macOS ./gradlew assembleDebugAndroidTest Windows gradlew assembleDebugAndroidTest The resulting apk can be found in the build/outputs/androidTest directory. Process your application with DexGuard and print out the mapping file \u00b6 In this step you process your application as you normally would as described earlier on this page. When you want to test the resulting apk using Espresso you need to keep two things in mind, however. You need to print out the mapping file. This file will be used when processing the test application to rename the calls in this application to the obfuscated name. You need to sign it so it can be installed on the test device or emulator. Signing it with the default debug keystore works perfectly fine. -printmapping mapping.txt -keystore <user.home>/.android/debug.keystore -keystorepassword android -keyalias androiddebugkey -keypassword android Process the test application using DexGuard and the Espresso configuration \u00b6 Processing the test application is straight-forward and will require no custom configuration in almost all cases. The configuration is similar to that of a normal application except for the default configuration and some additional requirements. The default configuration used is dexguard-espresso-internal.pro . This will configure DexGuard to perform some adaptations to match the application under test. Apart from that, minimal processing is performed to prevent any major structural changes to your test code. The additional requirements are the following: The unobfuscated main application has to be passed in as a library jar to DexGuard since the test application depends on it. An -applymapping rule has to be added using the mapping file of the main application so calls into the main application code can be renamed consistently. The apk needs to be signed so it can be installed. The Android build chain will use the default debug keystore, so we suggest doing the same. Example: -injars path/to/my-application-androidTest.apk -outjars path/to/obfuscated-application-androidTest.apk -libraryjars path/to/my-application.apk -libraryjars /path/to/android/sdk/platforms/android-XX/android.jar -include /lib/dexguard-espresso-internal.pro -applymapping path/to/mapping.txt -keystore <user.home>/.android/debug.keystore -keystorepassword android -keyalias androiddebugkey -keypassword android Install both applications to a test device or emulator \u00b6 Installing a local apk to a connected device or emulator can easily be done using adb , which comes with the Android SDK: Linux/macOS path/to/android/sdk/platform-tools/adb install path/to/obfuscated-application.apk path/to/android/sdk/platform-tools/adb install path/to/obfuscated-application-androidTest.apk Windows path \\to\\android\\sdk\\platform-tools\\adb install path\\to\\obfuscated-application.apk path \\to\\android\\sdk\\platform-tools\\adb install path\\to\\obfuscated-application-androidTest.apk Execute the Espresso tests \u00b6 Executing the Espresso tests call also be done via adb : Linux/macOS path/to/android/sdk/platform-tools/adb shell am instrument -w my.package.name.test/android.support.test.runner.AndroidJUnitRunner Windows path \\to\\android\\sdk\\platform-tools\\adb shell am instrument -w my.package.name.test/android.support.test.runner.AndroidJUnitRunner The -w argument makes it so the process waits to return until it's finished, this is required for test runners. The following argument is the test runner, starting with the package name (or application ID ) of the test application . This is by default the package name of the main application appended with .test . After that is a / followed by fully qualified class name of the test runner to use to run the tests. This is by default the android.support.test.runner.AndroidJUnitRunner , but if you can also use a custom one. For more information on this process, refer to the official documentation . Uninstall the applications \u00b6 This step is optional, but if you want to uninstall the applications when you are done with the tests, you can again use adb for this purpose: Linux/macOS path/to/android/sdk/platform-tools/adb uninstall my.package.name path/to/android/sdk/platform-tools/adb uninstall my.package.name.test Windows path \\to\\android\\sdk\\platform-tools\\adb uninstall my.package.name path \\to\\android\\sdk\\platform-tools\\adb uninstall my.package.name.test As you can see, the uninstall command takes in the package name of the application you want to uninstall. Best practices \u00b6 Even though DexGuard does not alter the functionality and intended behavior of your application, it does change the internal structure quite a bit due to the optimizations and layers of protection it applies. This means some care should be taken when creating your Espresso tests. This section will go over our recommendations to lower the amount of additional configuration needed and keep the obfuscation of the application you are testing as close to the final product as possible. The general idea is to start from working tests without applying DexGuard to your application. After that, try to run the tests with DexGuard applied but without any additional configuration. If they do not succeed, it means DexGuard broke them and you'll either have to rework your test code to be less dependent on the application code or extend the configuration for the application under test. Test configuration Many of the suggestions below will mention adding additional configuration for the application that's being tested. These additional rules and default configurations should only be applied when testing your app using Espresso, they should not be applied when creating the application you're going to ship since they weaken the obfuscation to allow the tests to do their work. Test code \u00b6 Espresso is a framework that allows you to emulate user input and verify the current state of the user interface. This means it's actually very forgiving with regards to the various optimization and obfuscation techniques DexGuard applies. There are some problematic cases, of course. Using classes from the application in your tests should be avoided as much as possible. As stated earlier, DexGuard will apply optimizations and obfuscations that can drastically change the way your code looks internally. Our default configuration for the Espresso tests makes the obfuscation less of an issue but it's not perfect and the optimizations will almost certainly cause problems. We are aware that this is not always possible and there are ways around this. This is generally not ideal, as you want to avoid additional configuration. For this reason we do stress that you try to avoid this as much as you can. Possible solutions include: Copy the class or method you want to use. This is really only advised if they are small and not likely to change. Create dedicated methods used in tests only. These methods are guaranteed to be removed by DexGuard in your actual release and can be kept using the rule below. -keepclassmembers class classname { returntype methodname ( parametertypes ); } Add additional rules to keep any relevant code or disable any problematic optimizations. You can read more about the various optimizations that can be disabled on the optimizations page. Use a default test configuration . Depending on the configuration you choose, several classes will be kept and/or optimizations will be disabled. If the problem persists you'll likely have to add a custom keep rule. Resources \u00b6 DexGuard also processes the various resources that are used in your application, which means this can cause problems if you try to refer to them from your test code. Just as with code, try to avoid referring to application resources in your test code . If this is not possible, try running your tests to see if there are any issues. If there are, you can try any of the following suggestions: Use the dexguard-espresso-no-resource-optimizations.pro default test configuration. Keep the problematic resources using the -keepresources rule. Dependencies \u00b6 When building the tests the Android gradle plugin will treat the dependencies shared by the application and its tests as compile only dependencies, meaning they won't end up packaged in the test application. This saves space and in normal circumstances isn't an issue as the dependencies will be available in the application under test. However, when using DexGuard this no longer holds true because of its shrinking. If the application does not use a class that the tests do use, it will be removed during the shrinking step from the main application. Here are some suggestions to resolve these issues if they occur: Try to avoid sharing dependencies between your application and its tests. In general this shouldn't be too much of an issue, but there are some common cases where this is not possible. Add keep rules for the missing classes. Default configurations \u00b6 DexGuard provides a few default configurations you can include for applicaton builds you're going to test using Espresso. These configurations have a specific purpose and are independent of each other, meaning you can use multiple at the same time. The available default configurations are explained in more detail below. dexguard-espresso.pro \u00b6 This is the basic configuration needed to run Espresso tests on an application that is obfuscated by DexGuard. It also offers support for the @VisibleForTesting annotation which will prevent annotated classes or members from being obfuscated, shrunk or optimized in order to be accessed by tests. -include /lib/dexguard-espresso.pro dexguard-espresso-no-resource-optimizations.pro \u00b6 Using this default configuration makes using resources in your test code a non-issue. It disables all resource related optimizations so everything your tests expect to find should still be there with their original ids. -include /lib/dexguard-espresso-no-resource-optimizations.pro dexguard-espresso-aggressive-optimizations.pro \u00b6 This default configuration disables all less invasive code optimizations. These should be sufficient when your tests only access a small portion of the application code. The optimizations that are disabled are: field/marking/private method/marking/private method/marking/static method/marking/final method/inlining/short method/inlining/unique -include /lib/dexguard-espresso-aggressive-optimizations.pro dexguard-espresso-safe-optimizations.pro \u00b6 This is an extension of the dexguard-espresso-aggressive-optimizations.pro configuration and disables more optimizations. The optimizations in question are responsible for most drastic changes in code structure and using this configuration should allow you to access all of your application code from your tests. The optimizations that are disabled in addition to the ones mentioned above are: class/merging/vertical class/merging/horizontal class/merging/wrapper field/generalization/class method/generalization/class field/sepcialization/type method/sepcialization/parametertype method/sepcialization/returntype field/propagation/value method/propagation/parameter method/propagation/returnvalue -include /lib/dexguard-espresso-safe-optimizations.pro Note The configuration dexguard-espresso-safe-optimizations.pro is a superset of dexguard-espresso-aggressive-optimizations.pro . This means you should not include both at the same time. They can be combined with the other default configurations, just not with each other.","title":"Espresso"},{"location":"setup/espresso.html#build-your-application","text":"You can build your application using the assemble Gradle task. This task will build all variants of your application, if you only want to build a single variant, append the name of the variant to the end. For example, assembleRelease to build only the release variant. Linux/macOS ./gradlew assembleRelease Windows gradlew assembleRelease Warning If you use Espresso annotations, you will have to make sure they are not stripped by D8/R8 while building your application. DexGuard cannot see the annotations otherwise, which may result in exceptions at runtime. Please visit this page for more information.","title":"Build your application"},{"location":"setup/espresso.html#build-the-test-application","text":"The test application is a special test variant derived from the one you want to test. As such, you can build it like any other variant of your application. The name of this test variant is the name of the base variant appended with androidTest . For example, releaseAndroidTest for the release variant. This test variant will build an application containing your Espresso tests, it will be installed alongside your actual application. Upon opening this test application it will open up the application it's supposed to test and performs the actions described in the tests, reporting the results. Building this test variant is done by calling its assemble task. If you are testing your debug build this would look something like this: Linux/macOS ./gradlew assembleDebugAndroidTest Windows gradlew assembleDebugAndroidTest The resulting apk can be found in the build/outputs/androidTest directory.","title":"Build the test application"},{"location":"setup/espresso.html#process-your-application-with-dexguard-and-print-out-the-mapping-file","text":"In this step you process your application as you normally would as described earlier on this page. When you want to test the resulting apk using Espresso you need to keep two things in mind, however. You need to print out the mapping file. This file will be used when processing the test application to rename the calls in this application to the obfuscated name. You need to sign it so it can be installed on the test device or emulator. Signing it with the default debug keystore works perfectly fine. -printmapping mapping.txt -keystore <user.home>/.android/debug.keystore -keystorepassword android -keyalias androiddebugkey -keypassword android","title":"Process your application with DexGuard and print out the mapping file"},{"location":"setup/espresso.html#process-the-test-application-using-dexguard-and-the-espresso-configuration","text":"Processing the test application is straight-forward and will require no custom configuration in almost all cases. The configuration is similar to that of a normal application except for the default configuration and some additional requirements. The default configuration used is dexguard-espresso-internal.pro . This will configure DexGuard to perform some adaptations to match the application under test. Apart from that, minimal processing is performed to prevent any major structural changes to your test code. The additional requirements are the following: The unobfuscated main application has to be passed in as a library jar to DexGuard since the test application depends on it. An -applymapping rule has to be added using the mapping file of the main application so calls into the main application code can be renamed consistently. The apk needs to be signed so it can be installed. The Android build chain will use the default debug keystore, so we suggest doing the same. Example: -injars path/to/my-application-androidTest.apk -outjars path/to/obfuscated-application-androidTest.apk -libraryjars path/to/my-application.apk -libraryjars /path/to/android/sdk/platforms/android-XX/android.jar -include /lib/dexguard-espresso-internal.pro -applymapping path/to/mapping.txt -keystore <user.home>/.android/debug.keystore -keystorepassword android -keyalias androiddebugkey -keypassword android","title":"Process the test application using DexGuard and the Espresso configuration"},{"location":"setup/espresso.html#install-both-applications-to-a-test-device-or-emulator","text":"Installing a local apk to a connected device or emulator can easily be done using adb , which comes with the Android SDK: Linux/macOS path/to/android/sdk/platform-tools/adb install path/to/obfuscated-application.apk path/to/android/sdk/platform-tools/adb install path/to/obfuscated-application-androidTest.apk Windows path \\to\\android\\sdk\\platform-tools\\adb install path\\to\\obfuscated-application.apk path \\to\\android\\sdk\\platform-tools\\adb install path\\to\\obfuscated-application-androidTest.apk","title":"Install both applications to a test device or emulator"},{"location":"setup/espresso.html#execute-the-espresso-tests","text":"Executing the Espresso tests call also be done via adb : Linux/macOS path/to/android/sdk/platform-tools/adb shell am instrument -w my.package.name.test/android.support.test.runner.AndroidJUnitRunner Windows path \\to\\android\\sdk\\platform-tools\\adb shell am instrument -w my.package.name.test/android.support.test.runner.AndroidJUnitRunner The -w argument makes it so the process waits to return until it's finished, this is required for test runners. The following argument is the test runner, starting with the package name (or application ID ) of the test application . This is by default the package name of the main application appended with .test . After that is a / followed by fully qualified class name of the test runner to use to run the tests. This is by default the android.support.test.runner.AndroidJUnitRunner , but if you can also use a custom one. For more information on this process, refer to the official documentation .","title":"Execute the Espresso tests"},{"location":"setup/espresso.html#uninstall-the-applications","text":"This step is optional, but if you want to uninstall the applications when you are done with the tests, you can again use adb for this purpose: Linux/macOS path/to/android/sdk/platform-tools/adb uninstall my.package.name path/to/android/sdk/platform-tools/adb uninstall my.package.name.test Windows path \\to\\android\\sdk\\platform-tools\\adb uninstall my.package.name path \\to\\android\\sdk\\platform-tools\\adb uninstall my.package.name.test As you can see, the uninstall command takes in the package name of the application you want to uninstall.","title":"Uninstall the applications"},{"location":"setup/espresso.html#best-practices","text":"Even though DexGuard does not alter the functionality and intended behavior of your application, it does change the internal structure quite a bit due to the optimizations and layers of protection it applies. This means some care should be taken when creating your Espresso tests. This section will go over our recommendations to lower the amount of additional configuration needed and keep the obfuscation of the application you are testing as close to the final product as possible. The general idea is to start from working tests without applying DexGuard to your application. After that, try to run the tests with DexGuard applied but without any additional configuration. If they do not succeed, it means DexGuard broke them and you'll either have to rework your test code to be less dependent on the application code or extend the configuration for the application under test. Test configuration Many of the suggestions below will mention adding additional configuration for the application that's being tested. These additional rules and default configurations should only be applied when testing your app using Espresso, they should not be applied when creating the application you're going to ship since they weaken the obfuscation to allow the tests to do their work.","title":"Best practices"},{"location":"setup/espresso.html#test-code","text":"Espresso is a framework that allows you to emulate user input and verify the current state of the user interface. This means it's actually very forgiving with regards to the various optimization and obfuscation techniques DexGuard applies. There are some problematic cases, of course. Using classes from the application in your tests should be avoided as much as possible. As stated earlier, DexGuard will apply optimizations and obfuscations that can drastically change the way your code looks internally. Our default configuration for the Espresso tests makes the obfuscation less of an issue but it's not perfect and the optimizations will almost certainly cause problems. We are aware that this is not always possible and there are ways around this. This is generally not ideal, as you want to avoid additional configuration. For this reason we do stress that you try to avoid this as much as you can. Possible solutions include: Copy the class or method you want to use. This is really only advised if they are small and not likely to change. Create dedicated methods used in tests only. These methods are guaranteed to be removed by DexGuard in your actual release and can be kept using the rule below. -keepclassmembers class classname { returntype methodname ( parametertypes ); } Add additional rules to keep any relevant code or disable any problematic optimizations. You can read more about the various optimizations that can be disabled on the optimizations page. Use a default test configuration . Depending on the configuration you choose, several classes will be kept and/or optimizations will be disabled. If the problem persists you'll likely have to add a custom keep rule.","title":"Test code"},{"location":"setup/espresso.html#resources","text":"DexGuard also processes the various resources that are used in your application, which means this can cause problems if you try to refer to them from your test code. Just as with code, try to avoid referring to application resources in your test code . If this is not possible, try running your tests to see if there are any issues. If there are, you can try any of the following suggestions: Use the dexguard-espresso-no-resource-optimizations.pro default test configuration. Keep the problematic resources using the -keepresources rule.","title":"Resources"},{"location":"setup/espresso.html#dependencies","text":"When building the tests the Android gradle plugin will treat the dependencies shared by the application and its tests as compile only dependencies, meaning they won't end up packaged in the test application. This saves space and in normal circumstances isn't an issue as the dependencies will be available in the application under test. However, when using DexGuard this no longer holds true because of its shrinking. If the application does not use a class that the tests do use, it will be removed during the shrinking step from the main application. Here are some suggestions to resolve these issues if they occur: Try to avoid sharing dependencies between your application and its tests. In general this shouldn't be too much of an issue, but there are some common cases where this is not possible. Add keep rules for the missing classes.","title":"Dependencies"},{"location":"setup/espresso.html#default-configurations","text":"DexGuard provides a few default configurations you can include for applicaton builds you're going to test using Espresso. These configurations have a specific purpose and are independent of each other, meaning you can use multiple at the same time. The available default configurations are explained in more detail below.","title":"Default configurations"},{"location":"setup/espresso.html#dexguard-espressopro","text":"This is the basic configuration needed to run Espresso tests on an application that is obfuscated by DexGuard. It also offers support for the @VisibleForTesting annotation which will prevent annotated classes or members from being obfuscated, shrunk or optimized in order to be accessed by tests. -include /lib/dexguard-espresso.pro","title":"dexguard-espresso.pro"},{"location":"setup/espresso.html#dexguard-espresso-no-resource-optimizationspro","text":"Using this default configuration makes using resources in your test code a non-issue. It disables all resource related optimizations so everything your tests expect to find should still be there with their original ids. -include /lib/dexguard-espresso-no-resource-optimizations.pro","title":"dexguard-espresso-no-resource-optimizations.pro"},{"location":"setup/espresso.html#dexguard-espresso-aggressive-optimizationspro","text":"This default configuration disables all less invasive code optimizations. These should be sufficient when your tests only access a small portion of the application code. The optimizations that are disabled are: field/marking/private method/marking/private method/marking/static method/marking/final method/inlining/short method/inlining/unique -include /lib/dexguard-espresso-aggressive-optimizations.pro","title":"dexguard-espresso-aggressive-optimizations.pro"},{"location":"setup/espresso.html#dexguard-espresso-safe-optimizationspro","text":"This is an extension of the dexguard-espresso-aggressive-optimizations.pro configuration and disables more optimizations. The optimizations in question are responsible for most drastic changes in code structure and using this configuration should allow you to access all of your application code from your tests. The optimizations that are disabled in addition to the ones mentioned above are: class/merging/vertical class/merging/horizontal class/merging/wrapper field/generalization/class method/generalization/class field/sepcialization/type method/sepcialization/parametertype method/sepcialization/returntype field/propagation/value method/propagation/parameter method/propagation/returnvalue -include /lib/dexguard-espresso-safe-optimizations.pro Note The configuration dexguard-espresso-safe-optimizations.pro is a superset of dexguard-espresso-aggressive-optimizations.pro . This means you should not include both at the same time. They can be combined with the other default configurations, just not with each other.","title":"dexguard-espresso-safe-optimizations.pro"},{"location":"setup/gradle-plugin.html","text":"Finding your protected APK DexGuard places your protected APK next to the original unprotected APK, in the same directory: build/outputs/apk/release/{app-name}-protected.apk . Note that build/outputs/apk/release/{app-name}.apk is the original, unprotected APK! Runtime-invisible annotations By default D8/R8 strips runtime-invisible annotations when building release configurations. If you rely on these annotations being visible to DexGuard, please visit this page for a workaround. Getting Started \u00b6 The DexGuard Gradle plugin is available in the libs folder of the DexGuard distribution or through the secure Maven repository . You can include the following in your root level build.gradle(.kts) file: Manual download (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. url '/path/to/DexGuard/lib' } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:+' // The DexGuard Gradle plugin. } } Manual download (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { url = uri ( \"/path/to/DexGuard/lib\" ) // For the DexGuard Gradle plugin jar. } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:+\" ) // The DexGuard Gradle plugin. } } Maven (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:1.2.7' // The DexGuard Gradle plugin. } } Maven (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:1.2.7\" ) // The DexGuard Gradle plugin. } } In case you want to copy the DexGuard plugin to a different location you need to copy the whole directory structure located in '/path/to/DexGuard/lib'. Apply Plugin \u00b6 To actually apply the plugin to your project, just add the line to your module level build.gradle(.kts) file after applying the Android Gradle plugin as shown below. Groovy apply plugin: 'dexguard' Kotlin plugins { id ( \"dexguard\" ) } Executing DexGuard \u00b6 DexGuard can be executed automatically whenever you build any of the configured variants. You can configure a variant using the dexguard block in your module level build.gradle(.kts) files. This is a top-level block and should be placed outside of the android block. Manual download (Groovy) android { ... } dexguard { path = 'path/to/dexguard/distribution' license = '/path/to/dexguard-license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' } debug { defaultConfiguration 'dexguard-debug.pro' } } } Manual download (Kotlin) android { ... } dexguard { path = \"path/to/dexguard/distribution\" license = \"/path/to/dexguard-license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) } register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) } } } Maven (Groovy) android { ... } dexguard { version = '9.2.7' license = '/path/to/dexguard-license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' } debug { defaultConfiguration 'dexguard-debug.pro' } } } Maven (Kotlin) android { ... } dexguard { version = \"9.2.7\" license = \"/path/to/dexguard-license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) } register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) } } } minifyEnabled DexGuard expects its inputs to be unobfuscated , so make sure none of the variants you specify here have the minifyEnabled options set to true . This will tell the DexGuard Gradle plugin the path to the DexGuard distribution it should use, which Android variants it should process and how these variants should be configured. The obfuscated apk/aab/aar is created alongside the unprotected artefact and is given a -protected suffix in the name. The other outputs (mapping files, reports, ...) can be found in the build/outputs/dexguard directory. The Gradle plugin will automatically configure DexGuard to sign its output using the same key that was used to sign its input. So you dont have to explicitly configure DexGuard to sign the processed app. Note Previous versions of the DexGuard Gradle plugin would replace the apk/aab/aar originally produced by the Android build chain. This is no longer the case . By default, the apk/aab/aar produced by the Android Gradle plugin will remain where it is, unprotected. The obfuscated version is placed in the same directory and is given a -protected suffix in the name. You can mimic the behavior of previous versions of the plugin, overwriting the unprotected apk/aab/aar, by specifying overwriteUnprotected = true in the dexguard block. Below is a more elaborate explanation of all the options available in the dexguard configuration block. Use DexGuard with Firebase Crashlytics \u00b6 The DexGuard gradle plugin has a built in Firebase Crashlytics integration, which allows it to automatically upload the correct mapping files. To enable this integration, please make sure to run through the following steps first Follow the Firebase Crashlytics guide to add the necessary plugins and dependencies to your project. Make sure your Crashlytics integration works without DexGuard . Make sure the DexGuard plugin is applied after the Firebase Crashlytics plugin. Do not set the mappingFileUploadEnabled or mappingFile properties of the Firebase Crashlytics plugin on DexGuard-enabled build types or flavors. The DexGuard Gradle plugin will expect your mapping files to be in their default locations. Please make sure to not add any -printmapping rules yourself when using this integration. Afterwards, you can use the uploadCrashlyticsMappingFile option to enable mapping file uploads for the required build types and flavors. Use DexGuard with dynamic features \u00b6 Dynamic feature projects can specify dependencies just like any other project. This means dynamic feature projects might have consumer rules or library jars associated with them. The Gradle plugin will need to collect these and pass them on to DexGuard to process your app bundle correctly. In order for the Gradle plugin to collect these inputs you must also apply the DexGuard Gradle plugin to your dynamic feature projects: Groovy apply plugin: 'com.android.dynamic-feature' apply plugin: 'dexguard' Kotlin plugins { id ( \"com.android.dynamic-feature\" ) id ( \"dexguard\" ) } This is all that is needed for the DexGuard Gradle plugin to correctly process app bundles with dynamic features. In case you need to specify a consumer rule filter for a dependency of a dynamic feature, you can do so in the dynamic feature project as shown below: Groovy dexguard { configurations { release { consumerRuleFilter 'myGroup:myModule' } } } Kotlin dexguard { configurations { register ( \"release\" ) { consumerRuleFilter ( \"myGroup:myModule\" ) } } } Only the consumerRuleFilter option is allowed for dynamic feature projects. Fat aar support \u00b6 The DexGuard Gradle plugin can process and merge dependencies (local or remote) into the resulting aar file. When an app includes the aar file, it can reference these dependencies and resources directly without the need for the end user of the aar to import these again. You can use the keyword embed instead of implementation or compile to package a dependency inside of the resulting aar. Groovy dependencies { embed 'com.example:yourdependency:8.7.08' } Kotlin dependencies { embed ( \"com.example:yourdependency:8.7.08\" ) } When referencing a project, Groovy dependencies { embed project ( ':moduleA' ) } Kotlin dependencies { embed ( project ( \":moduleA\" )) } When referencing a local file, Groovy repositories { flatDir { dirs 'libs' } } dependencies { embed ( name: 'moduleA' , ext: 'aar' ) } Kotlin repositories { flatDir { dirs ( \"libs\" ) } } dependencies { embed ( mapOf ( \"name\" to \"moduleA\" , \"ext\" to \"aar\" )) } A specific usage of this could be the inclusion of the DexGuard runtime into an SDK. Flavors and build types \u00b6 Embed dependencies also work for specific flavor and build type. You can specify such a dependency by appending Embed to the buildtype or flavor name. Groovy dependencies { releaseEmbed 'com.example:yourdependency:8.7.08' } Kotlin dependencies { releaseEmbed ( \"com.example:yourdependency:8.7.08\" ) } Groovy dependencies { flavor1Embed 'com.example:yourdependency:8.7.08' } Kotlin dependencies { flavor1Embed ( \"com.example:yourdependency:8.7.08\" ) } Transitive local dependency \u00b6 If you want to include local transitive dependencies in your final aar, you must explicitly add embed statements for these dependencies. For example, mainLib can depend on subLib1 , and subLib1 on subLib2 , this results in a transitive dependency of mainLib on subLib2 . If you want to include all dependencies in your aar, you must add embed for subLib1 and subLib2 in your build.gradle file. Transitive remote dependency \u00b6 If you want to include all remote transitive dependencies specified in the pom file of your dependency, you can set the transitive option to true in your build.gradle file. // the default value is false // this does not work for a local aar dependency configurations . embed . transitive = true The 'dexguard' block \u00b6 The following options are available in the dexguard block: path = <path> version = <version> license = <license> overwriteUnprotected = <true/false> configurations <variant configuration block> path \u00b6 The path (or version ) option is required when specifying the dexguard block and accepts a path, either as a String or a File object. The path should point to the DexGuard distribution directory you want the plugin to use. Groovy dexguard { path = \"path/to/dexguard/distribution\" } Kotlin dexguard { path = \"path/to/dexguard/distribution\" } version \u00b6 The version (or path ) option is required when specifying the dexguard block and accepts a Gradle-style version string . For example, you can keep up-to-date with patch releases for DexGuard version 9.2 using the following version string: Groovy dexguard { version = \"9.2.+\" } Kotlin dexguard { version = \"9.2.+\" } license \u00b6 The license option can be used to set the path to your DexGuard license file or the directory containing the file. If you do not specify your license here DexGuard will search for your license in the other standard locations . Groovy dexguard { license = \"/path/to/dexguard-license.txt\" } Kotlin dexguard { license = \"/path/to/dexguard-license.txt\" } overwriteUnprotected \u00b6 The overwriteUnprotected option is optional and is by default set to false . When set to true , DexGuard mimics the behavior of previous versions of the plugin by overwriting the unprotected apk/aab/aar with its protected version and keeping the original name of the input apk/aab/aar, without the -protected suffix. It is not recommended to overwrite the unprotected artifacts, as this would invalidate the Gradle caches and trigger DexGuard processing each time the artifacts are built. Groovy dexguard { overwriteUnprotected = true } Kotlin dexguard { overwriteUnprotected = true } configurations \u00b6 The configurations option is a block option of the dexguard block that can be used to specify DexGuard configurations for the Android variants you wish to obfuscate by using the name of that variant. For example, if you have a variant named premiumRelease you want to protect using DexGuard, you would write the following: Groovy dexguard { configurations { premiumRelease { ... } } } Kotlin dexguard { configurations { register ( \"premiumRelease\" ) { ... } } } For convenience, you can also use the build type name to match all variants that have that build type. For example, if you have the variants premiumRelease and freeRelease you can match both of them by using release : Groovy dexguard { configurations { release { ... } } } Kotlin dexguard { configurations { register ( \"release\" ) { ... } } } The following options are available in these variant configuration blocks: defaultConfiguration <name> defaultConfigurations <name>, ... configuration <path> configurations <path>, ... testConfiguration <path> testConfigurations <path>, ... consumerRuleFilter <dependency>, ... defaultConfiguration \u00b6 The defaultConfiguration option allows you to specify a default configuration file DexGuard should use. You can specify this option more than once, in which case all of the specified default configurations will be used. At least one default configuration must be specified. A list of available default configurations can be found on the default configurations page . Groovy dexguard { configurations { release { defaultConfiguration 'dexguard-release.pro' } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) } } } defaultConfigurations \u00b6 This option is the same as defaultConfiguration but allows you to specify multiple default configurations at once. Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' , 'dexguard-gson.pro' } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfigurations ( \"dexguard-release.pro\" , \"dexguard-gson.pro\" ) } } } is equivalent to Groovy dexguard { configurations { release { defaultConfiguration 'dexguard-release.pro' defaultConfiguration 'dexguard-gson.pro' } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) defaultConfiguration ( \"dexguard-gson.pro\" ) } } } configuration \u00b6 The configuration option allows you to specify a custom DexGuard configuration file DexGuard should use. Specifying this option multiple times will pass all of the specified configuration files to DexGuard. The option accepts a path to the configuration file to use, this can be either a String or File object. Groovy dexguard { configurations { release { configuration 'dexguard-project.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { configuration ( \"dexguard-project.txt\" ) } } } configurations \u00b6 This option is the same as configuration but allows you to specify multiple configuration files at once. For example, the following snippet Groovy dexguard { configurations { release { configurations 'dexguard-project.txt' , 'dexguard-project-release.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { configurations ( \"dexguard-project.txt\" , \"dexguard-project-release.txt\" ) } } } is equivalent to Groovy dexguard { configurations { release { configuration 'dexguard-project.txt' configuration 'dexguard-project-release.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { configuration ( \"dexguard-project.txt\" ) configuration ( \"dexguard-project-release.txt\" ) } } } testConfiguration \u00b6 The testConfiguration option allows you to specify a custom DexGuard configuration file DexGuard should use when processing the test variant of the configured variant. It has the same semantics as the configuration option. In general, you won't need to configure the test variant as the DexGuard Gradle plugin will do this for you. This option is only useful in the rare cases where it is necessary to configure the test variant. Groovy dexguard { configurations { release { testConfiguration 'dexguard-test.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { testConfiguration ( \"dexguard-test.txt\" ) } } } testConfigurations \u00b6 This option is the same as testConfiguration but allows you to specify multiple configuration files at once. Its semantics are the same as the ones for the configurations option. consumerRuleFilter \u00b6 The consumerRuleFilter option allows you to specify a list of maven group and module name pairs to filter out the ProGuard consumer rules of the dependencies that match the specified group and module pairs. A group and module name pair is very similar to the maven coordinates you write when specifying the dependencies in the dependencies block, but without the version part. Groovy dexguard { configurations { release { consumerRuleFilter 'groupName:moduleName' , 'anotherGroupName:anotherModuleName' } } } Kotlin dexguard { configurations { register ( \"release\" ) { consumerRuleFilter ( \"groupName:moduleName\" , \"anotherGroupName:anotherModuleName\" ) } } } jvmArgs \u00b6 You can pass arguments to the JVM process in which DexGuard is executed using the jvmArgs option. This option takes list of strings, for example, you can set the initial and maximum heap sizes using the following: Groovy dexguard { jvmArgs \"-Xms512M\" , \"-Xmx2048M\" ... } Kotlin dexguard { jvmArgs ( \"-Xms512M\" , \"-Xmx2048M\" ) ... } uploadCrashlyticsMappingFile \u00b6 For this option to work correctly, please first follow the steps outlined in the \"Use DexGuard with Firebase Crashlytics section\" . This option instructs the DexGuard gradle plugin to upload mapping files to Crashlytics for the build types or flavors on which it is set to true . By default, it is set to false . For example, if you wish to upload mapping files for all release variants, you could use the following: Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = true } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = true } } } If you have multiple flavors of a certain build type, you can also enable or disable the uploading of mapping files independently for each individual flavor. For example, if you wish to enable the uploading of mapping files for all release flavors, except internal , you could use the following: Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = true } internalRelease { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = false } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = true } register ( \"internalRelease\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = false } } } If you only wish to upload mapping files for one specific variant, e.g. external , you could use the following: Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' } externalRelease { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = true } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) } register ( \"externalRelease\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = true } } } Disabling splits At this moment, it is not possible to enable splits when integrating with Crashlytics. DexGuard only produces a single mapping file per build variant, and it is not valid for every split APK that would be built. Info Make sure to thoroughly test your Crashlytics integration before releasing. After enabling the uploading of mapping files, you should see two additional tasks being executed when assembling a variant. One will inject the necessary mapping file ID, a second one will upload your mapping file to Crashlytics. If you cause an intentional crash, a deobfuscated stack trace should show up in your Crashlytics console afterwards.","title":"Gradle Plugin"},{"location":"setup/gradle-plugin.html#getting-started","text":"The DexGuard Gradle plugin is available in the libs folder of the DexGuard distribution or through the secure Maven repository . You can include the following in your root level build.gradle(.kts) file: Manual download (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. url '/path/to/DexGuard/lib' } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:+' // The DexGuard Gradle plugin. } } Manual download (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { url = uri ( \"/path/to/DexGuard/lib\" ) // For the DexGuard Gradle plugin jar. } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:+\" ) // The DexGuard Gradle plugin. } } Maven (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:1.2.7' // The DexGuard Gradle plugin. } } Maven (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:1.2.7\" ) // The DexGuard Gradle plugin. } } In case you want to copy the DexGuard plugin to a different location you need to copy the whole directory structure located in '/path/to/DexGuard/lib'.","title":"Getting Started"},{"location":"setup/gradle-plugin.html#apply-plugin","text":"To actually apply the plugin to your project, just add the line to your module level build.gradle(.kts) file after applying the Android Gradle plugin as shown below. Groovy apply plugin: 'dexguard' Kotlin plugins { id ( \"dexguard\" ) }","title":"Apply Plugin"},{"location":"setup/gradle-plugin.html#executing-dexguard","text":"DexGuard can be executed automatically whenever you build any of the configured variants. You can configure a variant using the dexguard block in your module level build.gradle(.kts) files. This is a top-level block and should be placed outside of the android block. Manual download (Groovy) android { ... } dexguard { path = 'path/to/dexguard/distribution' license = '/path/to/dexguard-license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' } debug { defaultConfiguration 'dexguard-debug.pro' } } } Manual download (Kotlin) android { ... } dexguard { path = \"path/to/dexguard/distribution\" license = \"/path/to/dexguard-license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) } register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) } } } Maven (Groovy) android { ... } dexguard { version = '9.2.7' license = '/path/to/dexguard-license.txt' configurations { release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' } debug { defaultConfiguration 'dexguard-debug.pro' } } } Maven (Kotlin) android { ... } dexguard { version = \"9.2.7\" license = \"/path/to/dexguard-license.txt\" configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) } register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) } } } minifyEnabled DexGuard expects its inputs to be unobfuscated , so make sure none of the variants you specify here have the minifyEnabled options set to true . This will tell the DexGuard Gradle plugin the path to the DexGuard distribution it should use, which Android variants it should process and how these variants should be configured. The obfuscated apk/aab/aar is created alongside the unprotected artefact and is given a -protected suffix in the name. The other outputs (mapping files, reports, ...) can be found in the build/outputs/dexguard directory. The Gradle plugin will automatically configure DexGuard to sign its output using the same key that was used to sign its input. So you dont have to explicitly configure DexGuard to sign the processed app. Note Previous versions of the DexGuard Gradle plugin would replace the apk/aab/aar originally produced by the Android build chain. This is no longer the case . By default, the apk/aab/aar produced by the Android Gradle plugin will remain where it is, unprotected. The obfuscated version is placed in the same directory and is given a -protected suffix in the name. You can mimic the behavior of previous versions of the plugin, overwriting the unprotected apk/aab/aar, by specifying overwriteUnprotected = true in the dexguard block. Below is a more elaborate explanation of all the options available in the dexguard configuration block.","title":"Executing DexGuard"},{"location":"setup/gradle-plugin.html#use-dexguard-with-firebase-crashlytics","text":"The DexGuard gradle plugin has a built in Firebase Crashlytics integration, which allows it to automatically upload the correct mapping files. To enable this integration, please make sure to run through the following steps first Follow the Firebase Crashlytics guide to add the necessary plugins and dependencies to your project. Make sure your Crashlytics integration works without DexGuard . Make sure the DexGuard plugin is applied after the Firebase Crashlytics plugin. Do not set the mappingFileUploadEnabled or mappingFile properties of the Firebase Crashlytics plugin on DexGuard-enabled build types or flavors. The DexGuard Gradle plugin will expect your mapping files to be in their default locations. Please make sure to not add any -printmapping rules yourself when using this integration. Afterwards, you can use the uploadCrashlyticsMappingFile option to enable mapping file uploads for the required build types and flavors.","title":"Use DexGuard with Firebase Crashlytics"},{"location":"setup/gradle-plugin.html#use-dexguard-with-dynamic-features","text":"Dynamic feature projects can specify dependencies just like any other project. This means dynamic feature projects might have consumer rules or library jars associated with them. The Gradle plugin will need to collect these and pass them on to DexGuard to process your app bundle correctly. In order for the Gradle plugin to collect these inputs you must also apply the DexGuard Gradle plugin to your dynamic feature projects: Groovy apply plugin: 'com.android.dynamic-feature' apply plugin: 'dexguard' Kotlin plugins { id ( \"com.android.dynamic-feature\" ) id ( \"dexguard\" ) } This is all that is needed for the DexGuard Gradle plugin to correctly process app bundles with dynamic features. In case you need to specify a consumer rule filter for a dependency of a dynamic feature, you can do so in the dynamic feature project as shown below: Groovy dexguard { configurations { release { consumerRuleFilter 'myGroup:myModule' } } } Kotlin dexguard { configurations { register ( \"release\" ) { consumerRuleFilter ( \"myGroup:myModule\" ) } } } Only the consumerRuleFilter option is allowed for dynamic feature projects.","title":"Use DexGuard with dynamic features"},{"location":"setup/gradle-plugin.html#fat-aar","text":"The DexGuard Gradle plugin can process and merge dependencies (local or remote) into the resulting aar file. When an app includes the aar file, it can reference these dependencies and resources directly without the need for the end user of the aar to import these again. You can use the keyword embed instead of implementation or compile to package a dependency inside of the resulting aar. Groovy dependencies { embed 'com.example:yourdependency:8.7.08' } Kotlin dependencies { embed ( \"com.example:yourdependency:8.7.08\" ) } When referencing a project, Groovy dependencies { embed project ( ':moduleA' ) } Kotlin dependencies { embed ( project ( \":moduleA\" )) } When referencing a local file, Groovy repositories { flatDir { dirs 'libs' } } dependencies { embed ( name: 'moduleA' , ext: 'aar' ) } Kotlin repositories { flatDir { dirs ( \"libs\" ) } } dependencies { embed ( mapOf ( \"name\" to \"moduleA\" , \"ext\" to \"aar\" )) } A specific usage of this could be the inclusion of the DexGuard runtime into an SDK.","title":"Fat aar support"},{"location":"setup/gradle-plugin.html#flavors-and-build-types","text":"Embed dependencies also work for specific flavor and build type. You can specify such a dependency by appending Embed to the buildtype or flavor name. Groovy dependencies { releaseEmbed 'com.example:yourdependency:8.7.08' } Kotlin dependencies { releaseEmbed ( \"com.example:yourdependency:8.7.08\" ) } Groovy dependencies { flavor1Embed 'com.example:yourdependency:8.7.08' } Kotlin dependencies { flavor1Embed ( \"com.example:yourdependency:8.7.08\" ) }","title":"Flavors and build types"},{"location":"setup/gradle-plugin.html#transitive-local-dependency","text":"If you want to include local transitive dependencies in your final aar, you must explicitly add embed statements for these dependencies. For example, mainLib can depend on subLib1 , and subLib1 on subLib2 , this results in a transitive dependency of mainLib on subLib2 . If you want to include all dependencies in your aar, you must add embed for subLib1 and subLib2 in your build.gradle file.","title":"Transitive local dependency"},{"location":"setup/gradle-plugin.html#transitive-remote-dependency","text":"If you want to include all remote transitive dependencies specified in the pom file of your dependency, you can set the transitive option to true in your build.gradle file. // the default value is false // this does not work for a local aar dependency configurations . embed . transitive = true","title":"Transitive remote dependency"},{"location":"setup/gradle-plugin.html#the-dexguard-block","text":"The following options are available in the dexguard block: path = <path> version = <version> license = <license> overwriteUnprotected = <true/false> configurations <variant configuration block>","title":"The 'dexguard' block"},{"location":"setup/gradle-plugin.html#path","text":"The path (or version ) option is required when specifying the dexguard block and accepts a path, either as a String or a File object. The path should point to the DexGuard distribution directory you want the plugin to use. Groovy dexguard { path = \"path/to/dexguard/distribution\" } Kotlin dexguard { path = \"path/to/dexguard/distribution\" }","title":"path"},{"location":"setup/gradle-plugin.html#version","text":"The version (or path ) option is required when specifying the dexguard block and accepts a Gradle-style version string . For example, you can keep up-to-date with patch releases for DexGuard version 9.2 using the following version string: Groovy dexguard { version = \"9.2.+\" } Kotlin dexguard { version = \"9.2.+\" }","title":"version"},{"location":"setup/gradle-plugin.html#license","text":"The license option can be used to set the path to your DexGuard license file or the directory containing the file. If you do not specify your license here DexGuard will search for your license in the other standard locations . Groovy dexguard { license = \"/path/to/dexguard-license.txt\" } Kotlin dexguard { license = \"/path/to/dexguard-license.txt\" }","title":"license"},{"location":"setup/gradle-plugin.html#overwriteunprotected","text":"The overwriteUnprotected option is optional and is by default set to false . When set to true , DexGuard mimics the behavior of previous versions of the plugin by overwriting the unprotected apk/aab/aar with its protected version and keeping the original name of the input apk/aab/aar, without the -protected suffix. It is not recommended to overwrite the unprotected artifacts, as this would invalidate the Gradle caches and trigger DexGuard processing each time the artifacts are built. Groovy dexguard { overwriteUnprotected = true } Kotlin dexguard { overwriteUnprotected = true }","title":"overwriteUnprotected"},{"location":"setup/gradle-plugin.html#configurations","text":"The configurations option is a block option of the dexguard block that can be used to specify DexGuard configurations for the Android variants you wish to obfuscate by using the name of that variant. For example, if you have a variant named premiumRelease you want to protect using DexGuard, you would write the following: Groovy dexguard { configurations { premiumRelease { ... } } } Kotlin dexguard { configurations { register ( \"premiumRelease\" ) { ... } } } For convenience, you can also use the build type name to match all variants that have that build type. For example, if you have the variants premiumRelease and freeRelease you can match both of them by using release : Groovy dexguard { configurations { release { ... } } } Kotlin dexguard { configurations { register ( \"release\" ) { ... } } } The following options are available in these variant configuration blocks: defaultConfiguration <name> defaultConfigurations <name>, ... configuration <path> configurations <path>, ... testConfiguration <path> testConfigurations <path>, ... consumerRuleFilter <dependency>, ...","title":"configurations"},{"location":"setup/gradle-plugin.html#defaultconfiguration","text":"The defaultConfiguration option allows you to specify a default configuration file DexGuard should use. You can specify this option more than once, in which case all of the specified default configurations will be used. At least one default configuration must be specified. A list of available default configurations can be found on the default configurations page . Groovy dexguard { configurations { release { defaultConfiguration 'dexguard-release.pro' } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) } } }","title":"defaultConfiguration"},{"location":"setup/gradle-plugin.html#defaultconfigurations","text":"This option is the same as defaultConfiguration but allows you to specify multiple default configurations at once. Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' , 'dexguard-gson.pro' } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfigurations ( \"dexguard-release.pro\" , \"dexguard-gson.pro\" ) } } } is equivalent to Groovy dexguard { configurations { release { defaultConfiguration 'dexguard-release.pro' defaultConfiguration 'dexguard-gson.pro' } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) defaultConfiguration ( \"dexguard-gson.pro\" ) } } }","title":"defaultConfigurations"},{"location":"setup/gradle-plugin.html#configuration","text":"The configuration option allows you to specify a custom DexGuard configuration file DexGuard should use. Specifying this option multiple times will pass all of the specified configuration files to DexGuard. The option accepts a path to the configuration file to use, this can be either a String or File object. Groovy dexguard { configurations { release { configuration 'dexguard-project.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { configuration ( \"dexguard-project.txt\" ) } } }","title":"configuration"},{"location":"setup/gradle-plugin.html#configurations_1","text":"This option is the same as configuration but allows you to specify multiple configuration files at once. For example, the following snippet Groovy dexguard { configurations { release { configurations 'dexguard-project.txt' , 'dexguard-project-release.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { configurations ( \"dexguard-project.txt\" , \"dexguard-project-release.txt\" ) } } } is equivalent to Groovy dexguard { configurations { release { configuration 'dexguard-project.txt' configuration 'dexguard-project-release.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { configuration ( \"dexguard-project.txt\" ) configuration ( \"dexguard-project-release.txt\" ) } } }","title":"configurations"},{"location":"setup/gradle-plugin.html#testconfiguration","text":"The testConfiguration option allows you to specify a custom DexGuard configuration file DexGuard should use when processing the test variant of the configured variant. It has the same semantics as the configuration option. In general, you won't need to configure the test variant as the DexGuard Gradle plugin will do this for you. This option is only useful in the rare cases where it is necessary to configure the test variant. Groovy dexguard { configurations { release { testConfiguration 'dexguard-test.txt' } } } Kotlin dexguard { configurations { register ( \"release\" ) { testConfiguration ( \"dexguard-test.txt\" ) } } }","title":"testConfiguration"},{"location":"setup/gradle-plugin.html#testconfigurations","text":"This option is the same as testConfiguration but allows you to specify multiple configuration files at once. Its semantics are the same as the ones for the configurations option.","title":"testConfigurations"},{"location":"setup/gradle-plugin.html#consumerrulefilter","text":"The consumerRuleFilter option allows you to specify a list of maven group and module name pairs to filter out the ProGuard consumer rules of the dependencies that match the specified group and module pairs. A group and module name pair is very similar to the maven coordinates you write when specifying the dependencies in the dependencies block, but without the version part. Groovy dexguard { configurations { release { consumerRuleFilter 'groupName:moduleName' , 'anotherGroupName:anotherModuleName' } } } Kotlin dexguard { configurations { register ( \"release\" ) { consumerRuleFilter ( \"groupName:moduleName\" , \"anotherGroupName:anotherModuleName\" ) } } }","title":"consumerRuleFilter"},{"location":"setup/gradle-plugin.html#jvmargs","text":"You can pass arguments to the JVM process in which DexGuard is executed using the jvmArgs option. This option takes list of strings, for example, you can set the initial and maximum heap sizes using the following: Groovy dexguard { jvmArgs \"-Xms512M\" , \"-Xmx2048M\" ... } Kotlin dexguard { jvmArgs ( \"-Xms512M\" , \"-Xmx2048M\" ) ... }","title":"jvmArgs"},{"location":"setup/gradle-plugin.html#uploadcrashlyticsmappingfile","text":"For this option to work correctly, please first follow the steps outlined in the \"Use DexGuard with Firebase Crashlytics section\" . This option instructs the DexGuard gradle plugin to upload mapping files to Crashlytics for the build types or flavors on which it is set to true . By default, it is set to false . For example, if you wish to upload mapping files for all release variants, you could use the following: Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = true } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = true } } } If you have multiple flavors of a certain build type, you can also enable or disable the uploading of mapping files independently for each individual flavor. For example, if you wish to enable the uploading of mapping files for all release flavors, except internal , you could use the following: Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = true } internalRelease { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = false } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = true } register ( \"internalRelease\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = false } } } If you only wish to upload mapping files for one specific variant, e.g. external , you could use the following: Groovy dexguard { configurations { release { defaultConfigurations 'dexguard-release.pro' } externalRelease { defaultConfigurations 'dexguard-release.pro' uploadCrashlyticsMappingFile = true } } } Kotlin dexguard { configurations { register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) } register ( \"externalRelease\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) uploadCrashlyticsMappingFile = true } } } Disabling splits At this moment, it is not possible to enable splits when integrating with Crashlytics. DexGuard only produces a single mapping file per build variant, and it is not valid for every split APK that would be built. Info Make sure to thoroughly test your Crashlytics integration before releasing. After enabling the uploading of mapping files, you should see two additional tasks being executed when assembling a variant. One will inject the necessary mapping file ID, a second one will upload your mapping file to Crashlytics. If you cause an intentional crash, a deobfuscated stack trace should show up in your Crashlytics console afterwards.","title":"uploadCrashlyticsMappingFile"},{"location":"setup/repository.html","text":"This page will describe how to configure access to the secure maven repository giving access to various artifacts included in the DexGuard distribution. Configuring the secure maven repository / dependencies \u00b6 For the DexGuard Gradle plugin, you can include the following in your root level build.gradle(.kts) file: Groovy buildscript { repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependencies { classpath 'com.guardsquare:dexguard-gradle-plugin:1.2.7' } } Kotlin buildscript { repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependencies { classpath ( \"com.guardsquare:dexguard-gradle-plugin:1.2.7\" ) } } For project scope dependencies, you can include the following in your module level build.gradle(.kts) file: Groovy repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependency { // Example: include the DexGuard runtime library. implementation 'com.guardsquare:dexguard-runtime:9.2.7' } Kotlin repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependency { // Example: include the DexGuard runtime library. implementation ( \"com.guardsquare:dexguard-runtime:9.2.7\" ) } and in gradle.properties define user / password: dexguardMavenUser = <username> dexguardMavenPassword = <password> Note In order to avoid the need to commit login credentials to source code repositories, you can define empty properties ( dexguardMavenUser= , dexguardMavenPassword= ) in your project-specific gradle.properties file and define the actual credentials in the user specific gradle.properties file located under ~/.gradle . Gradle will replace these properties with the ones defined in the user properties. Available artifacts \u00b6 Artifact Maven coordinates Scope DexGuard com.guardsquare:dexguard:9.2.7 buildscript DexGuard Gradle plugin com.guardsquare:dexguard-gradle-plugin:1.2.7 buildscript DexGuard runtime library com.guardsquare:dexguard-runtime:9.2.7 project DexGuard native loader com.guardsquare:dexguard-nativeloader:9.2.7 project DexGuard annotations com.guardsquare:dexguard-annotations:9.2.7 project DexGuard RASP library com.guardsquare:dexguard-rasp:9.2.7 project DexGuard ThreatCast client com.guardsquare:dexguard-threatcast-client:9.2.7 project com.guardsquare:dexguard-threatcast-client:9.2.7:debug project","title":"Maven repository"},{"location":"setup/repository.html#configuring-the-secure-maven-repository-dependencies","text":"For the DexGuard Gradle plugin, you can include the following in your root level build.gradle(.kts) file: Groovy buildscript { repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependencies { classpath 'com.guardsquare:dexguard-gradle-plugin:1.2.7' } } Kotlin buildscript { repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependencies { classpath ( \"com.guardsquare:dexguard-gradle-plugin:1.2.7\" ) } } For project scope dependencies, you can include the following in your module level build.gradle(.kts) file: Groovy repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependency { // Example: include the DexGuard runtime library. implementation 'com.guardsquare:dexguard-runtime:9.2.7' } Kotlin repositories { ... google () mavenCentral () maven { credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependency { // Example: include the DexGuard runtime library. implementation ( \"com.guardsquare:dexguard-runtime:9.2.7\" ) } and in gradle.properties define user / password: dexguardMavenUser = <username> dexguardMavenPassword = <password> Note In order to avoid the need to commit login credentials to source code repositories, you can define empty properties ( dexguardMavenUser= , dexguardMavenPassword= ) in your project-specific gradle.properties file and define the actual credentials in the user specific gradle.properties file located under ~/.gradle . Gradle will replace these properties with the ones defined in the user properties.","title":"Configuring the secure maven repository / dependencies"},{"location":"setup/repository.html#available-artifacts","text":"Artifact Maven coordinates Scope DexGuard com.guardsquare:dexguard:9.2.7 buildscript DexGuard Gradle plugin com.guardsquare:dexguard-gradle-plugin:1.2.7 buildscript DexGuard runtime library com.guardsquare:dexguard-runtime:9.2.7 project DexGuard native loader com.guardsquare:dexguard-nativeloader:9.2.7 project DexGuard annotations com.guardsquare:dexguard-annotations:9.2.7 project DexGuard RASP library com.guardsquare:dexguard-rasp:9.2.7 project DexGuard ThreatCast client com.guardsquare:dexguard-threatcast-client:9.2.7 project com.guardsquare:dexguard-threatcast-client:9.2.7:debug project","title":"Available artifacts"},{"location":"setup/standalone.html","text":"Runtime-invisible annotations By default D8/R8 strips runtime-invisible annotations when building release configurations. If you rely on these annotations being visible to DexGuard, please visit this page for a workaround. DexGuard is a command line tool for processing Android applications ( .apk , .aab ) and libraries ( .aar ). The tool can be invoked as shown below: Linux/macOS bin/dexguard.sh <options> ... Windows bin\\dexguard < options > ... Typically, most of the options you pass to DexGuard will be put in a separate configuration file, dexguard-configuration.pro for example. You can then invoke DexGuard with this configuration file using the include option: Linux/macOS bin/dexguard.sh -include dexguard-configuration.pro Windows bin\\dexguard -include dexguard-configuration.pro You don't have to put all of your options in the file when you call DexGuard like this, and you can also specify multiple files if you like. Tip When including files on the command line, you can use the @ symbol instead of -include as a shorthand: Linux/macOS bin/dexguard.sh @dexguard-configuration.pro Windows bin\\dexguard @dexguard-configuration.pro Basic configuration \u00b6 The basic configuration required for DexGuard to run properly consists of the following: The binary to process ( .apk , .aab or .aar ). Name and location of the output file. The default configuration to use. The compile-only dependencies. The binary to process \u00b6 You have to pass in the file you want DexGuard to process using the injars option. The file types currently supported by DexGuard are: Android application ( .apk , .aab ) Android library ( .aar ) Example: -injars path/to/my-application.apk Name and location of the output file \u00b6 This will tell DexGuard where to output the obfuscated result and how to name it. The outjars option is used for this purpose. Example: -outjars path/to/output-application.apk Note DexGuard will not create the child directories of the output file. Make sure the directories exist before executing DexGuard as these missing directories are considered an error. The default configuration to use \u00b6 DexGuard includes several default configurations that contain rules to configure DexGuard to process a particular type of input. It also contains rules for well known and popular libraries. A full list of available default configurations and a description for each of them can be found on the default configurations page . The default configurations are packaged inside DexGuard and can be referred to by prefixing their name with /lib/ . For example, if you want to refer to the dexguard-release.pro default configuration you would use /lib/dexguard-release.pro . Example: -include /lib/dexguard-release.pro The include option can also be used inside a configuration file. The compile-only dependencies \u00b6 Not all of the application or library dependencies end up in the final binary. These dependencies are necessary for DexGuard to reason about the code and should be supplied to ensure the best possible obfuscation. For application projects ( .apk , .aab ) these are APIs that are expected to be on the target device, like the Android standard libraries. For library projects ( .aar ) these are almost all dependencies, except for local jar dependencies. The option used to pass these on to DexGuard is the libraryjars option: Example: -libraryjars path/to/android/sdk/platforms/android-XX/android.jar Example of a typical setup \u00b6 A typical setup will look something like this: Application -injars path/to/my-application.apk -outjars path/to/obfuscated-application.apk -libraryjars path/to/android/sdk/platforms/android-XX/android.jar -include /lib/dexguard-release.pro # My application-specific keep rules go here. ... Library -injars path/to/my-application.aar -outjars path/to/obfuscated-application.aar -libraryjars path/to/dependency1.aar ... -libraryjars path/to/dependencyN.jar -libraryjars path/to/android/sdk/platforms/android-XX/android.jar -include /lib/dexguard-library-release.pro # My application-specific keep rules go here. ... This allows you to call DexGuard like so: Linux/macOS bin/dexguard.sh -include dexguard-configuration.pro Windows bin\\dexguard -include dexguard-configuration.pro This has all of your configuration neatly stored together. You can then add any project-specific rules you need, either in the same file or in another file using the -include option. Configuration file \u00b6 The DexGuard configuration file format is a text file with a list of DexGuard command line options in it. Options can contain filters to whitelist or blacklist certain names/files/classes/packages from being processed by DexGuard. For a full list and detailed explanation of all the options, take a look at the reference guide . The format supports comments. A comment starts with a # symbol and continues until the end of the line. Extra whitespace between words and delimiters is ignored. File names with spaces or special characters should be quoted with single or double quotes. The order of the options is generally irrelevant. However, do note specifying the same option multiple times will concatenate the passed parameters. Changing the order of these options will also change the resulting list as a consequence. For example, the following rules -keepresourcefiles !lib/*/libsecret.so -keepresourcefiles lib/*/lib*.so are equivalant to -keepresourcefiles !lib/*/libsecret.so,lib/*/lib*.so This rule will keep all native libraries, except for libsecret.so . If you were to flip the order of the rules, they would be equivalant to -keepresourcefiles lib/*/lib*.so,!lib/*/libsecret.so which keeps all native libraries, including libsecret.so . Consumer rules \u00b6 Some libraries come with so called 'ProGuard consumer rules'. These are rules necessary for the library to continue working properly after processing it with ProGuard and, by extension, DexGuard as well. It is advised you check the dependencies of your application for these rules and apply them. These rules are only relevant for applications ( .apk , .aab ), not for libraries ( .aar ). Android SDK libraries \u00b6 The Android SDK contains the Android standard API which can be used by your application or library - this is android.jar . You should add this library as a dependency in your DexGuard configuration: -libraryjars path/to/android/sdk/platforms/android-XX/android.jar Some other dependencies might also be provided by the Android SDK, such as the legacy Apache HTTP library ( org.apache.http.legacy.jar ). Mapping files \u00b6 DexGuard can print out certain files containing some information on how DexGuard affected your application or library. These files aren't printed by default and have to be enabled with their corresponding option. Below are some examples: -printmapping path/to/mapping.txt - printresourcemapping path / to / resourcemapping.txt -printresourcefilenamemapping path/to/resourcefilenamemapping.txt -printseeds path/to/seeds.txt -printusage path/to/usage.txt -printresourceusage path / to / resourceusage.txt - printinjectmapping path / to / injectmapping.txt -printclassencryption path/to/classencryption.txt -printstringencryption path/to/stringencryption.txt -printassetencryption path/to/assetencryption.txt -printresourceencryption path/to/resourceencryption.txt -printnativelibraryencryption path/to/nativelibraryencryption.txt -printmaindexlist path / to / maindexlist.txt You can read the reference guide for more information about these options and the files they produce. Signing configuration \u00b6 DexGuard has the ability to sign your application ( .apk , .aab ). In order to do so, it will need the signing configuration, which can be specified as shown below: -keystore path/to/my/keystore.ks -keystorepassword supersecretpassword -keyalias myalias -keypassword supersecretpassword You may not want to put this, especially the passwords, in your main configuration file. One suggestion is to put these rules in a separate configuration file and include it in your main configuration file. Alternatively, if you don't want to check this file into source control or don't want to have to create the file for each checkout, you can pass the file to DexGuard directly: Linux/macOS bin/dexguard.sh -include dexguard-configuration.pro -include signing-config.pro Windows bin\\dexguard -include dexguard-configuration.pro -include signing-config.pro You can also choose to pass in the options directly instead of putting them in a file: Linux/macOS bin/dexguard.sh -include dexguard-configuration.pro \\ -keystore path/to/my/keystore.ks \\ -keystorepassword supersecretpassword \\ -keyalias myalias \\ -keypassword supersecretpassword Windows bin\\dexguard -include dexguard-configuration.pro ^ -keystore path/to/my/keystore.ks ^ -keystorepassword supersecretpassword ^ -keyalias myalias ^ -keypassword supersecretpassword Default debug keystore \u00b6 The default debug keystore shipped with the Android SDK can be found in a hidden generated directory called .android in your home folder. The file has the name debug.keystore . You can use this keystore in your DexGuard signing configuration like so: -keystore <user.home>/.android/debug.keystore -keystorepassword android -keyalias androiddebugkey -keypassword android","title":"DexGuard"},{"location":"setup/standalone.html#basic-configuration","text":"The basic configuration required for DexGuard to run properly consists of the following: The binary to process ( .apk , .aab or .aar ). Name and location of the output file. The default configuration to use. The compile-only dependencies.","title":"Basic configuration"},{"location":"setup/standalone.html#the-binary-to-process","text":"You have to pass in the file you want DexGuard to process using the injars option. The file types currently supported by DexGuard are: Android application ( .apk , .aab ) Android library ( .aar ) Example: -injars path/to/my-application.apk","title":"The binary to process"},{"location":"setup/standalone.html#name-and-location-of-the-output-file","text":"This will tell DexGuard where to output the obfuscated result and how to name it. The outjars option is used for this purpose. Example: -outjars path/to/output-application.apk Note DexGuard will not create the child directories of the output file. Make sure the directories exist before executing DexGuard as these missing directories are considered an error.","title":"Name and location of the output file"},{"location":"setup/standalone.html#the-default-configuration-to-use","text":"DexGuard includes several default configurations that contain rules to configure DexGuard to process a particular type of input. It also contains rules for well known and popular libraries. A full list of available default configurations and a description for each of them can be found on the default configurations page . The default configurations are packaged inside DexGuard and can be referred to by prefixing their name with /lib/ . For example, if you want to refer to the dexguard-release.pro default configuration you would use /lib/dexguard-release.pro . Example: -include /lib/dexguard-release.pro The include option can also be used inside a configuration file.","title":"The default configuration to use"},{"location":"setup/standalone.html#the-compile-only-dependencies","text":"Not all of the application or library dependencies end up in the final binary. These dependencies are necessary for DexGuard to reason about the code and should be supplied to ensure the best possible obfuscation. For application projects ( .apk , .aab ) these are APIs that are expected to be on the target device, like the Android standard libraries. For library projects ( .aar ) these are almost all dependencies, except for local jar dependencies. The option used to pass these on to DexGuard is the libraryjars option: Example: -libraryjars path/to/android/sdk/platforms/android-XX/android.jar","title":"The compile-only dependencies"},{"location":"setup/standalone.html#example-of-a-typical-setup","text":"A typical setup will look something like this: Application -injars path/to/my-application.apk -outjars path/to/obfuscated-application.apk -libraryjars path/to/android/sdk/platforms/android-XX/android.jar -include /lib/dexguard-release.pro # My application-specific keep rules go here. ... Library -injars path/to/my-application.aar -outjars path/to/obfuscated-application.aar -libraryjars path/to/dependency1.aar ... -libraryjars path/to/dependencyN.jar -libraryjars path/to/android/sdk/platforms/android-XX/android.jar -include /lib/dexguard-library-release.pro # My application-specific keep rules go here. ... This allows you to call DexGuard like so: Linux/macOS bin/dexguard.sh -include dexguard-configuration.pro Windows bin\\dexguard -include dexguard-configuration.pro This has all of your configuration neatly stored together. You can then add any project-specific rules you need, either in the same file or in another file using the -include option.","title":"Example of a typical setup"},{"location":"setup/standalone.html#configuration-file","text":"The DexGuard configuration file format is a text file with a list of DexGuard command line options in it. Options can contain filters to whitelist or blacklist certain names/files/classes/packages from being processed by DexGuard. For a full list and detailed explanation of all the options, take a look at the reference guide . The format supports comments. A comment starts with a # symbol and continues until the end of the line. Extra whitespace between words and delimiters is ignored. File names with spaces or special characters should be quoted with single or double quotes. The order of the options is generally irrelevant. However, do note specifying the same option multiple times will concatenate the passed parameters. Changing the order of these options will also change the resulting list as a consequence. For example, the following rules -keepresourcefiles !lib/*/libsecret.so -keepresourcefiles lib/*/lib*.so are equivalant to -keepresourcefiles !lib/*/libsecret.so,lib/*/lib*.so This rule will keep all native libraries, except for libsecret.so . If you were to flip the order of the rules, they would be equivalant to -keepresourcefiles lib/*/lib*.so,!lib/*/libsecret.so which keeps all native libraries, including libsecret.so .","title":"Configuration file"},{"location":"setup/standalone.html#consumer-rules","text":"Some libraries come with so called 'ProGuard consumer rules'. These are rules necessary for the library to continue working properly after processing it with ProGuard and, by extension, DexGuard as well. It is advised you check the dependencies of your application for these rules and apply them. These rules are only relevant for applications ( .apk , .aab ), not for libraries ( .aar ).","title":"Consumer rules"},{"location":"setup/standalone.html#android-sdk-libraries","text":"The Android SDK contains the Android standard API which can be used by your application or library - this is android.jar . You should add this library as a dependency in your DexGuard configuration: -libraryjars path/to/android/sdk/platforms/android-XX/android.jar Some other dependencies might also be provided by the Android SDK, such as the legacy Apache HTTP library ( org.apache.http.legacy.jar ).","title":"Android SDK libraries"},{"location":"setup/standalone.html#mapping-files","text":"DexGuard can print out certain files containing some information on how DexGuard affected your application or library. These files aren't printed by default and have to be enabled with their corresponding option. Below are some examples: -printmapping path/to/mapping.txt - printresourcemapping path / to / resourcemapping.txt -printresourcefilenamemapping path/to/resourcefilenamemapping.txt -printseeds path/to/seeds.txt -printusage path/to/usage.txt -printresourceusage path / to / resourceusage.txt - printinjectmapping path / to / injectmapping.txt -printclassencryption path/to/classencryption.txt -printstringencryption path/to/stringencryption.txt -printassetencryption path/to/assetencryption.txt -printresourceencryption path/to/resourceencryption.txt -printnativelibraryencryption path/to/nativelibraryencryption.txt -printmaindexlist path / to / maindexlist.txt You can read the reference guide for more information about these options and the files they produce.","title":"Mapping files"},{"location":"setup/standalone.html#signing-configuration","text":"DexGuard has the ability to sign your application ( .apk , .aab ). In order to do so, it will need the signing configuration, which can be specified as shown below: -keystore path/to/my/keystore.ks -keystorepassword supersecretpassword -keyalias myalias -keypassword supersecretpassword You may not want to put this, especially the passwords, in your main configuration file. One suggestion is to put these rules in a separate configuration file and include it in your main configuration file. Alternatively, if you don't want to check this file into source control or don't want to have to create the file for each checkout, you can pass the file to DexGuard directly: Linux/macOS bin/dexguard.sh -include dexguard-configuration.pro -include signing-config.pro Windows bin\\dexguard -include dexguard-configuration.pro -include signing-config.pro You can also choose to pass in the options directly instead of putting them in a file: Linux/macOS bin/dexguard.sh -include dexguard-configuration.pro \\ -keystore path/to/my/keystore.ks \\ -keystorepassword supersecretpassword \\ -keyalias myalias \\ -keypassword supersecretpassword Windows bin\\dexguard -include dexguard-configuration.pro ^ -keystore path/to/my/keystore.ks ^ -keystorepassword supersecretpassword ^ -keyalias myalias ^ -keypassword supersecretpassword","title":"Signing configuration"},{"location":"setup/standalone.html#default-debug-keystore","text":"The default debug keystore shipped with the Android SDK can be found in a hidden generated directory called .android in your home folder. The file has the name debug.keystore . You can use this keystore in your DexGuard signing configuration like so: -keystore <user.home>/.android/debug.keystore -keystorepassword android -keyalias androiddebugkey -keypassword android","title":"Default debug keystore"},{"location":"setup/upgrading.html","text":"From DexGuard 8.x \u00b6 The main difference in DexGuard 9.2 is that DexGuard now post-processes your application or library, rather than integrating itself into the build process. This means that the DexGuard input is now the unobfuscated application, app bundle or library produced by the standard Android build process. This section explains how you can upgrade your DexGuard 8.x setup to DexGuard 9.2 in a few quick steps using the DexGuard Gradle plugin . Upgrading Your Gradle Configuration \u00b6 Your app module build.gradle(.kts) file might look something like this: Groovy buildscript { repositories { maven { // For the DexGuard plugin. url '/path/to/dexguard/lib' } google () // For the Android plugin. mavenCentral () // For anything else. } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' classpath 'com.guardsquare.dexguard:dexguard-gradle-plugin:+' } } apply plugin: 'com.android.application' apply plugin: 'dexguard' android { ... buildTypes { debug { proguardFile getDefaultDexGuardFile ( 'dexguard-debug.pro' ) proguardFile 'dexguard-project.txt' proguardFile 'proguard-project.txt' } release { proguardFile getDefaultDexGuardFile ( 'dexguard-release.pro' ) proguardFile 'dexguard-project.txt' proguardFile 'proguard-project.txt' } } } Kotlin buildscript { repositories { maven { // For the DexGuard plugin. url = uri ( \"/path/to/dexguard/lib\" ) } google () // For the Android plugin. mavenCentral () // For anything else. } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) classpath ( \"com.guardsquare.dexguard:dexguard-gradle-plugin:+\" ) } } plugins { id ( \"com.android.application\" ) id ( \"dexguard\" ) } android { ... buildTypes { getByName ( \"debug\" ) { proguardFile ( extraDexGuardMethods . getDefaultDexGuardFile ( \"dexguard-debug.pro\" )) proguardFile ( \"dexguard-project.txt\" ) proguardFile ( \"proguard-project.txt\" ) } getByName ( \"release\" ) { proguardFile ( extraDexGuardMethods . getDefaultDexGuardFile ( \"dexguard-release.pro\" )) proguardFile ( \"dexguard-project.txt\" ) proguardFile ( \"proguard-project.txt\" ) } } } You should update the buildscript dependency to the new plugin: // Old plugin \"com.guardsquare.dexguard:dexguard-gradle-plugin:+\" // New plugin \"com.guardsquare:dexguard-gradle-plugin:+\" Manual download (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. url '/path/to/DexGuard/lib' } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:+' // The DexGuard Gradle plugin. } } Manual download (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. url = uri ( \"/path/to/DexGuard/lib\" ) } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:+\" ) // The DexGuard Gradle plugin. } } Maven (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:1.2.7' // The DexGuard Gradle plugin. } } Maven (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:1.2.7\" ) // The DexGuard Gradle plugin. } } You should remove the proguardFile configurations and set minifyEnabled and shrinkResources to false . Groovy apply plugin: 'com.android.application' apply plugin: 'dexguard' android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } Kotlin plugins { id ( \"com.android.application\" ) id ( \"dexguard\" ) } android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } You can specify your DexGuard configurations in a new dexguard block: Manual download (Groovy) android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } dexguard { path = '/path/to/dexguard' configurations { debug { defaultConfiguration 'dexguard-debug.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } } Manual download (Kotlin) android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } dexguard { path = \"/path/to/dexguard\" configurations { register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } } Maven (Groovy) android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } dexguard { version = '9.2.+' // the DexGuard version to automatically download configurations { debug { defaultConfiguration 'dexguard-debug.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } } Maven (Kotlin) android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } dexguard { version = \"9.2.+\" // the DexGuard version to automatically download configurations { register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } } See the Gradle plugin page for more details on configuring the DexGuard plugin. Version Check Plugin \u00b6 DexGuard 8.x came with a Gradle plugin, 'dexguard-versioncheck', which checks if you are using the latest available DexGuard version. In DexGuard 9 this plugin has been removed, so you can simply remove the plugin from your build.gradle file Maven (Groovy) apply plugin: 'dexguard-versioncheck' Maven (Kotlin) apply plugin : ' dexguard - versioncheck ' You can use the following replacements of the 'dexguard-versioncheck' plugin to ensure you always use an up-to-date version of DexGuard: Automatic updates through maven. Warnings in console and protection report. To automatically upgrade DexGuard you can configure DexGuard's plugin to fetch the latest release through maven by providing the version option in the dexguard block. Additionally, you will need to configure your buildscript to use Guardsquare's maven repository . DexGuard will print out a warning to it's console output when a newer version is available. The protection report will contain a banner when a newer version is available. License \u00b6 Previously, the DexGuard license file could be set via a system property by adding the following in the gradle.properties file: systemProp.dexguard.license = /path/to/dexguard-license.txt This has been replaced with a license option in the dexguard block: Groovy dexguard { license = \"/path/to/dexguard-license.txt\" // ... } Kotlin dexguard { license = \"/path/to/dexguard-license.txt\" // ... } DexGuard will also still look for your license in your home folder and in the environment variable DEXGUARD_LICENSE ; see the quick start page for more details. Setting system properties or arguments for the JVM running DexGuard \u00b6 Previously, the gradle.properties file could be used to specify system properties that should be taken into account by DexGuard, or to specify arguments to the JVM that runs DexGuard. As of DexGuard 9.0, such options should be provided via the new jvmArgs property of the DexGuard block instead. An exception to this rule is the dexguard.license system property, which has been promoted to a standalone property of the DexGuard block instead, as described in the previous section . For example, you may have a gradle.properties file as follows: # Set the JVM heap size org.gradle.jvmargs = -Xmx2048M # Set a system property for DexGuard systemProp.allow.incomplete.class.hierarchy = true These options should then be migrated to the jvmArgs property of the DexGuard block: Groovy dexguard { jvmArgs '-Xmx2048M' , '-Dallow.incomplete.class.hierarchy=true' // ... } Kotlin dexguard { jvmArgs ( \"-Xmx2048M\" , \"-Dallow.incomplete.class.hierarchy=true\" ) // ... } Executing DexGuard \u00b6 DexGuard outputs location The protected artefact is placed alongisde the unprotected one and has a -protected suffix in the name. All other output files are collected in the build/outputs/dexguard directory. A major difference between executing DexGuard 8.x and DexGuard 9.2 is that the protected application or library is built separately from the original. This means that the original will still be in the standard Android build location e.g. for a release application variant in build/outputs/apk/release/ DexGuard will produce the corresponding protected application in the same location and add a -protected suffix to the name. DexGuard will still be executed when you run the assemble task. For example, ./gradlew assembleRelease will build the unobfuscated application and then execute DexGuard to build the protected application. install task You can no longer use the install task to install an application as this will install the unprotected application, instead you can use adb e.g. adb install build/outputs/apk/release/MyApp-release-protected.apk . You can choose to run DexGuard in standalone mode or use the DexGuard Gradle plugin . See the quickstart section to continue setting up DexGuard. Preserving runtime-invisible annotations \u00b6 By default, R8/D8 will strip runtime-invisible annotations when building a release configuration. Since DexGuard now post-processes the binaries produced by R8/D8, this can cause problems if you rely on those annotations being visible to DexGuard. This may be the case if you use Espresso annotations, or annotation based DexGuard configuration. For a workaround, please visit this page From ProGuard \u00b6 Many developers already optimize the code in their projects with ProGuard or with R8. DexGuard is backward compatible with ProGuard: It understands all ProGuard configuration, plus additional options. It provides the same functionality, plus more optimizations and protection techniques. The main difference in execution is that DexGuard post-processes your application or library, rather than integrating itself into the build process. A Gradle plugin is provided to perform this step during the Gradle build. This section explains how you can upgrade your ProGuard setup to DexGuard in a few quick steps using the DexGuard Gradle plugin . Upgrading Your Gradle Configuration \u00b6 If your project already has ProGuard enabled, you should first disable it. The Android build process should produce an unobfuscated application or library that DexGuard can process. Your app module build.gradle(.kts) file might look something like this: Groovy apply plugin: 'com.android.application' android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled true shrinkResources true proguardFile getDefaultProguardFile ( 'proguard-android.txt' ) proguardFile 'proguard-project.txt' } } } Kotlin plugins { id ( \"com.android.application\" ) } android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = true isShrinkResources = true proguardFile ( getDefaultProguardFile ( \"proguard-android.txt\" )) proguardFile ( \"proguard-project.txt\" ) } } } You should remove the proguardFile configurations and set minifyEnabled and shrinkResources to false . Groovy apply plugin: 'com.android.application' android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } Kotlin plugins { id ( \"com.android.application\" ) } android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } After that, you can follow the quickstart section to configure the DexGuard Gradle plugin . Executing DexGuard \u00b6 DexGuard outputs location The protected artefact is placed alongisde the unprotected one and has a -protected suffix in the name. All other output files are collected in the build/outputs/dexguard directory. A major difference between executing ProGuard and DexGuard 9.2 is that the protected application or library is built separately from the original. This means that the original will still be in the standard Android build location e.g. for a release application variant in build/outputs/apk/release/ DexGuard will produce the corresponding protected application in the same location and add a -protected suffix to the name. DexGuard will still be executed when you run the assemble task. For example, ./gradlew assembleRelease will build the unobfuscated application and then execute DexGuard to build the protected application. install task You can no longer use the install task to install an application as this will install the unprotected application, instead you can use adb e.g. adb install build/outputs/apk/release/MyApp-release-protected.apk . Upgrading Your ProGuard Configuration \u00b6 Since DexGuard understands and needs the same fundamental options to make sure your app or library works ( -keep , -keepattributes ,...), your existing ProGuard configuration is a great start. Make sure the application still works. You can test your processed application right away. Since DexGuard not only processes the bytecode, but also the Android manifest, resources, resource files, asset files, and native libraries, it may need a few additional -keep options: Option ... may be necessary for Java construct -keep Class.forName -keepresources Resources#getIdentifier -keepresourcefiles System.loadLibrary ,... -keepresourcexmlattributenames AttributeSet#getAttributeName , AttributeSet#getAttributeValue -keepresourcexmlelements ApplicationInfo#metaData , Bundle#getString ,... Without the proper options, you may still see ResourceNotFoundExceptions, NullPointerExceptions, etc., if DexGuard unwittingly removes some expected resources. The option -addconfigurationdebugging can help to quickly find any missing options. It lets DexGuard instrument the code so the application prints out suggestions in the logcat, which you can just copy and paste into your configuration. Tune the initial configuration. DexGuard comes with tuned default configuration for the Android runtime and for common libraries, such as the Android support library, Dagger, and GSON. These libraries are listed in the Examples section. Chances are that you can simplify your own project-specific configuration accordingly. If you still have -keep options for the Android runtime or for any of the listed libraries, try removing them or commenting them out. DexGuard's tuned configuration generally allows for more optimizations and better obfuscation. Add options to further harden the application. DexGuard by default applies basic name obfuscation to the code and resources, but is only the start. You should still identify sensitive parts in your application and further harden those. The Protection Overview section provides a useful checklist. The following options may be relevant: Option -encryptassetfiles -encryptclasses -encryptmetadata -encryptnativelibraries -encryptresourcefiles -encryptresources -encryptstrings -obfuscatecode -virtualizecode -obfuscatejavascript -accessthroughreflection -assumenosideeffects The Usage section provides more details, with the new options compared to ProGuard highlighted . For more information on where to specify these rules and how to organise them, refer to the DexGuard standalone page.","title":"Upgrading"},{"location":"setup/upgrading.html#from-dexguard-8x","text":"The main difference in DexGuard 9.2 is that DexGuard now post-processes your application or library, rather than integrating itself into the build process. This means that the DexGuard input is now the unobfuscated application, app bundle or library produced by the standard Android build process. This section explains how you can upgrade your DexGuard 8.x setup to DexGuard 9.2 in a few quick steps using the DexGuard Gradle plugin .","title":"From DexGuard 8.x"},{"location":"setup/upgrading.html#upgrading-your-gradle-configuration","text":"Your app module build.gradle(.kts) file might look something like this: Groovy buildscript { repositories { maven { // For the DexGuard plugin. url '/path/to/dexguard/lib' } google () // For the Android plugin. mavenCentral () // For anything else. } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' classpath 'com.guardsquare.dexguard:dexguard-gradle-plugin:+' } } apply plugin: 'com.android.application' apply plugin: 'dexguard' android { ... buildTypes { debug { proguardFile getDefaultDexGuardFile ( 'dexguard-debug.pro' ) proguardFile 'dexguard-project.txt' proguardFile 'proguard-project.txt' } release { proguardFile getDefaultDexGuardFile ( 'dexguard-release.pro' ) proguardFile 'dexguard-project.txt' proguardFile 'proguard-project.txt' } } } Kotlin buildscript { repositories { maven { // For the DexGuard plugin. url = uri ( \"/path/to/dexguard/lib\" ) } google () // For the Android plugin. mavenCentral () // For anything else. } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) classpath ( \"com.guardsquare.dexguard:dexguard-gradle-plugin:+\" ) } } plugins { id ( \"com.android.application\" ) id ( \"dexguard\" ) } android { ... buildTypes { getByName ( \"debug\" ) { proguardFile ( extraDexGuardMethods . getDefaultDexGuardFile ( \"dexguard-debug.pro\" )) proguardFile ( \"dexguard-project.txt\" ) proguardFile ( \"proguard-project.txt\" ) } getByName ( \"release\" ) { proguardFile ( extraDexGuardMethods . getDefaultDexGuardFile ( \"dexguard-release.pro\" )) proguardFile ( \"dexguard-project.txt\" ) proguardFile ( \"proguard-project.txt\" ) } } } You should update the buildscript dependency to the new plugin: // Old plugin \"com.guardsquare.dexguard:dexguard-gradle-plugin:+\" // New plugin \"com.guardsquare:dexguard-gradle-plugin:+\" Manual download (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. url '/path/to/DexGuard/lib' } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:+' // The DexGuard Gradle plugin. } } Manual download (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. url = uri ( \"/path/to/DexGuard/lib\" ) } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:+\" ) // The DexGuard Gradle plugin. } } Maven (Groovy) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url \"https://maven.guardsquare.com\" // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex \"com\\\\.guardsquare.*\" } authentication { basic ( BasicAuthentication ) } } } dependencies { classpath 'com.android.tools.build:gradle:x.y.z' // The Android Gradle plugin. classpath 'com.guardsquare:dexguard-gradle-plugin:1.2.7' // The DexGuard Gradle plugin. } } Maven (Kotlin) buildscript { repositories { ... google () // For the Android Gradle plugin. mavenCentral () // For any dependencies. maven { // For the DexGuard Gradle plugin jar. credentials { username = \"${dexguardMavenUser}\" password = \"${dexguardMavenPassword}\" } url = uri ( \"https://maven.guardsquare.com\" ) // Only search for artifacts with groupId \"com.guardsquare.*\", // supported since gradle 5.1. content { includeGroupByRegex ( \"com\\\\.guardsquare.*\" ) } authentication { create < BasicAuthentication >( \"basic\" ) } } } dependencies { classpath ( \"com.android.tools.build:gradle:x.y.z\" ) // The Android Gradle plugin. classpath ( \"com.guardsquare:dexguard-gradle-plugin:1.2.7\" ) // The DexGuard Gradle plugin. } } You should remove the proguardFile configurations and set minifyEnabled and shrinkResources to false . Groovy apply plugin: 'com.android.application' apply plugin: 'dexguard' android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } Kotlin plugins { id ( \"com.android.application\" ) id ( \"dexguard\" ) } android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } You can specify your DexGuard configurations in a new dexguard block: Manual download (Groovy) android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } dexguard { path = '/path/to/dexguard' configurations { debug { defaultConfiguration 'dexguard-debug.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } } Manual download (Kotlin) android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } dexguard { path = \"/path/to/dexguard\" configurations { register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } } Maven (Groovy) android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } dexguard { version = '9.2.+' // the DexGuard version to automatically download configurations { debug { defaultConfiguration 'dexguard-debug.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } release { defaultConfiguration 'dexguard-release.pro' configuration 'dexguard-project.txt' configuration 'proguard-project.txt' } } } Maven (Kotlin) android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } dexguard { version = \"9.2.+\" // the DexGuard version to automatically download configurations { register ( \"debug\" ) { defaultConfiguration ( \"dexguard-debug.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } register ( \"release\" ) { defaultConfiguration ( \"dexguard-release.pro\" ) configuration ( \"dexguard-project.txt\" ) configuration ( \"proguard-project.txt\" ) } } } See the Gradle plugin page for more details on configuring the DexGuard plugin.","title":"Upgrading Your Gradle Configuration"},{"location":"setup/upgrading.html#version-check-plugin","text":"DexGuard 8.x came with a Gradle plugin, 'dexguard-versioncheck', which checks if you are using the latest available DexGuard version. In DexGuard 9 this plugin has been removed, so you can simply remove the plugin from your build.gradle file Maven (Groovy) apply plugin: 'dexguard-versioncheck' Maven (Kotlin) apply plugin : ' dexguard - versioncheck ' You can use the following replacements of the 'dexguard-versioncheck' plugin to ensure you always use an up-to-date version of DexGuard: Automatic updates through maven. Warnings in console and protection report. To automatically upgrade DexGuard you can configure DexGuard's plugin to fetch the latest release through maven by providing the version option in the dexguard block. Additionally, you will need to configure your buildscript to use Guardsquare's maven repository . DexGuard will print out a warning to it's console output when a newer version is available. The protection report will contain a banner when a newer version is available.","title":"Version Check Plugin"},{"location":"setup/upgrading.html#license","text":"Previously, the DexGuard license file could be set via a system property by adding the following in the gradle.properties file: systemProp.dexguard.license = /path/to/dexguard-license.txt This has been replaced with a license option in the dexguard block: Groovy dexguard { license = \"/path/to/dexguard-license.txt\" // ... } Kotlin dexguard { license = \"/path/to/dexguard-license.txt\" // ... } DexGuard will also still look for your license in your home folder and in the environment variable DEXGUARD_LICENSE ; see the quick start page for more details.","title":"License"},{"location":"setup/upgrading.html#setting-system-properties-or-arguments-for-the-jvm-running-dexguard","text":"Previously, the gradle.properties file could be used to specify system properties that should be taken into account by DexGuard, or to specify arguments to the JVM that runs DexGuard. As of DexGuard 9.0, such options should be provided via the new jvmArgs property of the DexGuard block instead. An exception to this rule is the dexguard.license system property, which has been promoted to a standalone property of the DexGuard block instead, as described in the previous section . For example, you may have a gradle.properties file as follows: # Set the JVM heap size org.gradle.jvmargs = -Xmx2048M # Set a system property for DexGuard systemProp.allow.incomplete.class.hierarchy = true These options should then be migrated to the jvmArgs property of the DexGuard block: Groovy dexguard { jvmArgs '-Xmx2048M' , '-Dallow.incomplete.class.hierarchy=true' // ... } Kotlin dexguard { jvmArgs ( \"-Xmx2048M\" , \"-Dallow.incomplete.class.hierarchy=true\" ) // ... }","title":"Setting system properties or arguments for the JVM running DexGuard"},{"location":"setup/upgrading.html#executing-dexguard","text":"DexGuard outputs location The protected artefact is placed alongisde the unprotected one and has a -protected suffix in the name. All other output files are collected in the build/outputs/dexguard directory. A major difference between executing DexGuard 8.x and DexGuard 9.2 is that the protected application or library is built separately from the original. This means that the original will still be in the standard Android build location e.g. for a release application variant in build/outputs/apk/release/ DexGuard will produce the corresponding protected application in the same location and add a -protected suffix to the name. DexGuard will still be executed when you run the assemble task. For example, ./gradlew assembleRelease will build the unobfuscated application and then execute DexGuard to build the protected application. install task You can no longer use the install task to install an application as this will install the unprotected application, instead you can use adb e.g. adb install build/outputs/apk/release/MyApp-release-protected.apk . You can choose to run DexGuard in standalone mode or use the DexGuard Gradle plugin . See the quickstart section to continue setting up DexGuard.","title":"Executing DexGuard"},{"location":"setup/upgrading.html#preserving-runtime-invisible-annotations","text":"By default, R8/D8 will strip runtime-invisible annotations when building a release configuration. Since DexGuard now post-processes the binaries produced by R8/D8, this can cause problems if you rely on those annotations being visible to DexGuard. This may be the case if you use Espresso annotations, or annotation based DexGuard configuration. For a workaround, please visit this page","title":"Preserving runtime-invisible annotations"},{"location":"setup/upgrading.html#from-proguard","text":"Many developers already optimize the code in their projects with ProGuard or with R8. DexGuard is backward compatible with ProGuard: It understands all ProGuard configuration, plus additional options. It provides the same functionality, plus more optimizations and protection techniques. The main difference in execution is that DexGuard post-processes your application or library, rather than integrating itself into the build process. A Gradle plugin is provided to perform this step during the Gradle build. This section explains how you can upgrade your ProGuard setup to DexGuard in a few quick steps using the DexGuard Gradle plugin .","title":"From ProGuard"},{"location":"setup/upgrading.html#upgrading-your-gradle-configuration_1","text":"If your project already has ProGuard enabled, you should first disable it. The Android build process should produce an unobfuscated application or library that DexGuard can process. Your app module build.gradle(.kts) file might look something like this: Groovy apply plugin: 'com.android.application' android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled true shrinkResources true proguardFile getDefaultProguardFile ( 'proguard-android.txt' ) proguardFile 'proguard-project.txt' } } } Kotlin plugins { id ( \"com.android.application\" ) } android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = true isShrinkResources = true proguardFile ( getDefaultProguardFile ( \"proguard-android.txt\" )) proguardFile ( \"proguard-project.txt\" ) } } } You should remove the proguardFile configurations and set minifyEnabled and shrinkResources to false . Groovy apply plugin: 'com.android.application' android { ... buildTypes { debug { minifyEnabled false shrinkResources false } release { minifyEnabled false shrinkResources false } } } Kotlin plugins { id ( \"com.android.application\" ) } android { ... buildTypes { getByName ( \"debug\" ) { isMinifyEnabled = false isShrinkResources = false } getByName ( \"release\" ) { isMinifyEnabled = false isShrinkResources = false } } } After that, you can follow the quickstart section to configure the DexGuard Gradle plugin .","title":"Upgrading Your Gradle Configuration"},{"location":"setup/upgrading.html#executing-dexguard_1","text":"DexGuard outputs location The protected artefact is placed alongisde the unprotected one and has a -protected suffix in the name. All other output files are collected in the build/outputs/dexguard directory. A major difference between executing ProGuard and DexGuard 9.2 is that the protected application or library is built separately from the original. This means that the original will still be in the standard Android build location e.g. for a release application variant in build/outputs/apk/release/ DexGuard will produce the corresponding protected application in the same location and add a -protected suffix to the name. DexGuard will still be executed when you run the assemble task. For example, ./gradlew assembleRelease will build the unobfuscated application and then execute DexGuard to build the protected application. install task You can no longer use the install task to install an application as this will install the unprotected application, instead you can use adb e.g. adb install build/outputs/apk/release/MyApp-release-protected.apk .","title":"Executing DexGuard"},{"location":"setup/upgrading.html#upgrading-your-proguard-configuration","text":"Since DexGuard understands and needs the same fundamental options to make sure your app or library works ( -keep , -keepattributes ,...), your existing ProGuard configuration is a great start. Make sure the application still works. You can test your processed application right away. Since DexGuard not only processes the bytecode, but also the Android manifest, resources, resource files, asset files, and native libraries, it may need a few additional -keep options: Option ... may be necessary for Java construct -keep Class.forName -keepresources Resources#getIdentifier -keepresourcefiles System.loadLibrary ,... -keepresourcexmlattributenames AttributeSet#getAttributeName , AttributeSet#getAttributeValue -keepresourcexmlelements ApplicationInfo#metaData , Bundle#getString ,... Without the proper options, you may still see ResourceNotFoundExceptions, NullPointerExceptions, etc., if DexGuard unwittingly removes some expected resources. The option -addconfigurationdebugging can help to quickly find any missing options. It lets DexGuard instrument the code so the application prints out suggestions in the logcat, which you can just copy and paste into your configuration. Tune the initial configuration. DexGuard comes with tuned default configuration for the Android runtime and for common libraries, such as the Android support library, Dagger, and GSON. These libraries are listed in the Examples section. Chances are that you can simplify your own project-specific configuration accordingly. If you still have -keep options for the Android runtime or for any of the listed libraries, try removing them or commenting them out. DexGuard's tuned configuration generally allows for more optimizations and better obfuscation. Add options to further harden the application. DexGuard by default applies basic name obfuscation to the code and resources, but is only the start. You should still identify sensitive parts in your application and further harden those. The Protection Overview section provides a useful checklist. The following options may be relevant: Option -encryptassetfiles -encryptclasses -encryptmetadata -encryptnativelibraries -encryptresourcefiles -encryptresources -encryptstrings -obfuscatecode -virtualizecode -obfuscatejavascript -accessthroughreflection -assumenosideeffects The Usage section provides more details, with the new options compared to ProGuard highlighted . For more information on where to specify these rules and how to organise them, refer to the DexGuard standalone page.","title":"Upgrading Your ProGuard Configuration"},{"location":"tools/androidstudio.html","text":"Setting up your project \u00b6 You can development your application or library as normal and apply DexGuard to the resulting application or library, as documented in DexGuard . Android Studio creates a standard build.gradle file in your project. You can optionally apply the DexGuard Gradle plugin, as documented in the Gradle Plugin section. Setting up the optional DexGuard configuration-editor plugin \u00b6 When editing ProGuard and DexGuard configuration files from the editor within Android Studio, the DexGuard plugin for Android Studio provides: syntax highlighting and validation; valid flags and keywords are highlighted, while invalid rules are red-underlined, to indicate an error syntax completion; valid flags, keywords, and class names are suggested while typing the identification of some common anti-patterns; some redundant or otherwise incorrect rules are yellow-underlined, to indicate a warning To install the plugin, open the Android Studio Preferences, and select \"Plugins\". Show \"All Plugins\" to see a list of the currently installed plugins. If \"DexGuard\" is not listed, select \"Install plugin from disk...\". Choose the plugin from the DexGuard studio directory: com.guardsquare.dexguard.studio_*.jar The DexGuard plugin will appear in the list of installed plugins. If the checkbox next to the DexGuard plugin is not marked, enable the DexGuard plugin by marking the checkbox. As with the installation of any plugin, a restart of Android Studio is recommended. By default, the file types automatically recognized by the plugin are: dexguard-*.txt dexguard.cfg These can be changed in the Android Studio Preferences, by selecting \"Editor \u203a File Types\". The registered file types are shown in the list. The file types associated with the DexGuard plugin are shown under \"DexGuard Rules Language\". Note that Android Studio uses its own validation for ProGuard rules, which are recognized by the file types: *.pro proguard-*.txt proguard.cfg For the DexGuard plugin to apply to such a file, it must be renamed to one of the file types associated with the DexGuard plugin.","title":"Android Studio Plugin"},{"location":"tools/androidstudio.html#setting-up-your-project","text":"You can development your application or library as normal and apply DexGuard to the resulting application or library, as documented in DexGuard . Android Studio creates a standard build.gradle file in your project. You can optionally apply the DexGuard Gradle plugin, as documented in the Gradle Plugin section.","title":"Setting up your project"},{"location":"tools/androidstudio.html#setting-up-the-optional-dexguard-configuration-editor-plugin","text":"When editing ProGuard and DexGuard configuration files from the editor within Android Studio, the DexGuard plugin for Android Studio provides: syntax highlighting and validation; valid flags and keywords are highlighted, while invalid rules are red-underlined, to indicate an error syntax completion; valid flags, keywords, and class names are suggested while typing the identification of some common anti-patterns; some redundant or otherwise incorrect rules are yellow-underlined, to indicate a warning To install the plugin, open the Android Studio Preferences, and select \"Plugins\". Show \"All Plugins\" to see a list of the currently installed plugins. If \"DexGuard\" is not listed, select \"Install plugin from disk...\". Choose the plugin from the DexGuard studio directory: com.guardsquare.dexguard.studio_*.jar The DexGuard plugin will appear in the list of installed plugins. If the checkbox next to the DexGuard plugin is not marked, enable the DexGuard plugin by marking the checkbox. As with the installation of any plugin, a restart of Android Studio is recommended. By default, the file types automatically recognized by the plugin are: dexguard-*.txt dexguard.cfg These can be changed in the Android Studio Preferences, by selecting \"Editor \u203a File Types\". The registered file types are shown in the list. The file types associated with the DexGuard plugin are shown under \"DexGuard Rules Language\". Note that Android Studio uses its own validation for ProGuard rules, which are recognized by the file types: *.pro proguard-*.txt proguard.cfg For the DexGuard plugin to apply to such a file, it must be renamed to one of the file types associated with the DexGuard plugin.","title":"Setting up the optional DexGuard configuration-editor plugin"},{"location":"tools/libraryrulesgenerator.html","text":"In order to generate all keep rules to instruct DexGuard to not touch anything contained in an aar file, you can execute the following Bash script on macOS or Linux bin/generate_keep_rules.sh <aar file> or this batch script on Windows bin/generate_keep_rules.bat <aar file> This will output a list of all required -keep , -keepresourcefiles and -keepresources rules for elements contained in the aar file.","title":"Library Rules Generator"},{"location":"tools/retrace.html","text":"ReTrace \u00b6 ReTrace is a companion tool for DexGuard (and for ProGuard) that 'de-obfuscates' stack traces. When an obfuscated program throws an exception, the resulting stack trace typically isn't very informative. Class names and method names have been replaced by short meaningless strings. Source file names and line numbers are missing altogether. While this may be intentional, it can also be inconvenient when debugging problems. Original code DexGuard Obfuscated code Mapping file Crash! Readable stack trace ReTrace Obfuscated stack trace ReTrace can read an obfuscated stack trace and restore it to what it would look like without obfuscation. The restoration is based on the mapping file that DexGuard can write out while obfuscating. The mapping file links the original class names and class member names to their obfuscated names. The DexGuard Gradle plugin, Ant plugin, and Eclipse plugin automatically write out mapping files to their traditional locations in your Android project: build/outputs/dexguard/<variant>/mapping/mapping.txt , bin/proguard/mapping.txt , and proguard/mapping.txt , respectively. Usage \u00b6 You can find the ReTrace jar in the lib directory of the DexGuard distribution. To run ReTrace, just type: java -jar retrace.jar [ options... ] mapping_file [ stacktrace_file ] Alternatively, the bin directory contains some short Linux and Windows scripts containing this command. These are the arguments: mapping_file Specifies the name of the mapping file, produced by DexGuard with the option \" -printmapping mapping_file \", while obfuscating the application that produced the stack trace. stacktrace_file Optionally specifies the name of the file containing the stack trace. If no file is specified, a stack trace is read from the standard input. The stack trace must be encoded with UTF-8 encoding. Blank lines and unrecognized lines are ignored. The following options are supported: -verbose Specifies to print out more informative stack traces that include not only method names, but also method return types and arguments. -greedy Attempts to retrace obfuscated classnames in otherwise unrecognized lines. Ths option might result in reduced performance when retracing large log files. -regex regular_expression Specifies the regular expression that is used to parse the lines in the stack trace. Specifying a different regular expression allows to de-obfuscate more general types of input than just stack traces. A relatively simple expression like this works for basic stack trace formats: (?:.*? at %c\\.%m\\(%s(?::%l)?\\))|(?:(?:.*?[:\"] +)?%c(?::.*)?) It for instance matches the following lines: Exception in thread \"main\" myapplication.MyException: Some message at com.example.MyClass.myMethod(MyClass.java:123) The regular expression is a Java regular expression (cfr. the documentation of java.util.regex.Pattern ), with a few additional wildcards: Wildcard Description Example %c matches a class name com.example.MyClass %C matches a class name with slashes com/example/MyClass %t matches a field type or method return type com.example.MyClass[] %f matches a field name myField %m matches a method name myMethod %a matches a list of method arguments boolean,int %s matches a source file name MyClass.java %l matches a line number inside a method 123 Elements that match these wildcards are de-obfuscated, when possible. Note that regular expressions must not contain any capturing groups. Use non-capturing groups instead: (?: ... ) You can print out the default regular expression by running ReTrace without arguments. It also matches more complex stack traces. The restored stack trace is printed to the standard output. The completeness of the restored stack trace depends on the presence of line number tables in the obfuscated class files: If all line numbers have been preserved while obfuscating the application, ReTrace will be able to restore the stack trace completely. If the line numbers have been removed, mapping obfuscated method names back to their original names has become ambiguous. Retrace will list all possible original method names for each line in the stack trace. The user can then try to deduce the actual stack trace manually, based on the logic of the program. Preserving line number tables is explained in detail in this example in the DexGuard User Manual. Source file names are currently restored based on the names of the outer-most classes. If you prefer to keep the obfuscated name, you can replace %s in the default regular expression by .* Unobfuscated elements and obfuscated elements for which no mapping is available will be left unchanged. Examples \u00b6 Restoring a stack trace with line numbers \u00b6 Assume for instance an application has been obfuscated using the following extra options: -printmapping mapping.txt -renamesourcefileattribute MyApplication -keepattributes SourceFile,LineNumberTable Now assume the processed application throws an exception: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.y.a(MyApplication:188) at proguard.y.a(MyApplication:158) at proguard.y.a(MyApplication:136) at proguard.y.a(MyApplication:66) at proguard.ProGuard.c(MyApplication:218) at proguard.ProGuard.a(MyApplication:82) at proguard.ProGuard.main(MyApplication:538) Caused by: java.io.IOException: No such file or directory at proguard.d.q.a(MyApplication:50) at proguard.y.a(MyApplication:184) ... 6 more If we have saved the stack trace in a file stacktrace.txt , we can use the following command to recover the stack trace: retrace mapping.txt stacktrace.txt The output will correspond to the original stack trace: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.InputReader.readInput(InputReader.java:188) at proguard.InputReader.readInput(InputReader.java:158) at proguard.InputReader.readInput(InputReader.java:136) at proguard.InputReader.execute(InputReader.java:66) at proguard.ProGuard.readInput(ProGuard.java:218) at proguard.ProGuard.execute(ProGuard.java:82) at proguard.ProGuard.main(ProGuard.java:538) Caused by: java.io.IOException: No such file or directory at proguard.io.DirectoryPump.pumpDataEntries(DirectoryPump.java:50) at proguard.InputReader.readInput(InputReader.java:184) ... 6 more Restoring a stack trace with line numbers (verbose) \u00b6 In the previous example, we could also use the verbose flag: java -jar retrace.jar -verbose mapping.txt stacktrace.txt The output will then look as follows: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPathEntry,proguard.io.DataEntryReader)(InputReader.java:188) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPath,int,int,proguard.io.DataEntryReader)(InputReader.java:158) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPath,proguard.io.DataEntryReader)(InputReader.java:136) at proguard.InputReader.void execute(proguard.classfile.ClassPool,proguard.classfile.ClassPool)(InputReader.java:66) at proguard.ProGuard.void readInput()(ProGuard.java:218) at proguard.ProGuard.void execute()(ProGuard.java:82) at proguard.ProGuard.void main(java.lang.String[])(ProGuard.java:538) Caused by: java.io.IOException: No such file or directory at proguard.io.DirectoryPump.void pumpDataEntries(proguard.io.DataEntryReader)(DirectoryPump.java:50) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPathEntry,proguard.io.DataEntryReader)(InputReader.java:184) ... 6 more Restoring a stack trace without line numbers \u00b6 Assume for instance the application DexGuard has been obfuscated using the following extra options, this time without preserving the line number tables: -printmapping mapping.txt A stack trace stacktrace.txt will then lack line number information, showing \"Unknown source\" instead: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.y.a(Unknown Source) at proguard.y.a(Unknown Source) at proguard.y.a(Unknown Source) at proguard.y.a(Unknown Source) at proguard.ProGuard.c(Unknown Source) at proguard.ProGuard.a(Unknown Source) at proguard.ProGuard.main(Unknown Source) Caused by: java.io.IOException: No such file or directory at proguard.d.q.a(Unknown Source) ... 7 more We can still use the same command to recover the stack trace: java -jar retrace.jar mapping.txt stacktrace.txt The output will now list all alternative original method names for each ambiguous obfuscated method name: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.ProGuard.readInput(ProGuard.java) at proguard.ProGuard.execute(ProGuard.java) optimize(ProGuard.java) createPrintStream(ProGuard.java) closePrintStream(ProGuard.java) fileName(ProGuard.java) at proguard.ProGuard.main(ProGuard.java) Caused by: java.io.IOException: No such file or directory at proguard.io.DirectoryPump.pumpDataEntries(DirectoryPump.java) readFiles(DirectoryPump.java) For instance, ReTrace can't tell if the method a corresponds to execute or to readInput , so it lists both. You need to figure it out based on your knowledge of the application. Having line numbers and unambiguous names clearly is a lot easier, so you should consider preserving the line numbers when you obfuscate your application. Specifications \u00b6 A mapping file contains the original names and the obfuscated names of classes, fields, and methods. DexGuard can write out such a file while obfuscating an application or a library, with the option -printmapping . ReTrace requires the mapping file to restore obfuscated stack traces to more readable versions. It is a readable file with UTF-8 encoding, so you can also look up names in an ordinary text viewer. The format is pretty self-explanatory, but we describe its details here. A mapping file contains a sequence of records of the following form: classline fieldline * methodline * A classline , with a trailing colon, specifies a class and its obfuscated name: originalclassname -> obfuscatedclassname: A fieldline , with 4 leading spaces, specifies a field and its obfuscated name: originalfieldtype originalfieldname -> obfuscatedfieldname A methodline , with 4 leading spaces, specifies a method and its obfuscated name: [startline:endline:]originalreturntype [originalclassname.]originalmethodname(originalargumenttype,...)[:originalstartline[:originalendline]] -> obfuscatedmethodname An asterisk \"*\" means the line may occur any number of times. Square brackets \"[]\" mean that their contents are optional. Ellipsis dots \"...\" mean that any number of the preceding items may be specified. The colon \":\", the separator \".\", and the arrow \"->\" are literal tokens. Example \u00b6 The following snippet gives an impression of the structure of a mapping file: com example.application.ArgumentWordReader -> com.example.a.a: java.lang.String[] arguments -> a int index -> a 36:57:void <init>(java.lang.String[],java.io.File) -> <init> 64:64:java.lang.String nextLine() -> a 72:72:java.lang.String lineLocationDescription() -> b com.example.application.Main -> com.example.application.Main: com.example.application.Configuration configuration -> a 50:66:void <init>(com.example.application.Configuration) -> <init> 74:228:void execute() -> a 2039:2056:void com.example.application.GPL.check():39:56 -> a 2039:2056:void execute():76 -> a 2236:2252:void printConfiguration():236:252 -> a 2236:2252:void execute():80 -> a 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a 3260:3268:void readInput():260:268 -> a 3260:3268:void execute():97 -> a You can see the names of classes and their fields and methods: The fields and methods are listed in ProGuard configuration format (javap format), with descriptors that have return types and argument types but no argument names. In the above example: void <init>(java.lang.String[],java.io.File) refers to a constructor with a String array argument and a File argument. A method may have a leading line number range, if it is known from the original source code (see Producing useful obfuscated stack traces in the Examples section). Unlike method names, line numbers are unique within a class, so ReTrace can resolve lines in a stack trace without ambiguities. For example: 74:228:void execute() refers to a method execute , defined on lines 74 to 228. The obfuscated method name follows the arrow. For example: 74:228:void execute() -> a shows that method execute has been renamed to a . Multiple fields and methods can get the same obfuscated names, as long as their descriptors are different. Inlined methods \u00b6 The mapping file accounts for the added complexity of inlined methods (as of ProGuard/ReTrace version 5.2). The optimization step may inline methods into other methods \u2014 recursively even. A single line in an obfuscated stack trace can then correspond to multiple lines in the original stack trace: the line that throws the exception followed by one or more nested method calls. In such cases, the mapping file repeats the leading line number range on subsequent lines. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a The subsequent lines correspond to the subsequent lines of the original stack trace. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a refers to method createPrintWriterOut called from and inlined in printConfiguration , in turn called from and inlined in method execute . An original method name may have a preceding class name, if the method originates from a different class. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a shows that method createPrintWriterOut was originally defined in class PrintWriterUtil . A single trailing line number corresponds to an inlined method call. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a specifies that method execute called printConfiguration on line 80, and printconfiguration called createPrintWriterOut on line 243. A traling line number range corresponds to the final inlined method body. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a shows that method createPrintWriterOut covered lines 40 to 42. The leading line number range is synthetic, to avoid ambiguities with other code in the same class. DexGuard makes up the range, but tries to make it similar-looking to the original code (by adding offsets that are multiples of 1000), for convenience. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a created synthetic range 3040:3042 in the bytecode of class Main to be unique but still resemble source code range 40:42 in class PrintWriterUtil . Tools that don't account for these repeated line number ranges, like older versions of ReTrace, may still degrade gracefully by outputting the subsequent lines without interpreting them.","title":"ReTrace"},{"location":"tools/retrace.html#retrace","text":"ReTrace is a companion tool for DexGuard (and for ProGuard) that 'de-obfuscates' stack traces. When an obfuscated program throws an exception, the resulting stack trace typically isn't very informative. Class names and method names have been replaced by short meaningless strings. Source file names and line numbers are missing altogether. While this may be intentional, it can also be inconvenient when debugging problems. Original code DexGuard Obfuscated code Mapping file Crash! Readable stack trace ReTrace Obfuscated stack trace ReTrace can read an obfuscated stack trace and restore it to what it would look like without obfuscation. The restoration is based on the mapping file that DexGuard can write out while obfuscating. The mapping file links the original class names and class member names to their obfuscated names. The DexGuard Gradle plugin, Ant plugin, and Eclipse plugin automatically write out mapping files to their traditional locations in your Android project: build/outputs/dexguard/<variant>/mapping/mapping.txt , bin/proguard/mapping.txt , and proguard/mapping.txt , respectively.","title":"ReTrace"},{"location":"tools/retrace.html#usage","text":"You can find the ReTrace jar in the lib directory of the DexGuard distribution. To run ReTrace, just type: java -jar retrace.jar [ options... ] mapping_file [ stacktrace_file ] Alternatively, the bin directory contains some short Linux and Windows scripts containing this command. These are the arguments: mapping_file Specifies the name of the mapping file, produced by DexGuard with the option \" -printmapping mapping_file \", while obfuscating the application that produced the stack trace. stacktrace_file Optionally specifies the name of the file containing the stack trace. If no file is specified, a stack trace is read from the standard input. The stack trace must be encoded with UTF-8 encoding. Blank lines and unrecognized lines are ignored. The following options are supported: -verbose Specifies to print out more informative stack traces that include not only method names, but also method return types and arguments. -greedy Attempts to retrace obfuscated classnames in otherwise unrecognized lines. Ths option might result in reduced performance when retracing large log files. -regex regular_expression Specifies the regular expression that is used to parse the lines in the stack trace. Specifying a different regular expression allows to de-obfuscate more general types of input than just stack traces. A relatively simple expression like this works for basic stack trace formats: (?:.*? at %c\\.%m\\(%s(?::%l)?\\))|(?:(?:.*?[:\"] +)?%c(?::.*)?) It for instance matches the following lines: Exception in thread \"main\" myapplication.MyException: Some message at com.example.MyClass.myMethod(MyClass.java:123) The regular expression is a Java regular expression (cfr. the documentation of java.util.regex.Pattern ), with a few additional wildcards: Wildcard Description Example %c matches a class name com.example.MyClass %C matches a class name with slashes com/example/MyClass %t matches a field type or method return type com.example.MyClass[] %f matches a field name myField %m matches a method name myMethod %a matches a list of method arguments boolean,int %s matches a source file name MyClass.java %l matches a line number inside a method 123 Elements that match these wildcards are de-obfuscated, when possible. Note that regular expressions must not contain any capturing groups. Use non-capturing groups instead: (?: ... ) You can print out the default regular expression by running ReTrace without arguments. It also matches more complex stack traces. The restored stack trace is printed to the standard output. The completeness of the restored stack trace depends on the presence of line number tables in the obfuscated class files: If all line numbers have been preserved while obfuscating the application, ReTrace will be able to restore the stack trace completely. If the line numbers have been removed, mapping obfuscated method names back to their original names has become ambiguous. Retrace will list all possible original method names for each line in the stack trace. The user can then try to deduce the actual stack trace manually, based on the logic of the program. Preserving line number tables is explained in detail in this example in the DexGuard User Manual. Source file names are currently restored based on the names of the outer-most classes. If you prefer to keep the obfuscated name, you can replace %s in the default regular expression by .* Unobfuscated elements and obfuscated elements for which no mapping is available will be left unchanged.","title":"Usage"},{"location":"tools/retrace.html#examples","text":"","title":"Examples"},{"location":"tools/retrace.html#with","text":"Assume for instance an application has been obfuscated using the following extra options: -printmapping mapping.txt -renamesourcefileattribute MyApplication -keepattributes SourceFile,LineNumberTable Now assume the processed application throws an exception: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.y.a(MyApplication:188) at proguard.y.a(MyApplication:158) at proguard.y.a(MyApplication:136) at proguard.y.a(MyApplication:66) at proguard.ProGuard.c(MyApplication:218) at proguard.ProGuard.a(MyApplication:82) at proguard.ProGuard.main(MyApplication:538) Caused by: java.io.IOException: No such file or directory at proguard.d.q.a(MyApplication:50) at proguard.y.a(MyApplication:184) ... 6 more If we have saved the stack trace in a file stacktrace.txt , we can use the following command to recover the stack trace: retrace mapping.txt stacktrace.txt The output will correspond to the original stack trace: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.InputReader.readInput(InputReader.java:188) at proguard.InputReader.readInput(InputReader.java:158) at proguard.InputReader.readInput(InputReader.java:136) at proguard.InputReader.execute(InputReader.java:66) at proguard.ProGuard.readInput(ProGuard.java:218) at proguard.ProGuard.execute(ProGuard.java:82) at proguard.ProGuard.main(ProGuard.java:538) Caused by: java.io.IOException: No such file or directory at proguard.io.DirectoryPump.pumpDataEntries(DirectoryPump.java:50) at proguard.InputReader.readInput(InputReader.java:184) ... 6 more","title":"Restoring a stack trace with line numbers"},{"location":"tools/retrace.html#withverbose","text":"In the previous example, we could also use the verbose flag: java -jar retrace.jar -verbose mapping.txt stacktrace.txt The output will then look as follows: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPathEntry,proguard.io.DataEntryReader)(InputReader.java:188) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPath,int,int,proguard.io.DataEntryReader)(InputReader.java:158) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPath,proguard.io.DataEntryReader)(InputReader.java:136) at proguard.InputReader.void execute(proguard.classfile.ClassPool,proguard.classfile.ClassPool)(InputReader.java:66) at proguard.ProGuard.void readInput()(ProGuard.java:218) at proguard.ProGuard.void execute()(ProGuard.java:82) at proguard.ProGuard.void main(java.lang.String[])(ProGuard.java:538) Caused by: java.io.IOException: No such file or directory at proguard.io.DirectoryPump.void pumpDataEntries(proguard.io.DataEntryReader)(DirectoryPump.java:50) at proguard.InputReader.void readInput(java.lang.String,proguard.ClassPathEntry,proguard.io.DataEntryReader)(InputReader.java:184) ... 6 more","title":"Restoring a stack trace with line numbers (verbose)"},{"location":"tools/retrace.html#without","text":"Assume for instance the application DexGuard has been obfuscated using the following extra options, this time without preserving the line number tables: -printmapping mapping.txt A stack trace stacktrace.txt will then lack line number information, showing \"Unknown source\" instead: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.y.a(Unknown Source) at proguard.y.a(Unknown Source) at proguard.y.a(Unknown Source) at proguard.y.a(Unknown Source) at proguard.ProGuard.c(Unknown Source) at proguard.ProGuard.a(Unknown Source) at proguard.ProGuard.main(Unknown Source) Caused by: java.io.IOException: No such file or directory at proguard.d.q.a(Unknown Source) ... 7 more We can still use the same command to recover the stack trace: java -jar retrace.jar mapping.txt stacktrace.txt The output will now list all alternative original method names for each ambiguous obfuscated method name: java.io.IOException: Can't read [dummy.jar] (No such file or directory) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.InputReader.execute(InputReader.java) readInput(InputReader.java) at proguard.ProGuard.readInput(ProGuard.java) at proguard.ProGuard.execute(ProGuard.java) optimize(ProGuard.java) createPrintStream(ProGuard.java) closePrintStream(ProGuard.java) fileName(ProGuard.java) at proguard.ProGuard.main(ProGuard.java) Caused by: java.io.IOException: No such file or directory at proguard.io.DirectoryPump.pumpDataEntries(DirectoryPump.java) readFiles(DirectoryPump.java) For instance, ReTrace can't tell if the method a corresponds to execute or to readInput , so it lists both. You need to figure it out based on your knowledge of the application. Having line numbers and unambiguous names clearly is a lot easier, so you should consider preserving the line numbers when you obfuscate your application.","title":"Restoring a stack trace without line numbers"},{"location":"tools/retrace.html#specifications","text":"A mapping file contains the original names and the obfuscated names of classes, fields, and methods. DexGuard can write out such a file while obfuscating an application or a library, with the option -printmapping . ReTrace requires the mapping file to restore obfuscated stack traces to more readable versions. It is a readable file with UTF-8 encoding, so you can also look up names in an ordinary text viewer. The format is pretty self-explanatory, but we describe its details here. A mapping file contains a sequence of records of the following form: classline fieldline * methodline * A classline , with a trailing colon, specifies a class and its obfuscated name: originalclassname -> obfuscatedclassname: A fieldline , with 4 leading spaces, specifies a field and its obfuscated name: originalfieldtype originalfieldname -> obfuscatedfieldname A methodline , with 4 leading spaces, specifies a method and its obfuscated name: [startline:endline:]originalreturntype [originalclassname.]originalmethodname(originalargumenttype,...)[:originalstartline[:originalendline]] -> obfuscatedmethodname An asterisk \"*\" means the line may occur any number of times. Square brackets \"[]\" mean that their contents are optional. Ellipsis dots \"...\" mean that any number of the preceding items may be specified. The colon \":\", the separator \".\", and the arrow \"->\" are literal tokens.","title":"Specifications"},{"location":"tools/retrace.html#example","text":"The following snippet gives an impression of the structure of a mapping file: com example.application.ArgumentWordReader -> com.example.a.a: java.lang.String[] arguments -> a int index -> a 36:57:void <init>(java.lang.String[],java.io.File) -> <init> 64:64:java.lang.String nextLine() -> a 72:72:java.lang.String lineLocationDescription() -> b com.example.application.Main -> com.example.application.Main: com.example.application.Configuration configuration -> a 50:66:void <init>(com.example.application.Configuration) -> <init> 74:228:void execute() -> a 2039:2056:void com.example.application.GPL.check():39:56 -> a 2039:2056:void execute():76 -> a 2236:2252:void printConfiguration():236:252 -> a 2236:2252:void execute():80 -> a 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a 3260:3268:void readInput():260:268 -> a 3260:3268:void execute():97 -> a You can see the names of classes and their fields and methods: The fields and methods are listed in ProGuard configuration format (javap format), with descriptors that have return types and argument types but no argument names. In the above example: void <init>(java.lang.String[],java.io.File) refers to a constructor with a String array argument and a File argument. A method may have a leading line number range, if it is known from the original source code (see Producing useful obfuscated stack traces in the Examples section). Unlike method names, line numbers are unique within a class, so ReTrace can resolve lines in a stack trace without ambiguities. For example: 74:228:void execute() refers to a method execute , defined on lines 74 to 228. The obfuscated method name follows the arrow. For example: 74:228:void execute() -> a shows that method execute has been renamed to a . Multiple fields and methods can get the same obfuscated names, as long as their descriptors are different.","title":"Example"},{"location":"tools/retrace.html#inlined-methods","text":"The mapping file accounts for the added complexity of inlined methods (as of ProGuard/ReTrace version 5.2). The optimization step may inline methods into other methods \u2014 recursively even. A single line in an obfuscated stack trace can then correspond to multiple lines in the original stack trace: the line that throws the exception followed by one or more nested method calls. In such cases, the mapping file repeats the leading line number range on subsequent lines. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a The subsequent lines correspond to the subsequent lines of the original stack trace. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a refers to method createPrintWriterOut called from and inlined in printConfiguration , in turn called from and inlined in method execute . An original method name may have a preceding class name, if the method originates from a different class. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a shows that method createPrintWriterOut was originally defined in class PrintWriterUtil . A single trailing line number corresponds to an inlined method call. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a 3040:3042:void printConfiguration():243 -> a 3040:3042:void execute():80 -> a specifies that method execute called printConfiguration on line 80, and printconfiguration called createPrintWriterOut on line 243. A traling line number range corresponds to the final inlined method body. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a shows that method createPrintWriterOut covered lines 40 to 42. The leading line number range is synthetic, to avoid ambiguities with other code in the same class. DexGuard makes up the range, but tries to make it similar-looking to the original code (by adding offsets that are multiples of 1000), for convenience. For example: 3040:3042:java.io.PrintWriter com.example.application.util.PrintWriterUtil.createPrintWriterOut(java.io.File):40:42 -> a created synthetic range 3040:3042 in the bytecode of class Main to be unique but still resemble source code range 40:42 in class PrintWriterUtil . Tools that don't account for these repeated line number ranges, like older versions of ReTrace, may still degrade gracefully by outputting the subsequent lines without interpreting them.","title":"Inlined methods"}]}